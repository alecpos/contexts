[
  {
    "source": "bioverse-client/app/utils/actions/admin/dashboard-scripts.ts",
    "exports": [
      {
        "name": "AdminOrderDashboardFetch",
        "kind": "function",
        "signature": "export async function AdminOrderDashboardFetch() {\n    const { data: completeOrderData, error: orderError } =\n        await getAllOrdersForAdminTable();\n\n    const renewalOrderData = await getAllRenewalOrdersForAdminOrderTable();\n\n    if (!completeOrderData && orderError) {\n        console.error(\n            'Order Fetching for general orders failed. error message: ',\n            orderError.message\n        );\n    }\n    const generalOrders = prescriptionRequestToAdminDashboard(\n        completeOrderData ?? []\n    );\n\n    const renewalOrders = renewalOrderToProviderDashboard(renewalOrderData);\n\n    const mergedOrders = concat(renewalOrders, generalOrders);\n    \n    mergedOrders.sort((a, b) => {\n        const dateA = new Date(a.created_at);\n        const dateB = new Date(b.created_at);\n        return dateB.getTime() - dateA.getTime();\n    });\n    \n\n    return mergedOrders;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/admin/dashboard-scripts.ts",
      "bioverse-client/app/components/admin/all-orders/page-container.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/admin/parsers.ts",
    "exports": [
      {
        "name": "prescriptionRequestToAdminDashboard",
        "kind": "variable",
        "signature": "prescriptionRequestToAdminDashboard = (\n    res: any[],\n): PatientOrderAdminDetails[] =>\n    res.map((orderItem) => {\n        // Check if both received and completed are populated\n        const hasValidProcessingTime = orderItem.received != null && orderItem.completed != null;\n        \n        return {\n            id: orderItem.id,\n            pharmacy_id: getTrackingId(orderItem),\n            providerName: orderItem.provider_name,\n            patientId: orderItem.customer_uid,\n            state: orderItem.state,\n            patient_first_name:orderItem.first_name,\n            patient_last_name:orderItem.last_name,\n            date_of_birth:orderItem.date_of_birth,\n            pharmacy: orderItem.assigned_pharmacy,\n            product_name: orderItem.variant_text != null ? `${orderItem.product_name} ${orderItem.variant_text}` : orderItem.product_name,\n            order_status: orderItem.order_status,\n            shipping_status: orderItem.shipping_status,\n            amount_paid: orderItem.price,\n            variant: orderItem.variant_text,\n\n            // Include processing_time only if both received and completed are populated\n            processing_time: hasValidProcessingTime \n                ? getDateHourDifference(new Date(orderItem.received), new Date(orderItem.completed))\n                : null,\n            tracking_number: orderItem.tracking_number,\n            updated: orderItem.last_updated,\n            prescribed_time:orderItem.prescribed_time,\n            created_at: orderItem.created_at,\n            is_escalated:orderItem.is_escalated\n\n        };\n    })"
      },
      {
        "name": "renewalOrderToProviderDashboard",
        "kind": "variable",
        "signature": "renewalOrderToProviderDashboard = (\n    renewalOrders: any[],\n): PatientOrderAdminDetails[] => {\n    return renewalOrders.map((renewalOrder) => {\n        const hasValidProcessingTime = renewalOrder.received != null && renewalOrder.completed != null;\n        \n        return {\n            id: renewalOrder.id,\n            pharmacy_id: getTrackingId(renewalOrder),\n            providerName: renewalOrder.provider_name,\n            patientId: renewalOrder.customer_uid,\n            state: renewalOrder.state,\n            patient_first_name:renewalOrder.first_name,\n            patient_last_name:renewalOrder.last_name,\n            date_of_birth:renewalOrder.date_of_birth,\n            pharmacy: renewalOrder.assigned_pharmacy,\n            product_name: renewalOrder.product_name,\n            order_status: renewalOrder.order_status,\n            shipping_status: renewalOrder.shipping_status,\n            amount_paid: renewalOrder.price,\n            variant: renewalOrder.variant_text,\n\n            // Include processing_time only if both received and completed are populated\n            processing_time: hasValidProcessingTime \n                ? getDateHourDifference(new Date(renewalOrder.received), new Date(renewalOrder.completed))\n                : null,\n            tracking_number: renewalOrder.tracking_number,\n            updated: renewalOrder.last_updated,\n            prescribed_time:renewalOrder.prescribed_time,\n            created_at: renewalOrder.created_at,\n            is_escalated:renewalOrder.is_escalated\n        };\n    });\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(administration)/admin/order-administration/_components/admin-parser.ts",
      "bioverse-client/app/(administration)/admin/order-administration/_components/administrator-order-table.tsx",
      "bioverse-client/app/utils/actions/admin/dashboard-scripts.ts",
      "bioverse-client/app/utils/actions/admin/parsers.ts",
      "bioverse-client/app/utils/actions/provider/dashboard-scripts.ts",
      "bioverse-client/app/utils/actions/provider/parsers.ts",
      "bioverse-client/app/components/provider-portal/order-table/utils/assigned-order-fetch-helper.ts",
      "bioverse-client/_deprecated/clinical-intake-flow/order-table/utils/assigned-order-fetch-helper.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/alternatives/weight-loss/alternative-weight-loss-actions.ts",
    "exports": [
      {
        "name": "verifyAlternativeRequiredOrderData",
        "kind": "function",
        "signature": "export async function verifyAlternativeRequiredOrderData(\n    orderId: string | number\n): Promise<{\n    status: Status;\n    data: {\n        code: VERIFY_ORDER_DATA_CODES;\n        order_data: ServerSideOrderData | null;\n    };\n}> {\n    const supabase = createSupabaseServiceClient();\n    const userId = (await readUserSession()).data.session?.user.id;\n\n    const { data: order_data, error } = await supabase\n        .from('orders')\n        .select(\n            'id, customer_uid, order_status, product_href, assigned_provider, metadata'\n        )\n        .eq('id', orderId)\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            'verifyOrderData issue, orderId - ',\n            orderId,\n            ' user ID - ',\n            userId,\n            'error message - ',\n            error\n        );\n\n        return {\n            status: Status.Error,\n            data: {\n                code: VERIFY_ORDER_DATA_CODES.NO_ORDER,\n                order_data: null,\n            },\n        };\n    }\n\n    if (!order_data) {\n        return {\n            status: Status.Failure,\n            data: { code: VERIFY_ORDER_DATA_CODES.NO_ORDER, order_data: null },\n        };\n    }\n\n    if (order_data.customer_uid != userId) {\n        return {\n            status: Status.Failure,\n            data: { code: VERIFY_ORDER_DATA_CODES.NO_ORDER, order_data: null },\n        };\n    }\n\n    const alternative_options = order_data.metadata?.alternative_options ?? [];\n\n    //We need the status to be Denied-CardDown to make sure this order went through the recommendation flow.\n    if (\n        order_data.order_status !== 'Denied-CardDown' ||\n        isEmpty(alternative_options)\n    ) {\n        return {\n            status: Status.Failure,\n            data: {\n                code: VERIFY_ORDER_DATA_CODES.NOT_ELIGIBLE,\n                order_data: null,\n            },\n        };\n    }\n\n    return {\n        status: Status.Success,\n        data: {\n            code: VERIFY_ORDER_DATA_CODES.SUCCESS,\n            order_data: order_data as ServerSideOrderData,\n        },\n    };\n}"
      },
      {
        "name": "collectInformationToCreateAlternativeOrder",
        "kind": "function",
        "signature": "export async function collectInformationToCreateAlternativeOrder(\n    order_data: ServerSideOrderData\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const price_ID =\n        ALTERNATIVE_PRODUCT_PRICE_MAPPING[\n            order_data.metadata.selected_alternative_product\n        ][order_data.metadata.selected_alternative_cadence][\n            process.env.NEXT_PUBLIC_ENVIRONMENT!\n        ];\n    const coupon_ID =\n        ALTERNATIVE_PRODUCT_DISCOUNT_MAPPING[\n            order_data.metadata.selected_alternative_product\n        ][order_data.metadata.selected_alternative_cadence][\n            process.env.NEXT_PUBLIC_ENVIRONMENT!\n        ];\n\n    const { data: profile_data, error: profile_table_error } = await supabase\n        .from('profiles')\n        .select(\n            'first_name, last_name, stripe_customer_id, address_line1, address_line2, city, state, zip'\n        )\n        .eq('id', order_data.customer_uid)\n        .limit(1)\n        .single();\n\n    if (profile_table_error) {\n        console.error(\n            'collectInformationToCreateAlternativeOrder error ',\n            profile_table_error\n        );\n        return;\n    }\n\n    const stripePaymentMethodData = await fetchDefaultCardForCustomer(\n        order_data.customer_uid\n    );\n\n    return {\n        profileData: profile_data as ServerSideProfileData,\n\n        stripeData: {\n            priceId: price_ID,\n            couponId: coupon_ID,\n            customerDefaultPaymentMethodId:\n                stripePaymentMethodData.defaultPaymentMethodId,\n        } as ServerSideStripeData,\n    };\n}"
      },
      {
        "name": "confirmAlternativeOrder",
        "kind": "function",
        "signature": "export async function confirmAlternativeOrder(\n    profile_data: ServerSideProfileData,\n    order_data: ServerSideOrderData,\n    stripe_data: ServerSideStripeData\n) {\n    if (order_data.order_status !== 'Denied-CardDown') {\n        console.error(\n            'collectInformationToCreateAlternativeOrder was given an order - ',\n            order_data.id,\n            'which was in a status - ',\n            order_data.order_status\n        );\n        return Status.Failure;\n    }\n\n    const product_href = order_data.metadata.selected_alternative_product;\n    const cadence = order_data.metadata.selected_alternative_cadence;\n    let pharmacy: string;\n    if ((product_href as PRODUCT_HREF) === PRODUCT_HREF.WL_CAPSULE) {\n        pharmacy = 'empower';\n    } else pharmacy = 'curexa';\n\n    const getVariant = (): number => {\n        if (product_href === 'metformin') {\n            return 0;\n        } else {\n            if (cadence === 'monthly') {\n                return 0;\n            } else return 1;\n        }\n    };\n\n    const getVariantText = (): string => {\n        if (product_href === 'metformin') {\n            return '90 doses';\n        } else {\n            if (cadence === 'monthly') {\n                return '30 capsules';\n            } else {\n                return '90 capsules';\n            }\n        }\n    };\n\n    const newOrder: OrdersSBR = {\n        customer_uid: order_data.customer_uid,\n        variant_index: getVariant(),\n        variant_text: getVariantText(),\n        subscription_type: order_data.metadata.selected_alternative_cadence,\n        stripe_metadata: {\n            clientSecret: '',\n            setupIntentId: '',\n            paymentMethodId: stripe_data.customerDefaultPaymentMethodId,\n        },\n        order_status: 'Unapproved-CardDown',\n        product_href: order_data.metadata.selected_alternative_product,\n        price_id: stripe_data.priceId,\n        // discount_id: [stripe_data.couponId],\n        // price_id: 'price_1Pn6QsDyFtOu3ZuTnsVelapz', not correct.\n        discount_id: [],\n        assigned_pharmacy: pharmacy,\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n        address_line1: profile_data.address_line1,\n        address_line2: profile_data.address_line2,\n        city: profile_data.city,\n        state: profile_data.state,\n        zip: profile_data.zip,\n        source: 'alternative',\n    };\n\n    const new_order_data = await insertNewManualOrder(newOrder);\n\n    if (product_href === PRODUCT_HREF.METFORMIN) {\n        await createUserStatusTagWAction(\n            StatusTag.Review,\n            String(new_order_data.id),\n            StatusTagAction.REPLACE,\n            order_data.customer_uid,\n            'Sending metformin order to review from alternative product flow.',\n            'ffabc905-5508-4d54-98fb-1e2ef2b9e99a',\n            [StatusTag.Review]\n        );\n\n        await updateOrder(order_data.id, {\n            order_status: 'Alternative-Confirmed',\n        });\n\n        return Status.Success;\n    }\n\n    if (product_href === PRODUCT_HREF.WL_CAPSULE) {\n        try {\n            const { type: orderType, data: fetchedOrderData } =\n                await fetchOrderData(String(new_order_data.id));\n\n            const { data: patientData, error: patientDataError } =\n                await getPatientInformationById(order_data.customer_uid);\n\n            const empowerScriptData = generateEmpowerScript(\n                patientData!,\n                fetchedOrderData,\n                orderType,\n                {\n                    height_feet: 0,\n                    height_inches: 0,\n                    weight_lbs: 0,\n                    bmi: 0,\n                },\n                fetchedOrderData.variant_index ??\n                    fetchedOrderData.order.variant_index\n            );\n\n            const resp = await processEmpowerScript(\n                fetchedOrderData.id,\n                fetchedOrderData.order_status,\n                fetchedOrderData.assigned_provider,\n                empowerScriptData.script,\n                orderType,\n                fetchedOrderData.subscription_id\n                    ? fetchedOrderData.subscription_id\n                    : '',\n                fetchedOrderData,\n                fetchedOrderData.variant_index\n            );\n\n            await updateOrder(order_data.id, {\n                order_status: 'Alternative-Confirmed',\n            });\n        } catch (error: any) {\n            console.error(\n                'try-catch error within confirmAlternativeOrder for WL Capsule Script processing. Order ID - ',\n                new_order_data.id,\n                'error message ',\n                error\n            );\n        } finally {\n            return Status.Success;\n        }\n    }\n\n    return Status.Failure;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/alternatives/weight-loss/alternative-weight-loss-actions.ts",
      "bioverse-client/app/(patient-portal)/alternative/weight-loss/[orderId]/checkout/page.tsx",
      "bioverse-client/app/(patient-portal)/alternative/weight-loss/[orderId]/page.tsx",
      "bioverse-client/app/(patient-portal)/alternative/weight-loss/[orderId]/cadence/page.tsx",
      "bioverse-client/app/(patient-portal)/alternative/weight-loss/[orderId]/summary/page.tsx",
      "bioverse-client/app/components/patient-portal/alternative-selection/weight-loss/alternative-checkout/alternative-checkout.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/auth/auth-actions.ts",
    "exports": [
      {
        "name": "getUserIdFromSession",
        "kind": "function",
        "signature": "export async function getUserIdFromSession() {\n    const supabase = createSupabaseServerClient();\n\n    return (await supabase.auth.getSession()).data.session?.user.id;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/auth/auth-actions.ts",
      "bioverse-client/app/(employee)/(provider-portal)/provider/dosespot-general/page.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/auth/authorization.ts",
    "exports": [
      {
        "name": "verifyUserPermission",
        "kind": "function",
        "signature": "export async function verifyUserPermission(\n    required_role: BV_AUTH_TYPE\n): Promise<{ access_granted: boolean; role: string }> {\n    try {\n        //Get current user Id\n        const current_user_role: BV_AUTH_TYPE | null =\n            await getCurrentEmployeeRole();\n\n        if (!current_user_role) {\n            return { access_granted: false, role: '' };\n        }\n\n        const allowed = determineAccessByRoleName(\n            current_user_role,\n            required_role\n        );\n\n        if (allowed) {\n            return { access_granted: true, role: current_user_role! };\n        } else {\n            return { access_granted: false, role: current_user_role ?? '' };\n        }\n    } catch (error: any) {\n        console.error(\n            'verifyUserPermission',\n            error,\n            `required_role: ${required_role}`\n        );\n        return { access_granted: false, role: '' };\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(administration)/admin/all-orders/page.tsx",
      "bioverse-client/app/utils/actions/auth/authorization.ts",
      "bioverse-client/app/(employee)/(registered-nurse-portal)/registered-nurse/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/active-macros/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/all-patients/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/dashboard/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/active-renewal-options/page.tsx",
      "bioverse-client/app/(employee)/(coordinator-portal)/coordinator/tasks/[taskId]/page.tsx",
      "bioverse-client/app/(employee)/(coordinator-portal)/coordinator/all-orders/page.tsx",
      "bioverse-client/app/(employee)/(coordinator-portal)/coordinator/all-patients/page.tsx",
      "bioverse-client/app/(employee)/(coordinator-portal)/coordinator/all-patients/[patient_id]/page.tsx",
      "bioverse-client/app/(employee)/(coordinator-portal)/coordinator/provider-audit/page.tsx",
      "bioverse-client/app/(employee)/(coordinator-portal)/coordinator/orders/[orderId]/page.tsx",
      "bioverse-client/app/(employee)/(coordinator-portal)/coordinator/page.tsx",
      "bioverse-client/app/components/coordinator-portal/dashboard/coordinator-dashboard.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/macros/macro-view.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/macros/macros-display.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/auth/change-email.ts",
    "exports": [
      {
        "name": "changeEmail",
        "kind": "function",
        "signature": "export async function changeEmail(new_email: string, patient_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase.auth.admin.updateUserById(patient_id, {\n        email: new_email,\n    });\n    if (error) {\n        return { error: error };\n    }\n\n    return { error: error };\n}"
      },
      {
        "name": "checkIfEmailExists",
        "kind": "function",
        "signature": "export async function checkIfEmailExists(email: string) {\n    const supabase = createSupabaseServiceClient();\n    const { data, error } = await supabase\n        .from('profiles')\n        .select('id')\n        .eq('email', email);\n\n    if (error) {\n        console.error('Error checking email:', error);\n        return false;\n    }\n\n    return data && data.length > 0;\n}"
      },
      {
        "name": "changePassword",
        "kind": "function",
        "signature": "export async function changePassword(new_password: string, patient_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase.auth.admin.updateUserById(patient_id, {\n        password: new_password,\n    });\n    if (error) {\n        return { error: error };\n    }\n\n    return { error: null };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/auth/change-email.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/info/info-edit-dialog.tsx",
      "bioverse-client/app/components/patient-portal/account-information/personal-information/account-edit-drawer.tsx",
      "bioverse-client/app/utils/actions/membership/membership-portal-actions.ts",
      "bioverse-client/app/components/login/CheckEmail.tsx",
      "bioverse-client/app/components/login/ResetPassword.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/auth/oauth.ts",
    "exports": [
      {
        "name": "googleOAuthSignIn",
        "kind": "function",
        "signature": "export async function googleOAuthSignIn(\n    currentUrl: string,\n    anonId: string,\n    productHref: string,\n    ad_id: string,\n    ad_type: 'google' | 'meta' | 'none',\n    lead_event_id: string,\n) {\n    const supabase = await createSupabaseBrowserClient();\n\n    const getURL = () => {\n        let url =\n            process?.env?.NEXT_PUBLIC_SITE_URL ?? // Set this to your site URL in production env.\n            process?.env?.NEXT_PUBLIC_VERCEL_URL ?? // Automatically set by Vercel.\n            'http://localhost:3000/';\n\n        // Make sure to include https:// when not localhost.\n        url = url.includes('http') ? url : `https://${url}`;\n        // Make sure to including trailing /.\n        url = url.charAt(url.length - 1) === '/' ? url : `${url}/`;\n        return url;\n    };\n\n    let ad_string = '';\n\n    if (ad_type === 'google') {\n        ad_string = `&gclid=${ad_id}`;\n    } else if (ad_type === 'meta') {\n        ad_string = `&fbclid=${ad_id}`;\n    }\n\n    const updatedUrl = removeUrlParam(currentUrl, 'verifyEmail');\n\n    const encodedURL = encodeURIComponent(updatedUrl);\n\n    const { data, error } = await supabase.auth.signInWithOAuth({\n        provider: 'google',\n        options: {\n            //redirectTo: `https://app.gobioverse.com/api/callback?next=/${currentUrl}`,\n            redirectTo: `${getURL()}auth/callback?next=${encodedURL}&anonId=${window.rudderanalytics.getAnonymousId()}&productHref=${productHref}${ad_string}&leadEventId=${lead_event_id}`,\n            queryParams: {\n                access_type: 'offline',\n                prompt: 'consent',\n            },\n        },\n    });\n}"
      },
      {
        "name": "facebookOAuthSignIn",
        "kind": "function",
        "signature": "export async function facebookOAuthSignIn(\n    currentUrl: string,\n    anonId: string,\n    productHref: string,\n    ad_id: string,\n    ad_type: 'google' | 'meta' | 'none',\n    lead_event_id: string,\n) {\n    const supabase = await createSupabaseBrowserClient();\n\n    const getURL = () => {\n        let url =\n            process?.env?.NEXT_PUBLIC_SITE_URL ?? // Set this to your site URL in production env.\n            process?.env?.NEXT_PUBLIC_VERCEL_URL ?? // Automatically set by Vercel.\n            'http://localhost:3000/';\n\n        // Make sure to include https:// when not localhost.\n        url = url.includes('http') ? url : `https://${url}`;\n        // Make sure to including trailing /.\n        url = url.charAt(url.length - 1) === '/' ? url : `${url}/`;\n        return url;\n    };\n\n    let ad_string = '';\n\n    if (ad_type === 'google') {\n        ad_string = `&gclid=${ad_id}`;\n    } else if (ad_type === 'meta') {\n        ad_string = `&fbclid=${ad_id}`;\n    }\n\n    const updatedUrl = removeUrlParam(currentUrl, 'verifyEmail');\n\n    const encodedURL = encodeURIComponent(updatedUrl);\n\n    const { data, error } = await supabase.auth.signInWithOAuth({\n        provider: 'facebook',\n        options: {\n            //redirectTo: `https://app.gobioverse.com/api/callback?next=/${currentUrl}`,\n            redirectTo: `${getURL()}auth/callback?next=${encodedURL}&anonId=${window.rudderanalytics.getAnonymousId()}&productHref=${productHref}${ad_string}&leadEventId=${lead_event_id}`,\n        },\n    });\n}"
      },
      {
        "name": "appleOauthSignIn",
        "kind": "function",
        "signature": "export async function appleOauthSignIn(\n    currentUrl: string,\n    anonId: string,\n    productHref: string,\n    ad_id: string,\n    ad_type: 'google' | 'meta' | 'none',\n    lead_event_id: string,\n) {\n    const supabase = await createSupabaseBrowserClient();\n\n    const getURL = () => {\n        let url =\n            process?.env?.NEXT_PUBLIC_SITE_URL ?? // Set this to your site URL in production env.\n            process?.env?.NEXT_PUBLIC_VERCEL_URL ?? // Automatically set by Vercel.\n            'http://localhost:3000/';\n\n        // Make sure to include https:// when not localhost.\n        url = url.includes('http') ? url : `https://${url}`;\n        // Make sure to including trailing /.\n        url = url.charAt(url.length - 1) === '/' ? url : `${url}/`;\n        return url;\n    };\n\n    let ad_string = '';\n\n    if (ad_type === 'google') {\n        ad_string = `&gclid=${ad_id}`;\n    } else if (ad_type === 'meta') {\n        ad_string = `&fbclid=${ad_id}`;\n    }\n\n    const updatedUrl = removeUrlParam(currentUrl, 'verifyEmail');\n\n    const encodedURL = encodeURIComponent(updatedUrl);\n\n    const { data, error } = await supabase.auth.signInWithOAuth({\n        provider: 'apple',\n        options: {\n            //redirectTo: `https://app.gobioverse.com/api/callback?next=/${currentUrl}`,\n            redirectTo: `${getURL()}auth/callback?next=${encodedURL}&anonId=${window.rudderanalytics.getAnonymousId()}&productHref=${productHref}${ad_string}&leadEventId=${lead_event_id}`,\n        },\n    });\n\n    if (error) {\n        console.log('error in oauth apple: ', error);\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/auth/oauth.ts",
      "bioverse-client/app/components/intake-v3/buttons/oauth-buttons/oauth-google-v3.tsx",
      "bioverse-client/app/components/intake-v3/buttons/oauth-buttons/oauth-facebook-v3.tsx",
      "bioverse-client/app/components/login/oauth-button/v2-buttons/oauth-google-v2.tsx",
      "bioverse-client/app/components/login/oauth-button/oauth-facebook.tsx",
      "bioverse-client/app/components/login/oauth-button/oauth-google.tsx",
      "bioverse-client/app/components/login/oauth-button/v2-buttons/oauth-facebook-v2.tsx",
      "bioverse-client/app/components/intake-v3/buttons/oauth-buttons/oauth-apple-v3.tsx",
      "bioverse-client/app/components/login/oauth-button/v2-buttons/oauth-apple-v2.tsx",
      "bioverse-client/app/components/login/oauth-button/oauth-apple.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/auth/server-signIn-signOut.ts",
    "exports": [
      {
        "name": "signUpWithEmailAndPassword",
        "kind": "function",
        "signature": "export async function signUpWithEmailAndPassword(data: Data) {\n    const supabase = await createSupabaseServiceClient();\n\n    const result = await supabase.auth.signUp({\n        email: data.email,\n        password: data.password,\n    });\n\n    if (result.error) {\n        console.log('signUpWithEmailAndPassword', result.error);\n    }\n\n    return JSON.stringify(result);\n}"
      },
      {
        "name": "signInUser",
        "kind": "function",
        "signature": "export async function signInUser(data: Data) {\n    const supabase = createSupabaseServerClient();\n    // Sign in the user\n    const { data: signInData, error: signInError } =\n        await supabase.auth.signInWithPassword({\n            email: data.email,\n            password: data.password,\n        });\n\n    if (signInError) {\n        console.log('Error signing in: ', signInError.message);\n        return { success: false, error: signInError.message };\n    } else {\n        //console.log('Signed in: ', signInData);\n        return { success: true, data: signInData };\n    }\n}"
      },
      {
        "name": "signOutUser",
        "kind": "function",
        "signature": "export async function signOutUser() {\n    const supabase = await createSupabaseServerClient();\n    const { error } = await supabase.auth.signOut();\n    if (error) {\n        console.error(error);\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/auth/server-signIn-signOut.ts",
      "bioverse-client/app/components/intake-v3/registration/intake-signup-form/intake-signup-form-v3.tsx",
      "bioverse-client/app/components/intake-v3/wl-graph/wl-login-verification-screen.tsx",
      "bioverse-client/app/components/intake-v3/wl-graph/wl-registration-pre-graph-dialog.tsx",
      "bioverse-client/app/components/intake-v2/registration/intake-signup-form/intake-signup-form.tsx",
      "bioverse-client/app/components/login/forms/v2/sign-up-form-v2.tsx",
      "bioverse-client/app/components/login/forms/signUpForm.tsx",
      "bioverse-client/app/components/login/login-drawer/drawer-specific-forms/sign-up-form-drawer.tsx",
      "bioverse-client/app/components/intake-v3/registration/intake-login-form/intake-login-form-v3.tsx",
      "bioverse-client/app/components/intake-v2/registration/intake-login-form/intake-login-form.tsx",
      "bioverse-client/app/components/login/forms/loginForm.tsx",
      "bioverse-client/app/components/login/forms/v2/login-form-v2.tsx",
      "bioverse-client/app/components/login/login-drawer/drawer-specific-forms/login-form-drawer.tsx",
      "bioverse-client/app/components/login/PrivilegedLogin.tsx",
      "bioverse-client/app/utils/functions/provider-portal/time-tracker/provider-time-tracker-functions.ts",
      "bioverse-client/app/components/coordinator-portal/navbar/components/sign-out-button.tsx",
      "bioverse-client/app/components/coordinator-portal/navbar/coordinator-resources/coordinator-resources-button.tsx",
      "bioverse-client/app/components/engineer-portal/navbar/components/sign-out-button.tsx",
      "bioverse-client/app/components/navigation/components/mobile/menu-drawer/menu-drawer.tsx",
      "bioverse-client/app/components/provider-portal/nav-bar/start-session-button/start-session-button.tsx",
      "bioverse-client/app/components/provider-portal/nav-bar/provider-nav-bar-sign-out/sign-out-button.tsx",
      "bioverse-client/app/components/provider-portal/nav-bar/provider-resources/provider-resources-button.tsx",
      "bioverse-client/app/components/registered-nurse-portal/nav-bar/registered-nurse-resources/registered-nurse-resources-button.tsx",
      "bioverse-client/app/components/patient-portal/nav-bar/portal-nav-bar-buttons/patient-nav-buttons.tsx",
      "bioverse-client/app/components/patient-portal/nav-bar/mobile-nav/portal-nav-drawer.tsx",
      "bioverse-client/app/components/login/PasswordResetSuccess.tsx",
      "bioverse-client/app/components/login/mfa/mfaVerifyPageContents.tsx",
      "bioverse-client/app/components/login/mfa/mfaPageContents.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/auth/session-reader.ts",
    "exports": [
      {
        "name": "readUserSession",
        "kind": "function",
        "signature": "export async function readUserSession() {\n    const supabase = createSupabaseServerClient();\n    return await supabase.auth.getSession();\n}"
      },
      {
        "name": "readActiveUser",
        "kind": "function",
        "signature": "export async function readActiveUser() {\n    const supabase = createSupabaseServerClient();\n    return await supabase.auth.getUser();\n}"
      },
      {
        "name": "readUserSessionCheckForMFARequirement",
        "kind": "function",
        "signature": "export async function readUserSessionCheckForMFARequirement() {\n    const supabase = await createSupabaseServerClient();\n    const session = await supabase.auth.getSession();\n    const user_id = session.data.session?.user.id;\n\n    if (user_id) {\n        const assurance_level =\n            await supabase.auth.mfa.getAuthenticatorAssuranceLevel();\n\n        const employee_record = await getEmployeeRecordById(user_id);\n\n        if (employee_record) {\n            return {\n                user_id: user_id,\n                mfa_required: true,\n                assurance_level: assurance_level,\n            };\n        } else {\n            return {\n                user_id: user_id,\n                mfa_required: false,\n                assurance_level: assurance_level,\n            };\n        }\n    } else return null;\n}"
      },
      {
        "name": "getCurrentUserId",
        "kind": "function",
        "signature": "export async function getCurrentUserId() {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase.auth.getSession();\n\n    if (error) {\n        console.log('Error retrieving the user ID', error);\n        return null;\n    }\n\n    return data.session ? data.session.user.id : null;\n}"
      },
      {
        "name": "getAuthLevel",
        "kind": "function",
        "signature": "export async function getAuthLevel() {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const uid = (await supabase.auth.getSession()).data.session?.user.id;\n\n    if (uid) {\n        const { data: authTextualData, error } = await supabase\n            .from('profiles')\n            .select('authorization')\n            .eq('id', uid)\n            .single();\n\n        if (authTextualData) {\n            switch (authTextualData.authorization) {\n                case 'customer':\n                    return 0;\n                case 'coordinator':\n                    return 1;\n                case 'provider':\n                    return 2;\n                case 'developer':\n                    return 2;\n                case 'administrator':\n                    return 3;\n                case 'customer_service':\n                    return 4;\n            }\n        }\n    }\n    return 0;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(testing_and_development)/dev/mock/subscriptions/[user_id]/page.tsx",
      "bioverse-client/app/(testing_and_development)/dev/mock/order-history/[user_id]/page.tsx",
      "bioverse-client/app/auth/passwordResetSuccess/page.tsx",
      "bioverse-client/app/(login)/signup/page.tsx",
      "bioverse-client/app/(login)/login/mfa-verify/page.tsx",
      "bioverse-client/app/(login)/login/mfa-enroll/page.tsx",
      "bioverse-client/app/utils/database/controller/site-error-audit/site_error_audit.ts",
      "bioverse-client/app/utils/database/controller/tasks/task-api.ts",
      "bioverse-client/app/utils/database/controller/questionnaires/questionnaire.ts",
      "bioverse-client/app/utils/database/controller/provider_activity_audit/provider_activity_audit-api.ts",
      "bioverse-client/app/utils/database/controller/providers/providers-api.ts",
      "bioverse-client/app/utils/database/controller/clinical_notes/clinical_notes_v2.ts",
      "bioverse-client/app/utils/database/controller/clinical_notes/clinical-notes.ts",
      "bioverse-client/app/utils/database/controller/profiles/profiles.ts",
      "bioverse-client/app/utils/database/controller/patient_weight_audit/patient-weight-audit-api.ts",
      "bioverse-client/app/utils/database/controller/messaging/threads/threads.ts",
      "bioverse-client/app/utils/database/controller/messaging/thread_escalations/thread_escalations.ts",
      "bioverse-client/app/utils/database/controller/coordinator_tasks/coordinator-task-api.ts",
      "bioverse-client/app/utils/database/controller/employees/employees-api.ts",
      "bioverse-client/app/utils/actions/auth/session-reader.ts",
      "bioverse-client/app/utils/actions/alternatives/weight-loss/alternative-weight-loss-actions.ts",
      "bioverse-client/app/(employee)/(registered-nurse-portal)/registered-nurse/tasks/page.tsx",
      "bioverse-client/app/(employee)/(registered-nurse-portal)/registered-nurse/tasks/[taskId]/page.tsx",
      "bioverse-client/app/(employee)/(registered-nurse-portal)/registered-nurse/dashboard/page.tsx",
      "bioverse-client/app/(employee)/(registered-nurse-portal)/registered-nurse/track-hours/page.tsx",
      "bioverse-client/app/(employee)/(registered-nurse-portal)/registered-nurse/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/tx-patient-list/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/tasks/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/tasks/[taskId]/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/messages/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/intakes/[orderId]/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/all-patients/[patient_id]/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/dashboard/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/history/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/track-hours/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/page.tsx",
      "bioverse-client/app/(employee)/(engineer-portal)/layout.tsx",
      "bioverse-client/app/(employee)/(engineer-portal)/engineer/page.tsx",
      "bioverse-client/app/(employee)/layout.tsx",
      "bioverse-client/app/(employee)/(coordinator-portal)/coordinator/escalations/page.tsx",
      "bioverse-client/app/(employee)/(coordinator-portal)/coordinator/tasks/page.tsx",
      "bioverse-client/app/(employee)/(coordinator-portal)/coordinator/tasks/[taskId]/page.tsx",
      "bioverse-client/app/(employee)/(coordinator-portal)/coordinator/all-patients/[patient_id]/page.tsx",
      "bioverse-client/app/(employee)/(coordinator-portal)/coordinator/track-hours/page.tsx",
      "bioverse-client/app/(employee)/(coordinator-portal)/coordinator/orders/[orderId]/page.tsx",
      "bioverse-client/app/components/coordinator-portal/navbar/coordinator-portal-navbar.tsx",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/patient-information-column/clinical-note-components/note-display-v2.tsx",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/patient-information-column/clinical-notes-v2-content.tsx",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/tab-column/message/message-display.tsx",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/containers/tab-container.tsx",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/containers/components/EngineerModal.tsx",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/containers/components/ReviewModal.tsx",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/containers/coordinator-main-view-container.tsx",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/confirm-prescription-dialog.tsx",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/coordinator-manual-internal-note/coordinator-manual-internal-note.tsx",
      "bioverse-client/app/components/engineer-portal/components/dashboard/special-case-dropdown.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/order-charts/components/StatusDropdown.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/messages/components/messages-allpatients-content.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/clinical-notes/components/allergy-med-display.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/clinical-notes/components/clinical-note-tiptap.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/internal-notes/add-manual-note-dialog.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/ManualOrderCreationDialog.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/escalation/escalate-renewal-order-dialog.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/escalation/escalate-order-dialog.tsx",
      "bioverse-client/app/components/admin/all-orders/escalation/escalate-order-dialog.tsx",
      "bioverse-client/app/components/navigation/components/nav-bar.tsx",
      "bioverse-client/app/components/navigation/components/nav-bar-v3.tsx",
      "bioverse-client/app/components/provider-portal/tasks/task-action-page/utils/task-action-data-fetch.ts",
      "bioverse-client/app/components/provider-portal/tasks/task-action-page/components/intake-view-task-container.tsx",
      "bioverse-client/app/components/provider-portal/nav-bar/provider-nav-bar.tsx",
      "bioverse-client/app/components/provider-portal/order-table/utils/assigned-order-fetch-helper.ts",
      "bioverse-client/app/components/provider-portal/order-table/utils/assign-provider-helper.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-creation-menu/creation-tab-content/bmi-creation.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-creation-menu/creation-tab-content/note-creation/note-creation.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-creation-menu/creation-tab-content/template-creation.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/text-editor/clinical-note-text-editor.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-components/allergy-med-display.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-components/note-display-v2.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-components/allergy-med-accordion.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-components/note-and-template-accordion.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-components/bmi-accordion-record.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/belmar/belmar-prescribe-window.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/empower/empower-window-v2.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/hallandale/hallandale-prescribe-window.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/tmc/tmc-window.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/message/message-display.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/intake-view-main-container.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/utils/post-prescribe-macro-selector/post-prescribe-macro-selector.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approval-buttons.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/decline-dialog.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approve-script-dialog.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/provider-review-ui.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/patient-information/approval-buttons/review-approval-buttons.tsx",
      "bioverse-client/app/components/registered-nurse-portal/nav-bar/registered-nurse-nav-bar.tsx",
      "bioverse-client/app/components/patient-portal/account-information/phi-download-component.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/ChangeRefillDate/confirm/ConfirmRefillData.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-graph-presignup.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/select-wl-treatment-v3.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/wl-goal-transition-v3.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/checkbox-logic/custom-checkboxes/custom-bloodwork-upload-v3.tsx",
      "bioverse-client/app/components/intake-v2/ed/utils/ed-order-update.ts",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/wl-goal-transition.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/upload.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/select-wl-treatment.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/select-wl-treatment-ro.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/checkbox-logic/custom-checkboxes/custom-bloodwork-upload.tsx",
      "bioverse-client/app/components/login/login-drawer/login-drawer-container.tsx",
      "bioverse-client/app/components/login/loginPageContents.tsx",
      "bioverse-client/app/components/login/PrivilegedLogin.tsx",
      "bioverse-client/app/(patient-portal)/portal/message/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/account-information/document-upload/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/account-information/id-verification/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/account-information/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/refill/[subscription_id]/confirm/layout.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/refill/[subscription_id]/confirm/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/refill/[subscription_id]/feedback/[question_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/refill/[subscription_id]/layout.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/refill/[subscription_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/resume/[subscription_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/cancel-flow/[subscription_id]/cancel/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/cancel-flow/[subscription_id]/information/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/cancel-flow/[subscription_id]/confirm/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/cancel-flow/[subscription_id]/change-refill/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/cancel-flow/[subscription_id]/feedback/[question_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/manage/[subscription_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/[subscription_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/layout.tsx",
      "bioverse-client/app/(patient-portal)/portal/order-history/page.tsx",
      "bioverse-client/app/(patient-portal)/dosage-selection/[product]/confirmed/page.tsx",
      "bioverse-client/app/(patient-portal)/dosage-selection/[product]/choose-sub-plan/page.tsx",
      "bioverse-client/app/(patient-portal)/dosage-selection/[product]/choose-plan/page.tsx",
      "bioverse-client/app/(patient-portal)/dosage-selection/[product]/[variant_index]/page.tsx",
      "bioverse-client/app/(patient-portal)/dosage-selection/[product]/page.tsx",
      "bioverse-client/app/(patient-portal)/layout.tsx",
      "bioverse-client/app/(patient-portal)/dosage/first-time/confirmed/page.tsx",
      "bioverse-client/app/(patient-portal)/dosage/first-time/[order_id]/[variant_index]/page.tsx",
      "bioverse-client/app/(patient-portal)/dosage/first-time/[order_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/check-up/[product_href]/success/page.tsx",
      "bioverse-client/app/(patient-portal)/check-up/[product_href]/question/[question_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/check-up/[product_href]/page.tsx",
      "bioverse-client/app/(intake)/intake/layout.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/up-next/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-graph-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/order-summary-v3-zbp/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-specialists/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/skincare-up-next-id/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-security-disclaimer/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-inform-1-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-1/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/order-summary-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-goal-hers-transition-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/order-summary-v4/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/treatment-support/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/ed-match/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/order-summary-v3-ap/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/pre-id/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/general-order-summary/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/start-wl-journey-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-supply/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/patient-match-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/skincare-up-next-health/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-inform-3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/up-next-preview-v3-ap/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/skincare-up-next-preview/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/id-verification-v3-noskip/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-calculating-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/new-checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-stat/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/up-next-v3-wl/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-supply-v2/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/treatment-evolve/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/shipping-information-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v2/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-calculating/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-pre-demographic/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-supply-v3-no-6/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/greeting/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/start-wl-journey/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-inform-2/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/up-next-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-supply-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/improve-health-ap/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-1-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/up-next-preview/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/glutathione-advantages/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/preview-treatment/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/demographic-collection-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/id-verification-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-specialists-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-question-1-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-graph-pre-signup/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-1-new/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3-abtest/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-reviews/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-dosage/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/rtb-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/general-order-summary-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-infographic-hers-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/date-of-birth/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/up-next-3-health/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/animated-match/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-question-1/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/up-next-id-v3-ap/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/up-next-id/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/good-news-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/enhance-energy/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/shipping-information/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/up-next-v3-ap/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/good-to-go/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-question-4-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/pre-id-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/patient-match/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/select-supply-ap/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-in-good-hands/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-dosage-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/ed-pre-id/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/bmi-summary/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/state-selection/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/fatigue-stat-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/state-selection-hers/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/combined-wl-demographic/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/up-next-health/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/skincare-up-next-upload/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/on-your-way/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-options-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/skincare-pre-demographic/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-graph/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/on-your-way-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-2/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/skincare-upload/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/ed-checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checklist/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/skin-care-see-others/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-reviews-v3-zbp/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/whats-next/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/demographic-wl/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-options/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-3-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-female-safety/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/pre-id-v3-post-co/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-up-next-preview/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/glutathione-process/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/up-next-4-health/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/product-overview/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/fatigue-stat/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-question-3-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/greeting-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/pre-id-b/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-2-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/b12-reviews/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-graph-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/improve-health/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/order-summary/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/demographic-information/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/patient-match-one-moment/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-capsule-cadence-selection/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/questions-v3/[question_id]/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/questions-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/improve-function/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/nad-benefits/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-question-2-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-profile-start-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-screen/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-data-processing/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/rtb/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/select-supply/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/state-selection-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-inform-1/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/up-next-health-v3-ap/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/id-verification-v3-post-co/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/demographic-wl-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/skincare-intro/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-stat-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/id-verification/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-accomplish-goals/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3-zbp/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-up-next-profile/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-graph/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-goal-hers-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/treatment-safety/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/date-of-birth-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/nad-benefits-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-inform-3-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/select-supply-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-data-processing-2/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/skincare-results/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/pre-demographic/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/pre-treatment/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-inform-2-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/demographic-collection/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-question-2/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/skincare-frequency/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-reviews-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-bmi/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/pre-date-of-birth-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/new-checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/one-moment/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/questions/[question_id]/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-question-3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/ed-selection/[frequency]/[treatmentType]/[medication]/confirmation/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/ed-selection/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-intro-question-4/page.tsx",
      "bioverse-client/app/services/stripe/recharge.ts",
      "bioverse-client/app/services/stripe/customer.ts",
      "bioverse-client/app/services/stripe/refunds.ts",
      "bioverse-client/_deprecated/clinical_notes_v1/collapsible-note-template.tsx",
      "bioverse-client/_deprecated/clinical_notes_v1/clinical-note-template-deprecated.tsx",
      "bioverse-client/_deprecated/clinical_notes_v1/clinical-notes-v2-content.tsx",
      "bioverse-client/_deprecated/clinical-intake-flow/order-table/utils/assigned-order-fetch-helper.ts",
      "bioverse-client/_deprecated/clinical-intake-flow/order-table/utils/assign-provider-helper.ts",
      "bioverse-client/_deprecated/patient-intakes/[orderId]/page.tsx",
      "bioverse-client/_deprecated/chat_old_6.10/testing.tsx",
      "bioverse-client/_deprecated/checkout-test/page.tsx",
      "bioverse-client/_deprecated/patient-overview/clinical-notes/clinical-notes.tsx",
      "bioverse-client/app/(testing_and_development)/layout.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/auth/sign-out.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/actions/check-up/check-up-actions.ts",
    "exports": [
      {
        "name": "getNextOrderStatusQuarterly",
        "kind": "variable",
        "signature": "getNextOrderStatusQuarterly = async (\n    renewalOrder: RenewalOrder\n): Promise<RenewalOrderStatus> => {\n    const order_status = renewalOrder.order_status;\n    const user_id = renewalOrder.customer_uuid;\n\n    if (\n        INVALID_RENEWAL_ORDER_STATSUES_FOR_CHECKUP_COMPLETE.includes(\n            order_status\n        )\n    ) {\n        await auditCheckupForm(\n            user_id,\n            'Could not get next order status',\n            JSON.stringify({ order_status, user_id })\n        );\n        console.error('Could not get next order status', user_id, order_status);\n        await forwardOrderToEngineering(\n            renewalOrder.renewal_order_id,\n            renewalOrder.customer_uuid,\n            'Could not get next order status ' + order_status\n        );\n        return order_status;\n    }\n\n    const orderDetails = getOrderStatusDetails(order_status);\n    if (orderDetails.isFailedPayment) {\n        const num = order_status.split('-').at(-1);\n\n        if (isUndefined(num)) {\n            await forwardOrderToEngineering(\n                renewalOrder.renewal_order_id,\n                renewalOrder.customer_uuid,\n                'function: getNextOrderStatusQuarterly. num was undefined'\n            );\n            return order_status;\n        }\n\n        if (isNaN(num)) {\n            await forwardOrderToEngineering(\n                renewalOrder.renewal_order_id,\n                renewalOrder.customer_uuid,\n                'function: getNextOrderStatusQuarterly. num was undefined'\n            );\n            return order_status;\n        }\n\n        return `CheckupComplete-Unprescribed-Unpaid-${num}` as RenewalOrderStatus;\n    }\n\n    if (!orderDetails.isCheckupComplete) {\n        if (orderDetails.isPaid) {\n            return RenewalOrderStatus.CheckupComplete_Unprescribed_Paid;\n        }\n        return RenewalOrderStatus.CheckupComplete_Unprescribed_Unpaid;\n    }\n\n    if (orderDetails.isPaid) {\n        return RenewalOrderStatus.CheckupComplete_Unprescribed_Paid;\n    }\n    return RenewalOrderStatus.CheckupComplete_Unprescribed_Unpaid;\n}"
      },
      {
        "name": "handleCheckupCompletionV2",
        "kind": "variable",
        "signature": "handleCheckupCompletionV2 = async (\n    userId: string,\n    prodcut_href: PRODUCT_HREF,\n    subscription_id: number,\n    last_action_item: ActionItemType\n) => {\n    let renewalOrderId: string | undefined;\n\n    try {\n        const supabase = createSupabaseServiceClient();\n\n        await logPatientAction(\n            userId,\n            PatientActionTask.CHECKIN_FORM_SUBMITTED,\n            {\n                product: prodcut_href,\n                action_item_id: last_action_item.id,\n            }\n        );\n\n        // Update since_last_checkup\n        const { error: prescriptionError } = await supabase\n            .from('prescription_subscriptions')\n            .update({\n                since_last_checkup: 0,\n            })\n            .eq('id', subscription_id);\n\n        //not throwing an error after this becuase I don't actually think it's necessary to update - Nathan\n        if (prescriptionError) {\n            console.error(\n                'Error updating prescription last_checkup',\n                subscription_id,\n                prescriptionError\n            );\n        }\n\n        //get the subscription data\n        const subscriptionData: PrescriptionSubscription =\n            await getSubscriptionById(subscription_id);\n\n        //remove NCI Flag from subscription if-present.\n        await addOrRemoveStatusFlags(\n            subscription_id,\n            'remove',\n            SubscriptionStatusFlags.NO_CHECK_IN_HOLD\n        );\n\n        //if the patient was in the NCI_Charged state, then put them into the pending dosage selection state\n        if (\n            subscriptionData?.status_flags?.includes(\n                SubscriptionStatusFlags.NO_CHECK_IN_HOLD_CHARGED\n            )\n        ) {\n            const { error: prescriptionError2 } = await supabase\n                .from('prescription_subscriptions')\n                .update({\n                    status_flags: [\n                        SubscriptionStatusFlags.NO_CHECK_IN_HOLD_PENDING_DS,\n                    ], //just replace the entire array\n                })\n                .eq('id', subscription_id);\n            if (prescriptionError2) {\n                console.error(\n                    'Error updating prescription last_checkup 69420',\n                    subscription_id,\n                    prescriptionError2\n                );\n            }\n        }\n\n        //get the latest renewal order for the subscription.\n        let renewalOrderData = await getLatestRenewalOrderForSubscription(\n            subscription_id\n        );\n        renewalOrderId = renewalOrderData?.renewal_order_id;\n\n        //Extends the subscription renewal date by 5 days if necessary.\n        await handleCheckUpSubscriptionExtension(subscriptionData);\n\n        //create a renewal order if one is not present.\n        if (!renewalOrderData) {\n            renewalOrderData = await createFirstTimeRenewalOrder(\n                subscriptionData.order_id.toString(),\n                false\n            );\n            renewalOrderId = renewalOrderData?.renewal_order_id;\n        }\n\n        //if renewal order is PharmacyProcessing == prescription sent   <-- TODO - delete this as we are moving away from order status dependent renewal logic\n        //we create a new renewal order for safe-keeping\n        if (\n            renewalOrderData?.order_status ===\n            RenewalOrderStatus.PharmacyProcessing\n            // ? checking here, bc if it does not exist, the next check will throw an error\n        ) {\n            renewalOrderData = await createUpcomingRenewalOrder(\n                renewalOrderData\n            );\n            renewalOrderId = renewalOrderData?.renewal_order_id;\n        }\n\n        if (!renewalOrderData) {\n            throw new Error(\n                'Check up Error: Could not create upcoming renewal order',\n                {\n                    cause: {\n                        subscription_id,\n                        userId,\n                    },\n                }\n            );\n        }\n\n        //add check in completion record to renewal order.\n        await addCheckInCompletionToRenewalOrder(\n            last_action_item.id,\n            new Date().toISOString(),\n            renewalOrderData.renewal_order_id\n        );\n\n        //mark the action item as completed\n        await updateActionItem(last_action_item.id, {\n            active: false,\n            last_updated_at: new Date(),\n            submission_time: new Date().toISOString(),\n        });\n\n        const nextOrderStatus =\n            renewalOrderData.subscription_type === SubscriptionCadency.Monthly\n                ? await getNextOrderStatusMonthly(\n                      renewalOrderData,\n                      renewalOrderData.customer_uuid,\n                      renewalOrderData.order_status\n                  )\n                : await getNextOrderStatusQuarterly(renewalOrderData);\n\n        const { statusTag: nextStatusTag, statusTagNotes } =\n            await getNextStatusTag(renewalOrderData);\n\n        //update the renewal order status\n        await supabase\n            .from('renewal_orders')\n            .update({\n                order_status: nextOrderStatus,\n                assigned_provider: null,\n                assigned_provider_timestamp: null,\n            })\n            .eq('renewal_order_id', renewalOrderData.renewal_order_id);\n\n        //create the status tag - TODO - make sure the status tag is Urgent IF the renewal date gets pushed because of the 48 hour checkin window\n        await createUserStatusTagWAction(\n            nextStatusTag,\n            renewalOrderData.renewal_order_id,\n            StatusTagAction.INSERT,\n            userId,\n            statusTagNotes,\n            'ffabc905-5508-4d54-98fb-1e2ef2b9e99a',\n            [nextStatusTag]\n        );\n\n        //fire the correct customer io event\n        const event = isGLP1Product(renewalOrderData.product_href)\n            ? WL_CHECKIN_COMPLETE\n            : NON_WL_CHECKIN_COMPLETE;\n        await triggerEvent(userId, event, {\n            exitJourney: false,\n        });\n\n        /**\n         * This code below triggers an event to customer io to exit the pt out of the first time dosage selection campaign.\n         * This is here because we had patients going through check ups when they were subscribed because the com's never removed them.\n         */\n        await triggerEvent(userId, FIRST_TIME_DOSAGE_SELECTION_COMPLETE, {});\n\n        /**\n         * @Nathan_note - I am confused as to why we are triggering a message_replied. If you understand why later, please populate this comment and remove note.\n         * Triggering an event here to notify the customer that their check-in has been completed.\n         */\n        await triggerEvent(userId, MESSAGE_REPLIED, {});\n\n        return Status.Success;\n    } catch (error: any) {\n        console.error('Error completing checkup', error);\n\n        auditCheckupForm(\n            userId,\n            'Error completing checkup',\n            JSON.stringify(error),\n            undefined,\n            {\n                renewalOrderId,\n                userId,\n                subscriptionId: subscription_id,\n                productHref: prodcut_href,\n                lastActionItemId: last_action_item.id,\n            }\n        );\n\n        //cannot send to eng queue without a renewal order Id, but it will audit failure otherwise.\n        if (renewalOrderId) {\n            await forwardOrderToEngineering(\n                renewalOrderId,\n                userId,\n                'Error completing checkup: ' + error.message\n            );\n        }\n\n        return Status.Error;\n    }\n}"
      },
      {
        "name": "isWithinLastThreeMonths",
        "kind": "function",
        "signature": "export async function isWithinLastThreeMonths(timestamp: string) {\n    // Parse the timestamp string into a Date object\n    const date = new Date(timestamp);\n\n    // Get the current date\n    const now = new Date();\n\n    // Calculate the date three months ago\n    const threeMonthsAgo = new Date();\n    threeMonthsAgo.setMonth(now.getMonth() - 3);\n\n    // Check if the date is within the last three months\n    return date >= threeMonthsAgo && date <= now;\n}"
      },
      {
        "name": "getLastCheckInFormSubmission",
        "kind": "function",
        "signature": "export async function getLastCheckInFormSubmission(\n    user_id: string,\n    product_href: PRODUCT_HREF\n): Promise<ActionItemType | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('action_items')\n        .select('*')\n        .eq('product_href', product_href)\n        .eq('patient_id', user_id)\n        .eq('action_type', 'check_up')\n        .not('submission_time', 'is', null)\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            'Error getting last check in form',\n            user_id,\n            product_href\n        );\n        return null;\n    }\n\n    return data;\n}"
      },
      {
        "name": "auditCheckupForm",
        "kind": "function",
        "signature": "export default async function auditCheckupForm(\n    patient_id: string,\n    error_message?: string,\n    error_json?: any,\n    form_type?: string,\n    metadata?: any\n) {\n    const supabase = createSupabaseServiceClient();\n\n    await supabase\n        .from('audit_checkup')\n        .insert({ patient_id, error_message, error_json, form_type, metadata });\n}"
      },
      {
        "name": "getNextStatusTag",
        "kind": "function",
        "signature": "export async function getNextStatusTag(\n    renewalOrder: RenewalOrder\n): Promise<{ statusTag: StatusTag; statusTagNotes: StatusTagNotes }> {\n    const final_review_started = renewalOrder.final_review_starts\n        ? new Date() >= new Date(renewalOrder.final_review_starts)\n        : false;\n    const subscription_cadency = renewalOrder.subscription_type;\n\n    if (subscription_cadency === SubscriptionCadency.Monthly) {\n        if (isGLP1Product(renewalOrder.product_href)) {\n            return {\n                statusTag: StatusTag.FinalReview,\n                statusTagNotes: StatusTagNotes.FinalReview,\n            };\n        }\n        return {\n            statusTag: StatusTag.Review,\n            statusTagNotes: StatusTagNotes.RenewalReview,\n        };\n    }\n\n    if (subscription_cadency === SubscriptionCadency.Quarterly) {\n        if (isGLP1Product(renewalOrder.product_href)) {\n            if (final_review_started) {\n                return {\n                    statusTag: StatusTag.FinalReview,\n                    statusTagNotes: StatusTagNotes.FinalReview,\n                };\n            }\n            return {\n                statusTag: StatusTag.ReviewNoPrescribe,\n                statusTagNotes: StatusTagNotes.ReviewNoPrescribe,\n            };\n        } else {\n            return {\n                statusTag: StatusTag.Review,\n                statusTagNotes: StatusTagNotes.RenewalReview,\n            };\n        }\n    } else if (subscription_cadency === SubscriptionCadency.Biannually) {\n        if (isGLP1Product(renewalOrder.product_href)) {\n            const month = await getMonthsIntoRenewalOrderSubscription(\n                renewalOrder.renewal_order_id\n            );\n\n            if (month === 6) {\n                return {\n                    statusTag: StatusTag.FinalReview,\n                    statusTagNotes: StatusTagNotes.FinalReview,\n                };\n            } else {\n                return {\n                    statusTag: StatusTag.ReviewNoPrescribe,\n                    statusTagNotes: StatusTagNotes.ReviewNoPrescribe,\n                };\n            }\n        } else {\n            return {\n                statusTag: StatusTag.Review,\n                statusTagNotes: StatusTagNotes.RenewalReview,\n            };\n        }\n    } else if (subscription_cadency === SubscriptionCadency.Annually) {\n        if (isGLP1Product(renewalOrder.product_href)) {\n            const month = await getMonthsIntoRenewalOrderSubscription(\n                renewalOrder.renewal_order_id\n            );\n\n            if (month === 12) {\n                return {\n                    statusTag: StatusTag.FinalReview,\n                    statusTagNotes: StatusTagNotes.FinalReview,\n                };\n            } else {\n                return {\n                    statusTag: StatusTag.ReviewNoPrescribe,\n                    statusTagNotes: StatusTagNotes.ReviewNoPrescribe,\n                };\n            }\n        } else {\n            return {\n                statusTag: StatusTag.Review,\n                statusTagNotes: StatusTagNotes.RenewalReview,\n            };\n        }\n    }\n\n    console.error(\n        'Edge case not expected for getting next status tag',\n        renewalOrder\n    );\n    await triggerEvent(renewalOrder.customer_uuid, NEW_BUG, {\n        order_id: renewalOrder.renewal_order_id,\n    });\n    return { statusTag: StatusTag.None, statusTagNotes: StatusTagNotes.None };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/check-up/check-up-actions.ts",
      "bioverse-client/app/components/patient-portal/check-up/question/CheckupQuestion.tsx",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/StripeInvoicePaidJobHandler.ts",
      "bioverse-client/app/api/stripe/webhook/invoice-paid/route.ts",
      "bioverse-client/app/components/patient-portal/check-up-requested/refill-preference/refill-preference-screen-v2.tsx",
      "bioverse-client/app/components/patient-portal/check-up-requested/refill-preference/refill-preference-screen-single-dosage.tsx",
      "bioverse-client/app/components/patient-portal/check-up-requested/refill-preference/refill-preference-screen.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/check-up/check-up-constants.ts",
    "exports": [
      {
        "name": "INVALID_RENEWAL_ORDER_STATSUES_FOR_CHECKUP_COMPLETE",
        "kind": "variable",
        "signature": "INVALID_RENEWAL_ORDER_STATSUES_FOR_CHECKUP_COMPLETE = [\n    RenewalOrderStatus.Administrative_Canceled,\n    RenewalOrderStatus.Canceled,\n    RenewalOrderStatus.Denied_Paid,\n    RenewalOrderStatus.Denied_Unpaid,\n    RenewalOrderStatus.Scheduled_Admin_Cancel,\n    RenewalOrderStatus.Scheduled_Cancel,\n    RenewalOrderStatus.PharmacyProcessing,\n    RenewalOrderStatus.Unknown,\n]"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/check-up/check-up-actions.ts",
      "bioverse-client/app/utils/actions/check-up/check-up-constants.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/coordinator/dashboard-scripts.ts",
    "exports": [
      {
        "name": "CoordinatorDashboardFetch",
        "kind": "function",
        "signature": "export async function CoordinatorDashboardFetch() {\n    const { data: completeOrderData, error: orderError } =\n        await getAllOrdersForCoordinatorOrderTable();\n\n    const renewalOrderData =\n        await getAllRenewalOrdersForCoordinatorOrderTable();\n\n    if (!completeOrderData && orderError) {\n        console.error(\n            'Order Fetching for general orders failed. error message: ',\n            orderError.message\n        );\n    }\n\n    const generalOrders = prescriptionRequestToCoordinatorDashboardv2(\n        completeOrderData ?? []\n    );\n    const renewalOrders = renewalOrderToCoordinatorDashboard(renewalOrderData);\n    const mergedOrders = concat(renewalOrders, generalOrders);\n\n    // console.log('merged orders: ', mergedOrders.length);\n\n    return mergedOrders;\n}"
      },
      {
        "name": "LeadCoordinatorDashboardFetch",
        "kind": "function",
        "signature": "export async function LeadCoordinatorDashboardFetch() {\n    const data = await getAllLeadCoordinatorOrders();\n\n    console.log(data);\n\n    const lead_orders = prescriptionRequestToCoordinatorDashboardv2(data ?? []);\n\n    return lead_orders;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/coordinator/dashboard-scripts.ts",
      "bioverse-client/app/components/coordinator-portal/dashboard/coordinator-dashboard.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/coordinator/parsers.ts",
    "exports": [
      {
        "name": "prescriptionRequestToCoordinatorDashboard",
        "kind": "variable",
        "signature": "prescriptionRequestToCoordinatorDashboard = (\n    res: any[]\n): PatientOrderProviderDetails[] =>\n    res.map((orderItem) => ({\n        id: orderItem.id,\n        patientId: orderItem.customer_uid,\n        patientName: `${orderItem.first_name} ${orderItem.last_name}`,\n        requestSubmissionTime: orderItem.created_at,\n        deliveryState: orderItem.state,\n        prescription: orderItem.name + ', ' + orderItem.variant_text,\n        approvalStatus: orderItem.order_status,\n        licensePhotoUrl: orderItem.license_photo_url ?? '',\n        selfiePhotoUrl: orderItem.selfie_photo_url ?? '',\n        statusTag: orderItem.statusTag,\n        vial_dosages: orderItem.vial_dosages,\n        productName: orderItem.name,\n        variant: orderItem.variant,\n        subscriptionType: orderItem.subscription_type,\n        status_tag_id: orderItem.status_tag_id,\n    }))"
      },
      {
        "name": "prescriptionRequestToCoordinatorDashboardv2",
        "kind": "variable",
        "signature": "prescriptionRequestToCoordinatorDashboardv2 = (\n    res: any[]\n): PatientOrderCoordinatorDetails[] =>\n    res.map((orderItem) => ({\n        id: orderItem.id ?? orderItem.order_id,\n        patientId: orderItem.customer_uid,\n        patientName: `${orderItem.first_name} ${orderItem.last_name}`,\n        requestSubmissionTime: orderItem.created_at,\n        deliveryState: orderItem.state,\n        prescription: orderItem.name + ', ' + (orderItem.variant_text ?? ''),\n        approvalStatus: orderItem.order_status,\n        licensePhotoUrl: orderItem.license_photo_url ?? '',\n        selfiePhotoUrl: orderItem.selfie_photo_url ?? '',\n        statusTag: orderItem.status_tag,\n        statusTags: orderItem.status_tags,\n        vial_dosages: orderItem.vial_dosages,\n        productName: orderItem.name,\n        variant: orderItem.variant,\n        subscriptionType: orderItem.subscription_type,\n    }))"
      },
      {
        "name": "renewalOrderToCoordinatorDashboard",
        "kind": "variable",
        "signature": "renewalOrderToCoordinatorDashboard = (\n    renewalOrders: RenewalOrderCoordinatorOverview[]\n): PatientOrderCoordinatorDetails[] => {\n    return renewalOrders.map(\n        (renewalOrder: RenewalOrderCoordinatorOverview) => {\n            return {\n                id: renewalOrder.renewal_order_id,\n                patientId: renewalOrder.id,\n                patientName: `${renewalOrder.first_name} ${renewalOrder.last_name}`,\n                requestSubmissionTime: renewalOrder.submission_time,\n                deliveryState: renewalOrder.state,\n                prescription: `${renewalOrder.name}, ${renewalOrder.variant_text}`,\n                approvalStatus: renewalOrder.order_status,\n                licensePhotoUrl: renewalOrder.license_photo_url,\n                selfiePhotoUrl: renewalOrder.selfie_photo_url,\n                statusTag: renewalOrder.status_tag,\n                statusTags: renewalOrder.status_tags,\n                productName: renewalOrder.name,\n            };\n        }\n    );\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/coordinator/dashboard-scripts.ts",
      "bioverse-client/app/utils/actions/coordinator/parsers.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/engineer/dashboard-scripts.ts",
    "exports": [
      {
        "name": "EngineerDashboardFetch",
        "kind": "function",
        "signature": "export async function EngineerDashboardFetch() {\n    const { data: completeOrderData, error: orderError } =\n        await getEngineerStatusTagOrders();\n\n    return completeOrderData;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/engineer/dashboard-scripts.ts",
      "bioverse-client/app/components/engineer-portal/engineer-dashboard.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/intake/hhq-questionnaire.ts",
    "exports": [
      {
        "name": "getHHQQuestionsForProduct",
        "kind": "function",
        "signature": "export async function getHHQQuestionsForProduct(product_href: string) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_hhq_questions_for_product',\n        {\n            name: product_href,\n        }\n    );\n\n    if (error) {\n        console.error(error, error.message);\n        return null;\n    }\n\n    return data;\n}"
      },
      {
        "name": "getHHQAnswersForProduct",
        "kind": "function",
        "signature": "export async function getHHQAnswersForProduct(\n    user_id: string,\n    product_href: string\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase.rpc('get_hhq_answers', {\n        name: product_href,\n        user_id_: user_id,\n    });\n\n    if (error) {\n        console.error(error, error.message);\n        return null;\n    }\n\n    return data;\n}"
      },
      {
        "name": "writeHHQAnswer",
        "kind": "function",
        "signature": "export async function writeHHQAnswer(\n    user_id: string,\n    question_id: number,\n    answer: any\n) {\n    const supabase = await createSupabaseServerComponentClient();\n    const { data, error } = await supabase.from('hhq_answers').upsert(\n        {\n            user_id,\n            question_id,\n            answer,\n        },\n        { onConflict: 'user_id, question_id' }\n    );\n\n    if (error) {\n        console.error(error, error.message);\n        return null;\n    }\n\n    return data;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/intake/hhq-questionnaire.ts",
      "bioverse-client/_deprecated/patient-intakes/[orderId]/page.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/intake/hooks/useLocalStorage.ts",
    "exports": [
      {
        "name": "useLocalStorage",
        "kind": "function",
        "signature": "export function useLocalStorage<T>(key: string, fallbackValue: T) {\n    const [value, setValue] = useState<T>(() => {\n        // Initialize state with local storage value or fallback\n        if (typeof window !== 'undefined') {\n            const stored = localStorage.getItem(key);\n            return stored ? JSON.parse(stored) : fallbackValue;\n        }\n        return fallbackValue;\n    });\n\n    useEffect(() => {\n        // Update local storage when value changes\n        if (typeof window !== 'undefined') {\n            localStorage.setItem(key, JSON.stringify(value));\n        }\n    }, [key, value]);\n\n    return [value, setValue] as const;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/intake/hooks/useLocalStorage.ts",
      "bioverse-client/app/components/intake-v3/registration/intake-signup-form/intake-signup-form-v3.tsx",
      "bioverse-client/app/components/intake-v3/buttons/oauth-buttons/oauth-google-v3.tsx",
      "bioverse-client/app/components/intake-v3/buttons/oauth-buttons/oauth-apple-v3.tsx",
      "bioverse-client/app/components/intake-v3/buttons/oauth-buttons/oauth-facebook-v3.tsx",
      "bioverse-client/app/components/intake-v3/data-collection/data-collection-wl-input-v4.tsx",
      "bioverse-client/app/components/intake-v3/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component-ab.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v3/wl-graph/wl-login-verification-screen.tsx",
      "bioverse-client/app/components/intake-v3/account/data-collection/data-collection-new.tsx",
      "bioverse-client/app/components/intake-v3/pages/question-id-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/demographic-wl-v3.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/what-is-your-sex-v3.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/identify-sex-v3.tsx",
      "bioverse-client/app/components/intake-v2/registration/intake-signup-form/intake-signup-form.tsx",
      "bioverse-client/app/components/intake-v2/ed/ed-checkout/ed-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/components/wl-checkout-component-fulltest.tsx",
      "bioverse-client/app/components/intake-v2/checkout/checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/account/data-collection/data-collection-wl.tsx",
      "bioverse-client/app/components/intake-v2/account/data-collection/data-collection.tsx",
      "bioverse-client/app/components/intake-v2/account/data-collection/data-collection-new.tsx",
      "bioverse-client/app/components/intake-v2/account/data-collection/wl-data-collection.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/what-is-your-sex.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/identify-sex.tsx",
      "bioverse-client/app/components/login/forms/v2/sign-up-form-v2.tsx",
      "bioverse-client/app/components/login/forms/signUpForm.tsx",
      "bioverse-client/app/components/login/login-drawer/drawer-specific-forms/sign-up-form-drawer.tsx",
      "bioverse-client/app/components/login/oauth-button/v2-buttons/oauth-google-v2.tsx",
      "bioverse-client/app/components/login/oauth-button/v2-buttons/oauth-apple-v2.tsx",
      "bioverse-client/app/components/login/oauth-button/v2-buttons/oauth-facebook-v2.tsx",
      "bioverse-client/app/components/login/oauth-button/oauth-facebook.tsx",
      "bioverse-client/app/components/login/oauth-button/oauth-google.tsx",
      "bioverse-client/app/components/login/oauth-button/oauth-apple.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/intake/order-control.ts",
    "exports": [
      {
        "name": "createNewOrder",
        "kind": "function",
        "signature": "export async function createNewOrder(\n    sessionData: any,\n    productData: any,\n    priceData: any\n) {\n    const setupIntent = JSON.parse(await createSetupIntentServer());\n\n    if (!setupIntent) {\n        console.log('error in creating setup intent');\n        return { order: null, error: 'error in creating setup intent.' };\n    }\n\n    const order: Order = {\n        customer_uid: sessionData?.user.id,\n        product_href: productData.productName,\n        variant_index: productData.variant,\n        variant_text: productData.variantText,\n        subscription_type: productData.subscriptionType,\n        price: priceData[productData.variant][productData.subscriptionType]\n            .product_price,\n        price_id:\n            priceData[productData.variant][productData.subscriptionType]\n                .stripe_price_id,\n        order_status: 'Incomplete',\n        stripe_metadata: {\n            setupIntentId: setupIntent.id,\n            clientSecret: setupIntent.client_secret!,\n            paymentMethodId: '',\n        },\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT ?? 'dev',\n    };\n\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { data: newlyCreatedOrder, error } = await supabase\n        .from('orders')\n        .insert([\n            {\n                customer_uid: order.customer_uid,\n                product_href: order.product_href,\n                variant_index: order.variant_index,\n                variant_text: order.variant_text,\n                subscription_type: order.subscription_type,\n                price: order.price,\n                order_status: order.order_status,\n                rx_questionnaire_answers: order.rxQuestionnaireAnswers,\n                stripe_metadata: order.stripe_metadata,\n                price_id: order.price_id,\n                environment: order.environment,\n            },\n        ])\n        .select('id');\n\n    if (error) return { order: null, error: error };\n\n    const updatedOrder = {\n        ...order,\n        orderId: newlyCreatedOrder[0].id,\n    };\n\n    return { order: updatedOrder, error: null };\n}"
      },
      {
        "name": "getUserIDForOrder",
        "kind": "function",
        "signature": "export async function getUserIDForOrder(orderID: number) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select('customer_uid')\n        .eq('id', orderID)\n        .maybeSingle();\n    if (error) {\n        console.error(\n            'Error fetching product from orders with order id',\n            error,\n            orderID\n        );\n    }\n\n    if (!isEmpty(data)) {\n        // Order is valid\n        return data.customer_uid;\n    }\n\n    const { data: renewalOrders, error: renewalOrdersError } = await supabase\n        .from('renewal_orders')\n        .select('customer_uuid')\n        .eq('renewal_order_id', orderID)\n        .maybeSingle();\n\n    if (renewalOrdersError) {\n        console.error(\n            'Error fetching customer_id from renewal_orders with order id',\n            error,\n            orderID\n        );\n    }\n    if (!isEmpty(renewalOrders)) {\n        return renewalOrders.customer_uuid;\n    }\n    console.error('Unknown customer_id for order_id', orderID);\n    return null;\n}"
      },
      {
        "name": "updateExistingOrderStatus",
        "kind": "function",
        "signature": "export async function updateExistingOrderStatus(\n    orderId: string | number,\n    updateStatus: string\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { data: fetchedData, error } = await supabase\n        .from('orders')\n        .update({\n            order_status: updateStatus,\n        })\n        .eq('id', orderId)\n        .select();\n\n    if (error) {\n        console.log(\n            'order-control.ts | updateExistingOrderStatus: There was an error in fetching data from the server' +\n                error.message\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: fetchedData, error: null };\n}"
      },
      {
        "name": "setOrderProvider",
        "kind": "function",
        "signature": "export async function setOrderProvider(orderId: number, providerId: string) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { data: fetchedData, error } = await supabase\n        .from('orders')\n        .update({\n            assigned_provider: providerId,\n        })\n        .eq('id', Number(orderId));\n\n    if (error) {\n        console.log(\n            'order-control.ts | updateExistingOrderStatus: There was an error in fetching data from the server' +\n                error.message\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: fetchedData, error: null };\n}"
      },
      {
        "name": "checkForExistingOrder",
        "kind": "function",
        "signature": "export async function checkForExistingOrder(\n    userUid: string,\n    productHref: string\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { data: fetchedData, error } = await supabase\n        .from('orders')\n        .select(\n            'id, stripe_metadata, order_status, variant_index, subscription_type'\n        )\n        .eq('customer_uid', userUid)\n        .eq('product_href', productHref)\n        .maybeSingle();\n\n    if (error) {\n        console.log(\n            'order-control.ts | checkForExistingOrder: There was an error in fetching data from the server',\n            error.message\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: fetchedData ?? null, error: null };\n}"
      },
      {
        "name": "getAllOrderDataById",
        "kind": "function",
        "signature": "export async function getAllOrderDataById(orderId: string | number) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select(\n            `*,\n        product:products!product_href(\n            name\n        ), \n        customer:profiles!customer_uid (\n            first_name,\n            last_name,\n            stripe_customer_id,\n            address_line1,\n            address_line2,\n            city,\n            state,\n            zip,\n            phone_number\n        )\n      `\n        )\n        .eq('id', orderId as string)\n        .single();\n\n    if (error) return { data: null, error: error };\n\n    return { data: data, error: null };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/orders/orders-api.ts",
      "bioverse-client/app/utils/actions/intake/order-control.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/order-content.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/SubscriptionList/utils/SubscriptionItem-functions.ts",
      "bioverse-client/app/(administration)/admin/order-administration/_components/administrator-order-table.tsx",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/intake-response-column/approval-buttons.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/order-tab-row.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approval-buttons.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/decline-dialog.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/patient-information/approval-buttons/review-approval-buttons.tsx",
      "bioverse-client/app/api/revive/send-script/route.ts",
      "bioverse-client/app/api/empower/send-script/route.ts",
      "bioverse-client/app/api/hallandale/send-script/route.ts",
      "bioverse-client/app/api/supabase/payment-failure/route.ts",
      "bioverse-client/app/api/boothwyn/send-script/route.ts",
      "bioverse-client/app/api/dosespot/_event-type-cases/handlePrescriptionResult.ts",
      "bioverse-client/app/api/tmc/send-script/route.ts",
      "bioverse-client/app/api/stripe/subscription/create/route.ts",
      "bioverse-client/app/api/stripe/payment-intent/create/route.ts",
      "bioverse-client/app/services/pharmacy-integration/empower/provider-script-feedback.ts",
      "bioverse-client/app/services/pharmacy-integration/tmc/tmc-actions.ts",
      "bioverse-client/app/services/pharmacy-integration/tmc/provider-script-feedback.ts",
      "bioverse-client/app/services/stripe/subscriptions.ts",
      "bioverse-client/app/services/stripe/paymentIntent.ts",
      "bioverse-client/_deprecated/clinical-intake-flow/approval-buttons/provider-approval-buttons.tsx",
      "bioverse-client/_deprecated/clinical-intake-flow/approval-buttons/finalize-order-button.tsx",
      "bioverse-client/app/utils/database/controller/profiles/profiles.ts",
      "bioverse-client/app/components/intake-v3/pages/id-verification-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/id-verification-noskip-v3.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/new-checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v2/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3-abtest/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/ed-checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/product-overview/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3-zbp/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/new-checkout/page.tsx",
      "bioverse-client/_deprecated/checkout-test/page.tsx",
      "bioverse-client/app/api/stripe/webhook/invoice-paid-dev/route.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/intake/order-util.ts",
    "exports": [
      {
        "name": "parseStateToNumeric",
        "kind": "function",
        "signature": "export async function parseStateToNumeric(order_state: string) {\n    switch (order_state) {\n        case 'Incomplete':\n            return 0;\n        case 'Unapproved-NoCard':\n            return 1;\n        case 'Unapproved-CardDown':\n            return 5;\n        case 'Approved-NoCard':\n            return 2;\n        case 'Approved-CardDown':\n            return 5;\n        case 'Approved-CardDown':\n            return 5;\n        case 'Canceled':\n            return 5;\n        default:\n            return 5;\n    }\n}"
      },
      {
        "name": "getOrderType",
        "kind": "function",
        "signature": "export async function getOrderType(order_id: string | number) {\n    if (typeof order_id === 'number') {\n        return OrderType.Order;\n    } else if (typeof order_id === 'string') {\n        if (order_id.includes('-')) {\n            return OrderType.RenewalOrder;\n        } else {\n            return OrderType.Order;\n        }\n    } else {\n        throw new Error(\n            'Invalid input type. Please provide a string or a number.'\n        );\n    }\n}"
      },
      {
        "name": "getOrderPillStatus",
        "kind": "function",
        "signature": "export async function getOrderPillStatus(\n    order_id: string,\n    orderStatus: string,\n    product_href: string\n) {\n    var res = [];\n\n    const subscriptionStatus = await isActiveSubscription(order_id);\n\n    if (\n        subscriptionStatus === 'active' &&\n        !WEIGHT_LOSS_PRODUCT_HREF.includes(product_href)\n    ) {\n        res.push(PillStatus.ActiveSubscription);\n    } else if (subscriptionStatus === 'canceled') {\n        res.push(PillStatus.Canceled);\n    }\n\n    const isIncomplete = await isOrderIncomplete(orderStatus);\n\n    if (isIncomplete) {\n        res.push(PillStatus.Incomplete);\n    }\n\n    const orderNeedsReview = await shouldOrderNeedReview(orderStatus);\n\n    if (orderNeedsReview) {\n        res.push(PillStatus.NeedsReview);\n    }\n\n    const subscriptionStatusFlags =\n        await getSubscriptionStatusFlagsFromOriginalOrderId(order_id);\n\n    if (\n        subscriptionStatusFlags &&\n        subscriptionStatusFlags.includes(PillStatus.NoCheckInHold)\n    ) {\n        res.push(PillStatus.NoCheckInHold);\n    }\n\n    // TODO: Scheduled Cancelations\n    return res;\n}"
      },
      {
        "name": "isOrderIncomplete",
        "kind": "function",
        "signature": "export async function isOrderIncomplete(orderStatus: string) {\n    switch (orderStatus) {\n        case OrderStatus.Incomplete:\n        case RenewalOrderStatus.Incomplete:\n            return true;\n        default:\n            return false;\n    }\n}"
      },
      {
        "name": "shouldOrderNeedReview",
        "kind": "function",
        "signature": "export async function shouldOrderNeedReview(orderStatus: string) {\n    switch (orderStatus) {\n        case OrderStatus.UnapprovedCardDown:\n        case OrderStatus.PaymentCompleted:\n        case OrderStatus.ApprovedCardDown:\n        case RenewalOrderStatus.CheckupComplete_Unprescribed_Paid:\n        case RenewalOrderStatus.CheckupComplete_Unprescribed_Unpaid:\n            return true;\n        default:\n            return false;\n    }\n}"
      },
      {
        "name": "processDosageSelectionFirstTimeRequest",
        "kind": "function",
        "signature": "export async function processDosageSelectionFirstTimeRequest(\n    order: BaseOrderInterface,\n    priceData: Partial<ProductVariantRecord>\n) {\n    const pharmacy = priceData.pharmacy;\n\n    await updateOrder(order.id, {\n        variant_index: priceData?.variant_index,\n        assigned_pharmacy: pharmacy,\n        subscription_type: priceData?.cadence,\n    });\n\n    await logPatientAction(\n        order.customer_uid,\n        PatientActionTask.FIRST_TIME_DOSAGE_SELECTION_REQUESTED,\n        {\n            order_id: order.id,\n            variant_index: priceData.variant_index,\n        }\n    );\n\n    await triggerEvent(\n        order.customer_uid,\n        RudderstackEvent.PRESCRIPTION_APPROVED,\n        {\n            order_id: order.id,\n            product_name: order.product_href,\n        }\n    );\n\n    await triggerEvent(\n        order.customer_uid,\n        RudderstackEvent.FIRST_TIME_DOSAGE_SELECTION_COMPLETE\n    );\n\n    const { data: patientData } = await getPatientInformationById(\n        order.customer_uid\n    );\n\n    await sendAutoMacro(order, priceData, patientData as DBPatientData);\n\n    try {\n        let result;\n\n        switch (pharmacy) {\n            case PHARMACY.EMPOWER:\n                result = await processEmpowerOrder(\n                    order,\n                    priceData,\n                    patientData as DBPatientData\n                );\n                break;\n            case PHARMACY.HALLANDALE:\n                result = await processHallandaleOrder(\n                    order,\n                    priceData,\n                    patientData as DBPatientData\n                );\n                break;\n            case PHARMACY.BOOTHWYN:\n                result = await processBoothwynOrder(\n                    order,\n                    priceData,\n                    patientData as DBPatientData\n                );\n                break;\n            case PHARMACY.REVIVE:\n                result = await processReviveOrder(\n                    order,\n                    priceData,\n                    patientData as DBPatientData\n                );\n                break;\n            default:\n                throw new Error('Unknown pharmacy');\n        }\n    } catch (error: any) {\n        await forwardOrderToEngineering(\n            String(order.id),\n            order.customer_uid,\n            error.message\n        );\n    }\n}"
      },
      {
        "name": "processEmpowerOrder",
        "kind": "function",
        "signature": "export async function processEmpowerOrder(\n    order: BaseOrderInterface,\n    priceData: Partial<ProductVariantRecord>,\n    patientData: DBPatientData\n) {\n    const bmiData = await getQuestionAnswersForBMI(order.customer_uid);\n\n    const empowerScript = generateEmpowerScript(\n        patientData as DBPatientData,\n        order as unknown as DBOrderData,\n        OrderType.Order,\n        bmiData,\n        priceData.variant_index\n    );\n\n    const resp = await processEmpowerScript(\n        String(order.id),\n        order.order_status,\n        order.assigned_provider,\n        empowerScript.script,\n        OrderType.Order,\n        String(order.subscription_id) ?? '',\n        order,\n        priceData.variant_index!\n    );\n\n    if (resp.result === Status.Success) {\n        return Status.Success;\n    }\n\n    throw new Error(\n        'Could not send empower script - first time dosage selection'\n    );\n}"
      },
      {
        "name": "processHallandaleOrder",
        "kind": "function",
        "signature": "export async function processHallandaleOrder(\n    order: BaseOrderInterface,\n    priceData: Partial<ProductVariantRecord>,\n    patientData: DBPatientData\n) {\n    const addressData: AddressInterface = {\n        address_line1: order.address_line1,\n        address_line2: order.address_line2,\n        city: order.city,\n        state: order.state,\n        zip: order.zip,\n    };\n\n    const hallandaleScript = generateHallandaleScript(\n        patientData as DBPatientData,\n        order as unknown as DBOrderData,\n        addressData,\n        OrderType.Order,\n        priceData.variant_index!\n    );\n\n    if (!hallandaleScript) {\n        throw new Error(\n            'Could not generate hallandale script - first time dosage selection'\n        );\n    }\n\n    const orderWithPdf: HallandaleOrderObject = {\n        ...hallandaleScript.script,\n        document: { pdfBase64: '' },\n    };\n\n    const body_json: HallandaleScriptJSON = {\n        message: { id: order.id, sentTime: new Date().toISOString() },\n        order: orderWithPdf,\n    };\n\n    const result = await sendHallendaleScript(\n        body_json,\n        String(order.id),\n        order.assigned_provider,\n        order.order_status,\n        OrderType.Order,\n        '',\n        '',\n        priceData.variant_index!\n    );\n\n    if (result.result !== Status.Success) {\n        throw new Error(\n            'Could not send hallandale script - first time dosage selection'\n        );\n    }\n    return Status.Success;\n}"
      },
      {
        "name": "processReviveOrder",
        "kind": "function",
        "signature": "export async function processReviveOrder(\n    order: BaseOrderInterface,\n    priceData: Partial<ProductVariantRecord>,\n    patientData: DBPatientData\n) {\n    const reviveScript = await generateReviveScript(\n        patientData.id,\n        String(order.id),\n        {\n            product_href: order.product_href,\n            variant_index: priceData.variant_index!,\n        }\n    );\n\n    if (!reviveScript.script_json) {\n        throw new Error(\n            'Could not generate revive script - first time dosage selection'\n        );\n    }\n\n    const result = await sendReviveScript(\n        reviveScript.script_json,\n        String(order.id),\n        order.assigned_provider,\n        order.order_status,\n        OrderType.Order,\n        '',\n        '',\n        priceData.variant_index\n    );\n\n    if (result.result === Status.Success) {\n        return Status.Success;\n    }\n\n    console.log(\"Revive FTDS debug log: \", order?.id, priceData?.variant_index || \"no variant index\", order?.customer_uid || \"no customer uid\", order?.order_status, order?.assigned_provider, result?.reason || \"no result reason\")\n    throw new Error(\n        'Could not send revive script - first time dosage selection'\n    );\n}"
      },
      {
        "name": "processBoothwynOrder",
        "kind": "function",
        "signature": "export async function processBoothwynOrder(\n    order: BaseOrderInterface,\n    priceData: Partial<ProductVariantRecord>,\n    patientData: DBPatientData\n) {\n    const boothwynScript = generateBoothwynScriptWithData(\n        patientData as DBPatientData,\n        order as unknown as DBOrderData,\n        {\n            product_href: order.product_href,\n            variant_index: priceData.variant_index!,\n        }\n    );\n\n    if (!boothwynScript.script_json) {\n        throw new Error(\n            'Could not generate boothwyn script - first time dosage selection'\n        );\n    }\n\n    const result = await sendBoothwynScript(\n        boothwynScript.script_json,\n        String(order.id),\n        order.assigned_provider,\n        order.order_status,\n        OrderType.Order,\n        '',\n        '',\n        priceData.variant_index\n    );\n\n    if (result.result === Status.Success) {\n        return Status.Success;\n    }\n\n    throw new Error(\n        'Could not send boothwyn script - first time dosage selection'\n    );\n}"
      },
      {
        "name": "sendAutoMacro",
        "kind": "function",
        "signature": "export async function sendAutoMacro(\n    order: BaseOrderInterface,\n    priceData: Partial<ProductVariantRecord>,\n    patientData: DBPatientData\n) {\n    const thread_id = await getThreadIDByPatientIDAndProduct(\n        order.customer_uid,\n        order.product_href\n    );\n\n    if (!thread_id) {\n        throw new Error(\n            'Could not send auto macro - first time dosage selection'\n        );\n    }\n\n    const htmlMacroText = await getProviderMacroHTMLPrePopulated(\n        order.product_href,\n        priceData.variant_index!,\n        patientData as DBPatientData,\n        order.assigned_provider\n    );\n\n    const messagePayload: MessagePayload = {\n        content: htmlMacroText,\n        sender_id: order.assigned_provider, // hard coded customer support\n        thread_id: Number(thread_id),\n        contains_phi: false,\n        requires_coordinator: false,\n        requires_lead: false,\n        requires_provider: false,\n    };\n\n    await postNewMessage(messagePayload);\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/intake/order-util.ts",
      "bioverse-client/app/utils/database/controller/custom_orders/custom_orders_api.ts",
      "bioverse-client/app/utils/database/controller/orders/orders-api.ts",
      "bioverse-client/app/utils/functions/client-utils.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/IDAndSelfieCheckJobHandler.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/SendPrescriptionJobHandler.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/containers/components/ReviewModal.tsx",
      "bioverse-client/app/services/pharmacy-integration/empower/update-order.ts",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/utils/coordinator-task-data-fetch.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/utils/data-fetch/intake-view-datafetch.ts",
      "bioverse-client/app/utils/database/controller/orders/process-manual-order.ts",
      "bioverse-client/app/(testing_and_development)/olivier-dev/utils.ts",
      "bioverse-client/app/components/patient-portal/dosage-selection-first-time/components/FirstTimeAlmostDone.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/intake/product-data.ts",
    "exports": [
      {
        "name": "fetchProductImageAndPriceData",
        "kind": "function",
        "signature": "export async function fetchProductImageAndPriceData(productName: string) {\n    const supabase = await createSupabaseServerComponentClient();\n    const { data: productInformationData, error: informationDataError } =\n        await supabase\n            .from('products')\n            .select(\n                `image_ref, \n                variants,\n                name, \n                category, \n                description_short,\n                review_image_ref,\n                href`\n            )\n            .eq('href', productName)\n            .single();\n\n    if (informationDataError) {\n        console.log(informationDataError, informationDataError.message);\n        return {\n            prodcutData: null,\n            priceData: null,\n            error: informationDataError,\n        };\n    }\n\n    return {\n        productData: productInformationData,\n        error: null,\n    };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/intake/product-data.ts",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/new-checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v2/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3-abtest/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/ed-checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/product-overview/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3-zbp/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/new-checkout/page.tsx",
      "bioverse-client/_deprecated/checkout-test/page.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/intake/wl-supply.ts",
    "exports": [
      {
        "name": "getRecommendedDosage",
        "kind": "function",
        "signature": "export async function getRecommendedDosage(\n    intake_product_href: string,\n    questionInformation: QuestionInformation[]\n) {\n    const questionDict = await constructQuestionObject(questionInformation);\n    const hasTakenGLP =\n        questionDict[GLP1Questions.TakenGLP1].answer?.answer === 'Yes';\n\n    const previousGLPProduct =\n        questionDict[GLP1Questions.WhichGLP1].answer?.answer;\n\n    const lowestDosage =\n        MEDICATION_DICTIONARY_V3[\n            intake_product_href as keyof MedicationDictionary\n        ]['lowest_dosage'].dosage;\n\n    if (!lowestDosage) {\n        return Status.Failure;\n    }\n\n    console.log(\n        'hasTakenGLP',\n        questionDict[GLP1Questions.TakenGLP1].answer?.answer\n    );\n\n    if (hasTakenGLP) {\n        console.log('hasTakenGLP triggered');\n\n        const sameSemaglutide =\n            intake_product_href === SEMAGLUTIDE_PRODUCT_HREF &&\n            previousGLPProduct === IntakeProductNames.Semaglutide;\n        const sameTirzepatide =\n            intake_product_href === TIRZEPATIDE_PRODUCT_HREF &&\n            previousGLPProduct === IntakeProductNames.Tirzepatide;\n        // If the GLP1 medication they've taken recently is the same as what they're requesting (semaglutide or tirzepatide)\n        if (sameTirzepatide || sameSemaglutide) {\n            const useDifferentDosage =\n                questionDict[GLP1Questions.ContinueSameDosage].answer?.answer;\n\n            const recentlyWeeklyDosage =\n                questionDict[GLP1Questions.RecentWeeklyDosage].answer?.answer;\n\n            if (\n                recentlyWeeklyDosage === 'I do not remember' ||\n                recentlyWeeklyDosage.includes('Other')\n            ) {\n                return lowestDosage;\n            }\n            // If they want to use a different dosage, use the answer asked in the following question\n\n            if (useDifferentDosage === 'No') {\n                const newDosage =\n                    questionDict[GLP1Questions.NewRequestedDosage].answer\n                        ?.answer;\n                return await extractNumberFromDosage(newDosage);\n            } else if (useDifferentDosage === 'Yes') {\n                // Otherwise just recommend their last used dosage\n                return await extractNumberFromDosage(recentlyWeeklyDosage);\n            } else {\n                const retailDosageRecommender =\n                    await RetailDosageRecommender.getDosage(\n                        intake_product_href,\n                        questionDict\n                    );\n                if (retailDosageRecommender === -1) {\n                    return lowestDosage;\n                }\n                return retailDosageRecommender;\n            }\n        } else {\n            // const sameSemaglutide =\n            //     intake_product_href === SEMAGLUTIDE_PRODUCT_HREF &&\n            //     previousGLPProduct === IntakeProductNames.Semaglutide;\n            // const sameTirzepatide =\n            //     intake_product_href === TIRZEPATIDE_PRODUCT_HREF &&\n            //     previousGLPProduct === IntakeProductNames.Tirzepatide;\n\n            // if (sameSemaglutide || sameTirzepatide) {\n            //     return lowestDosage;\n            // }\n\n            const needsDifferentialCrossMap =\n                (intake_product_href === SEMAGLUTIDE_PRODUCT_HREF &&\n                    previousGLPProduct === IntakeProductNames.Tirzepatide) ||\n                (intake_product_href === TIRZEPATIDE_PRODUCT_HREF &&\n                    previousGLPProduct === IntakeProductNames.Semaglutide);\n\n            if (needsDifferentialCrossMap) {\n                const recentlyWeeklyDosage = await extractNumberFromDosage(\n                    questionDict[GLP1Questions.RecentWeeklyDosage].answer\n                        ?.answer\n                );\n\n                const foundDosage =\n                    MEDICATION_DICTIONARY_V3_CROSS_MAP[intake_product_href][\n                        recentlyWeeklyDosage\n                    ];\n\n                if (foundDosage) {\n                    return foundDosage.dosage;\n                }\n            }\n\n            console.log(\n                'needsDifferentialCrossMap',\n                needsDifferentialCrossMap,\n                questionDict[GLP1Questions.RecentWeeklyDosage].answer?.answer\n            );\n\n            const retailDosageRecommender =\n                await RetailDosageRecommender.getDosage(\n                    intake_product_href,\n                    questionDict\n                );\n            if (retailDosageRecommender === -1) {\n                return lowestDosage;\n            }\n            return retailDosageRecommender;\n        }\n    }\n\n    return lowestDosage;\n}"
      },
      {
        "name": "getRecommendedPrices",
        "kind": "function",
        "signature": "export async function getRecommendedPrices(\n    dosage: string | number,\n    product_href: string\n): Promise<{\n    bundlePrice: Partial<ProductVariantRecord> | null;\n    monthlyPrice: Partial<ProductVariantRecord> | null;\n    biannualPrice: Partial<ProductVariantRecord> | null;\n    annualPrice: Partial<ProductVariantRecord> | null;\n}> {\n    const recommendation = MEDICATION_DICTIONARY_V3[\n        product_href as keyof MedicationDictionary\n    ][dosage]\n        ? MEDICATION_DICTIONARY_V3[product_href as keyof MedicationDictionary][\n              dosage\n          ]\n        : MEDICATION_DICTIONARY_V3[product_href as keyof MedicationDictionary][\n              'lowest_dosage'\n          ];\n\n    const bundlePrice = await getPriceDataRecordWithVariant(\n        product_href,\n        recommendation.bundle_variant_index\n    );\n    const monthlyPrice = await getPriceDataRecordWithVariant(\n        product_href,\n        recommendation.monthly_variant_index\n    );\n\n    let biannualPrice = null;\n    if (recommendation.biannual_variant_index) {\n        biannualPrice = await getPriceDataRecordWithVariant(\n            product_href,\n            recommendation.biannual_variant_index\n        );\n    }\n\n    let annualPrice = null;\n    if (recommendation.annual_variant_index) {\n        annualPrice = await getPriceDataRecordWithVariant(\n            product_href,\n            recommendation.annual_variant_index\n        );\n    }\n\n    return { bundlePrice, monthlyPrice, biannualPrice, annualPrice };\n}"
      },
      {
        "name": "fetchData",
        "kind": "function",
        "signature": "export async function fetchData(\n    intake_product_href: string,\n    questionInformation: QuestionInformation[],\n    pvn?: string\n): Promise<{\n    bundlePrice: Partial<ProductVariantRecord> | null;\n    monthlyPrice: Partial<ProductVariantRecord> | null;\n    biannualPrice: Partial<ProductVariantRecord> | null;\n    annualPrice: Partial<ProductVariantRecord> | null;\n    semaglutideV74PriceData?: {\n        bundlePrice: Partial<ProductVariantRecord> | null;\n        monthlyPrice: Partial<ProductVariantRecord> | null;\n        biannualPrice: Partial<ProductVariantRecord> | null;\n        annualPrice: Partial<ProductVariantRecord> | null;\n    };\n\n} | null> {\n    const recommendedDosage = await getRecommendedDosage(\n        intake_product_href,\n        questionInformation\n    );\n\n    if (recommendedDosage === Status.Failure) {\n        return null;\n    }\n    let recommendedPrices: {\n        bundlePrice: Partial<ProductVariantRecord> | null;\n        monthlyPrice: Partial<ProductVariantRecord> | null;\n        biannualPrice: Partial<ProductVariantRecord> | null;\n        annualPrice: Partial<ProductVariantRecord> | null;\n    };\n\n    if (!recommendedDosage || (pvn && pvn !== '0')) { //the pvn may be changed from zero if the user goes to 'Modify my plan' and comes back\n        recommendedPrices = await getRecommendedPrices(\n            pvn ? pvn : 0,\n            intake_product_href\n        );\n    } else {\n        recommendedPrices = await getRecommendedPrices(\n            recommendedDosage,\n            intake_product_href\n        );\n    }\n\n    // Extra: Always fetch variant 74 for semaglutide\n    if (intake_product_href === SEMAGLUTIDE_PRODUCT_HREF) {\n        const variant = 74;\n\n        const [bundlePrice, monthlyPrice, biannualPrice, annualPrice] =\n            await Promise.all([\n                getPriceDataRecordWithVariant(intake_product_href, variant),\n                getPriceDataRecordWithVariant(intake_product_href, variant),\n                getPriceDataRecordWithVariant(intake_product_href, variant),\n                getPriceDataRecordWithVariant(intake_product_href, variant),\n            ]);\n\n        return {\n            ...recommendedPrices,\n            semaglutideV74PriceData: {\n                bundlePrice,\n                monthlyPrice,\n                biannualPrice,\n                annualPrice,\n            },\n        };\n    }\n\n    return recommendedPrices;\n}"
      },
      {
        "name": "constructQuestionObject",
        "kind": "function",
        "signature": "export async function constructQuestionObject(\n    questionInformation: QuestionInformation[]\n): Promise<{ [key: number]: QuestionInformation }> {\n    const result = questionInformation.reduce(\n        (\n            acc: { [key: number]: QuestionInformation },\n            item: QuestionInformation\n        ) => {\n            acc[item.question_id] = item;\n            return acc;\n        },\n        {}\n    );\n\n    return result;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/intake/wl-supply.ts",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3-abtest/page.tsx",
      "bioverse-client/app/components/provider-portal/messages/components/UserDetails.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/CancelSubscription/feedback/CancelFeedbackQuestion.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/glp-1-dosage-request.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-supply/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/new-checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-supply-v2/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v2/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-supply-v3-no-6/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-supply-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3-zbp/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/new-checkout/page.tsx",
      "bioverse-client/_deprecated/chat_old_6.10/testing.tsx",
      "bioverse-client/_deprecated/checkout-test/page.tsx",
      "bioverse-client/app/components/patient-portal/alternative-selection/weight-loss/continue-button/alt-continue-button.tsx",
      "bioverse-client/app/components/intake-v3/buttons/LoadingButtonCustom.tsx",
      "bioverse-client/app/components/intake-v2/buttons/LoadingButtonCustom.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/membership/membership-portal-actions.ts",
    "exports": [
      {
        "name": "getLicenseOrSelfieURL",
        "kind": "function",
        "signature": "export async function getLicenseOrSelfieURL(filePath: string) {\n    const supabase = await createSupabaseServiceClient();\n\n    const { data: urlData, error } = await supabase.storage\n        .from('license_and_selfie_images')\n        .createSignedUrl(filePath, 60 * 60);\n\n    if (error) {\n        console.log('getLicenseOrSelfieURL', error);\n        return { data: null, error: error };\n    } else return { data: urlData, error: null };\n}"
      },
      {
        "name": "getSideProfileURL",
        "kind": "function",
        "signature": "export async function getSideProfileURL(filePath: string) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { data: urlData, error } = await supabase.storage\n        .from('face-picture-uploads')\n        .createSignedUrl(filePath, 60 * 60);\n\n    if (error) {\n        console.log('getSideProfileURL', error);\n        return { data: null, error: error };\n    } else return { data: urlData, error: null };\n}"
      },
      {
        "name": "changeUserPassword",
        "kind": "function",
        "signature": "export async function changeUserPassword(\n    oldPassword: string,\n    newPassword: string,\n    userEmail: string\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    // Update the password if the old password is correct\n    const { data: updatedData, error: changePasswordError } =\n        await supabase.auth.updateUser({ password: newPassword });\n\n    if (changePasswordError) {\n        console.log('Failed to update password for user: ' + userEmail);\n        return 'new_password_issue';\n    }\n\n    console.log('Password updated successfully for user: ' + userEmail);\n    return 'success';\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/storage/license-selfie/license-selfie.ts",
      "bioverse-client/app/utils/actions/membership/membership-portal-actions.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/utils/license-selfies/signed-url-retriever.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/utils/license-selfies/signed-url-retriever.ts",
      "bioverse-client/app/(patient-portal)/portal/account-information/page.tsx",
      "bioverse-client/_deprecated/patient-intakes/[orderId]/page.tsx",
      "bioverse-client/app/components/patient-portal/account-information/personal-information/password-edit-drawer.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/membership/order-history-actions.ts",
    "exports": [
      {
        "name": "getPatientSinglePurchaseOrderHistory",
        "kind": "variable",
        "signature": "getPatientSinglePurchaseOrderHistory = async (\n    patientId: string,\n) => {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select(\n            `\n        id, created_at, customer_uid, variant_index, variant_text, discount_id, subscription_type, price, order_status, product_href, assigned_pharmacy, shipping_status, tracking_number,\n        product:products!product_href (\n            name,\n            image_ref\n        ),\n        shipping:profiles!customer_uid (\n            address_line1,\n            address_line2,\n            city,\n            state,\n            zip\n        )\n        `,\n        )\n        .neq('order_status', 'Incomplete')\n        .eq('customer_uid', patientId)\n        .eq('subscription_type', 'one_time');\n\n    if (error) return { error: error.message, data: null };\n\n    return { data };\n}"
      },
      {
        "name": "getPatientSubscriptionOrderHistory",
        "kind": "variable",
        "signature": "getPatientSubscriptionOrderHistory = async (patientId: string) => {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select(\n            `\n        id, created_at, customer_uid,variant_index, variant_text, discount_id, subscription_type, price, order_status, product_href, assigned_pharmacy, shipping_status, tracking_number,\n        product:products!product_href (\n            name,\n            image_ref\n        ),\n        shipping:profiles!customer_uid (\n            address_line1,\n            address_line2,\n            city,\n            state,\n            zip\n        )\n        `,\n        )\n        .neq('order_status', 'Incomplete')\n        .eq('customer_uid', patientId);\n\n    if (error) return { error: error.message, data: null };\n\n    return { data };\n}"
      },
      {
        "name": "getSubscriptionHistory",
        "kind": "variable",
        "signature": "getSubscriptionHistory = async (\n    patientId: string,\n): Promise<SubscriptionListItem[]> => {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc('get_subscription_list', {\n        user_id_: patientId,\n    });\n\n    if (error) {\n        console.error(\"Error retreiving user's subscription history\", error);\n        return [];\n    }\n    return data;\n}"
      },
      {
        "name": "cancelSubscription",
        "kind": "variable",
        "signature": "cancelSubscription = async (orderId: string) => {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data: priorStatus, error: priorStatusError } = await supabase\n        .from('orders')\n        .select('order_status')\n        .eq('id', orderId)\n        .single();\n\n    if (priorStatusError) {\n        console.log(priorStatusError.message);\n        return { data: null, error: priorStatusError.message };\n    }\n\n    const { data, error } = await supabase\n        .from('orders')\n        .update({\n            order_status: 'Canceled',\n            status_prior_to_cancellation: priorStatus.order_status,\n        })\n        .eq('id', orderId)\n        .select();\n\n    return { data };\n}"
      },
      {
        "name": "resumeSubscription",
        "kind": "variable",
        "signature": "resumeSubscription = async (orderId: string) => {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data: priorStatus, error: priorStatusError } = await supabase\n        .from('orders')\n        .select('status_prior_to_cancellation')\n        .eq('id', orderId)\n        .single();\n\n    if (priorStatusError) {\n        console.log(priorStatusError.message);\n        return { data: null, error: priorStatusError.message };\n    }\n\n    const { data, error } = await supabase\n        .from('orders')\n        .update({\n            order_status: priorStatus.status_prior_to_cancellation,\n        })\n        .eq('id', orderId)\n        .select();\n\n    return { data };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/membership/order-history-actions.ts",
      "bioverse-client/app/(testing_and_development)/dev/mock/subscriptions/[user_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/account-information/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/page.tsx",
      "bioverse-client/app/(administration)/admin/stripe-api/stripe-api-actions.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/subscriptions/components/subscription-accordion.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/order-tab-row.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/CancelFeedback/CancelFeedback.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/ResumeSubscription/ResumeSubscription.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/CancelSubscription/refill/ChangeRefillOffer.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/CancelSubscription/feedback/CancelFeedbackQuestion.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/CancelSubscription/CancelSubscriptionConfirm.tsx",
      "bioverse-client/app/components/patient-portal/order-history/manageSubscription.tsx",
      "bioverse-client/app/components/patient-portal/order-history/manageSubscriptionMobile.tsx",
      "bioverse-client/app/api/customerio/webhook/route.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/message/message-actions.ts",
    "exports": [
      {
        "name": "getThreadIdBetweenUsers",
        "kind": "function",
        "signature": "export async function getThreadIdBetweenUsers(\n    uuid1: string,\n    uuid2: string,\n    tab: number\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    if (tab === 0) {\n        const { data, error } = await supabase.rpc('get_common_thread_ids', {\n            user_id1: uuid1,\n            user_id2: uuid2,\n        });\n\n        if (error) {\n            console.log('Get common thread id error');\n            console.log(error, error.message);\n            return [];\n        } else {\n            return data.map((thread: any) => thread.thread_id);\n        }\n    } else {\n        const { data, error } = await supabase.rpc(\n            'get_unread_provider_messages'\n        );\n        if (error) {\n            console.log('get all threads error');\n            console.log(error, error.message);\n            return [];\n        } else {\n            return data.map((thread: any) => thread.thread_id);\n        }\n    }\n}"
      },
      {
        "name": "getAllThreadsForUser",
        "kind": "function",
        "signature": "export async function getAllThreadsForUser(uuid: string, tab: number) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    if (tab === 0) {\n        const { data, error } = await supabase\n            .from('thread_members')\n            .select('thread_id')\n            .eq('user_id', uuid);\n\n        if (error) {\n            console.log('get all threads error');\n            console.log(error, error.message);\n            return [];\n        } else {\n            return data.map((thread) => thread.thread_id);\n        }\n    } else {\n        const { data, error } = await supabase.rpc(\n            'get_unread_provider_messages'\n        );\n        if (error) {\n            console.log('get all threads error');\n            console.log(error, error.message);\n            return [];\n        } else {\n            return data.map((thread: any) => thread.thread_id);\n        }\n    }\n}"
      },
      {
        "name": "getThreadsData",
        "kind": "function",
        "signature": "export async function getThreadsData(\n    user_id: string,\n    thread_ids: number[],\n    tab: number\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const rpc_function =\n        tab === 0 ? 'get_latest_messages' : 'get_latest_unread_messages';\n    // Think just write another function if tab = 1\n    const { data, error } = await supabase.rpc(rpc_function, {\n        _thread_ids: thread_ids,\n        ...(tab === 0 && { lookup_user_id: user_id }),\n    });\n    // TODO: If tab = 1: ignore user_ids of providers\n\n    const tm_rpc_function =\n        tab === 0 ? 'get_thread_members' : 'get_thread_members_for_provider';\n    const { data: nameData, error: nameError } = await supabase.rpc(\n        tm_rpc_function,\n        {\n            ...(tab === 0 && { lookup_user_id: user_id }),\n            _thread_ids: thread_ids,\n        }\n    );\n\n    if (error) {\n        console.log('get latest messages error');\n        console.log(error, error.message);\n    } else if (nameError) {\n        console.log('get thread members error');\n        console.log(nameError, nameError.message);\n    }\n\n    const threadData: InitialThreadData[] = constructThreadData(\n        data,\n        nameData\n    ) as InitialThreadData[];\n\n    return threadData;\n}"
      },
      {
        "name": "getThreadConversation",
        "kind": "function",
        "signature": "export async function getThreadConversation(thread_id: number) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase.rpc('get_thread_messages', {\n        thread_id_: thread_id,\n    });\n\n    if (error) {\n        console.log('get thread conversation error');\n        console.log(error, error.message);\n    }\n    return data;\n}"
      },
      {
        "name": "dispatchMessage",
        "kind": "function",
        "signature": "export async function dispatchMessage(message_payload: MessagePayload) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('messages')\n        .insert(message_payload)\n        .select();\n\n    if (error) {\n        console.log('dispatch message error');\n        console.log(error, error.message);\n        return false;\n    }\n\n    viewedMessage(message_payload.sender_id, message_payload.thread_id);\n\n    return data;\n}"
      },
      {
        "name": "getUsersToMessage",
        "kind": "function",
        "signature": "export async function getUsersToMessage(\n    user_id: string,\n    isProvider: boolean\n): Promise<any> {\n    const supabase = createSupabaseServerComponentClient();\n    let result;\n\n    try {\n        if (user_id === process.env.NEXT_PUBLIC_CUSTOMER_SUPPORT_USER_ID) {\n            result = await supabase.rpc('get_all_patients_and_providers');\n        } else if (isProvider) {\n            result = await supabase.rpc('get_patients_for_provider', {\n                provider_id_: user_id,\n            });\n        } else {\n            result = await supabase.rpc('get_provider_information', {\n                lookup_user_id: user_id,\n            });\n        }\n    } catch (error) {\n        if (typeof error === 'object' && error !== null && 'message' in error) {\n            console.error(`Error fetching users to message: ${error.message}`);\n        } else {\n            console.error(\n                'An unknown error occurred while fetching users to message.'\n            );\n        }\n        throw error; // Optionally rethrow the error if you want the caller to handle it\n    }\n\n    if ('error' in result && result.error) {\n        console.error(`Error in response: ${result.error.message}`);\n        return false;\n    }\n\n    return result.data;\n}"
      },
      {
        "name": "dispatchNewMessage",
        "kind": "function",
        "signature": "export async function dispatchNewMessage(\n    user_id: string,\n    receiver_id: string,\n    content: string\n) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const thread_id = await createOrGetThread(user_id, receiver_id);\n\n    // Fire Message\n    const NewMessage: MessagePayload = {\n        sender_id: user_id,\n        content,\n        thread_id,\n    };\n\n    await dispatchMessage(NewMessage);\n\n    /**\n     * Customer IO activation for tracking message\n     */\n    await trackMessageEvent(user_id, thread_id);\n}"
      },
      {
        "name": "createOrGetThread",
        "kind": "function",
        "signature": "export async function createOrGetThread(user_id: string, receiver_id: string) {\n    const supabase = createSupabaseServerComponentClient();\n\n    // 1. Check if a thread exists between the users\n    const { data: existingThread, error: existingThreadError } =\n        await supabase.rpc('check_existing_thread', {\n            user_id_1: user_id,\n            user_id_2: receiver_id,\n        });\n\n    if (existingThreadError) {\n        console.log('existing thread error');\n        console.log(existingThreadError, existingThreadError.message);\n    }\n\n    if (existingThread.length > 0) {\n        return existingThread[0].thread_id_;\n    }\n\n    // 2. Create a new thread if no existing thread\n\n    const newThreadID = await createNewThread();\n\n    if (!newThreadID) {\n        return false;\n    }\n\n    // 3. Add users to the thread\n\n    const threadMembers = await addThreadMembers(\n        user_id,\n        receiver_id,\n        newThreadID\n    );\n\n    return newThreadID;\n}"
      },
      {
        "name": "getOtherUserInThread",
        "kind": "function",
        "signature": "export async function getOtherUserInThread(\n    user_id: string,\n    thread_id: number | undefined\n) {\n    if (!thread_id) {\n        return false;\n    }\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .rpc('get_other_user_in_thread', {\n            user_id_: user_id,\n            thread_id_: thread_id,\n        })\n        .single();\n    console.log(data);\n    if (error) {\n        console.log('get other user in thread error');\n        console.error(error, error.message);\n        return;\n    }\n\n    return data;\n}"
      },
      {
        "name": "addThreadMembers",
        "kind": "function",
        "signature": "export async function addThreadMembers(\n    user_id: string,\n    receiver_id: string,\n    thread_id: any\n) {\n    const supabase = createSupabaseServerComponentClient();\n\n    if (!user_id || !receiver_id || !thread_id) {\n        console.log('Invalid incoming data!');\n        return false;\n    }\n\n    // Add both users\n    const { data, error } = await supabase.from('thread_members').insert([\n        { user_id, thread_id },\n        { user_id: receiver_id, thread_id },\n    ]);\n\n    if (error) {\n        console.log('add thread members error');\n        console.log(error, error.message);\n        return false;\n    }\n    return data;\n}"
      },
      {
        "name": "createNewThread",
        "kind": "function",
        "signature": "export async function createNewThread() {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase.from('threads').insert({}).select();\n\n    if (error || data.length === 0) {\n        console.log('create new thread error');\n        console.log(error, error?.message);\n        return false;\n    }\n\n    return data[0].id;\n}"
      },
      {
        "name": "viewedMessage",
        "kind": "function",
        "signature": "export async function viewedMessage(user_id: string, thread_id: number) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { error } = await supabase\n        .from('thread_members')\n        .update({ last_read_at: new Date() })\n        .eq('user_id', user_id)\n        .eq('thread_id', thread_id);\n\n    if (error) {\n        console.error(error, error.message);\n    }\n}"
      },
      {
        "name": "getNumberUnreadMessages",
        "kind": "function",
        "signature": "export async function getNumberUnreadMessages(\n    user_id: string\n): Promise<UnreadMessages> {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .rpc('get_number_unread_messages', { user_id_: user_id })\n        .single();\n\n    if (error) {\n        console.error(\n            'Error retreiving number of unread messages for user',\n            user_id\n        );\n        console.error(error);\n        return { unread_messages: 0 };\n    }\n\n    return data as UnreadMessages;\n}"
      },
      {
        "name": "getNumberUnreadProviderMessages",
        "kind": "function",
        "signature": "export async function getNumberUnreadProviderMessages(\n    user_id: string\n): Promise<UnreadMessages> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .rpc('get_number_unread_provider_messages', { user_id_: user_id })\n        .single();\n\n    if (error) {\n        console.error(\n            'Error retreiving number of unread messages for user',\n            user_id\n        );\n        console.error(error);\n        return { unread_messages: 0 };\n    }\n\n    return data as UnreadMessages;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/message/message-actions.ts",
      "bioverse-client/app/utils/functions/provider-portal/messages/admin-message-center.ts",
      "bioverse-client/_deprecated/chat_old_6.10/chatUI-old.tsx",
      "bioverse-client/_deprecated/chat_old_6.10/chatUI.tsx",
      "bioverse-client/_deprecated/chat_old_6.10/chatInterface.tsx",
      "bioverse-client/_deprecated/chat_old_6.10/messageMobile.tsx",
      "bioverse-client/_deprecated/chat_old_6.10/chatInterface-old.tsx",
      "bioverse-client/_deprecated/chat_old_6.10/messageUi.tsx",
      "bioverse-client/_deprecated/chat_old_6.10/newMessageModal.tsx",
      "bioverse-client/app/services/customerio/event_actions.ts",
      "bioverse-client/app/utils/database/controller/orders/create-manual-order.ts",
      "bioverse-client/app/utils/database/controller/messaging/threads/threads.ts",
      "bioverse-client/app/components/intake-v3/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component-ab.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/ed/ed-checkout/ed-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/components/wl-checkout-component-fulltest.tsx",
      "bioverse-client/app/components/intake-v2/checkout/checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/coordinator-portal/navbar/components/coordinator-portal-tabs.tsx",
      "bioverse-client/app/components/provider-portal/nav-bar/tabs/provider-tabs.tsx",
      "bioverse-client/app/components/registered-nurse-portal/nav-bar/registered-nurse-tabs.tsx/registered-nurse-tabs.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/message/message-user.ts",
    "exports": [
      {
        "name": "getAccountProfileDataforMessage",
        "kind": "function",
        "signature": "export async function getAccountProfileDataforMessage(uuid: string) {\n    const supabase = await createSupabaseServiceClient();\n    const { data, error } = await supabase\n        .from('profiles')\n        .select('id,authorization,first_name')\n        .eq('id', uuid)\n        .single();\n\n    if (error) {\n        console.log(error, error.message);\n    } else {\n        return data;\n    }\n}"
      },
      {
        "name": "getAllAccountProfiles",
        "kind": "function",
        "signature": "export async function getAllAccountProfiles() {\n    const supabase = await createSupabaseServiceClient();\n    const { data, error } = await supabase.from('profiles').select('*');\n\n    if (error) {\n        console.log(error, error.message);\n        return null;\n    } else {\n        return data;\n    }\n}"
      },
      {
        "name": "getUserAuthorization",
        "kind": "function",
        "signature": "export async function getUserAuthorization(uuid: string) {\n    const supabase = await createSupabaseServiceClient();\n    const { data, error } = await supabase\n        .from('profiles')\n        .select('*')\n        .eq('id', uuid)\n        .single();\n\n    if (error) {\n        console.error('Error fetching current user profile:', error);\n        return null;\n    }\n    console.log(data);\n\n    return data;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/message/message-user.ts",
      "bioverse-client/_deprecated/chat_old_6.10/testing.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/message/message-util.ts",
    "exports": [
      {
        "name": "formatThreadSidebarTimestamp",
        "kind": "function",
        "signature": "export function formatThreadSidebarTimestamp(timestamp: Date): string {\n    const currentDate = new Date();\n    const inputDate = new Date(timestamp);\n\n    // Calculate the difference in days\n    const diffDays = Math.floor(\n        (currentDate.getTime() - inputDate.getTime()) / (1000 * 3600 * 24)\n    );\n\n    // If it's today, return the current time\n    if (diffDays === 0) {\n        const hours = inputDate.getHours().toString().padStart(2, '0');\n        const minutes = inputDate.getMinutes().toString().padStart(2, '0');\n        return `${hours}:${minutes}`;\n    }\n    // If it's yesterday, return 'Yesterday'\n    else if (diffDays === 1) {\n        return 'Yesterday';\n    }\n    // Otherwise, return the date formatted as '05 Apr'\n    else {\n        const options = { day: '2-digit', month: 'short' } as const;\n        return inputDate.toLocaleDateString('en-US', options);\n    }\n}"
      },
      {
        "name": "formatToMonthDay",
        "kind": "function",
        "signature": "export function formatToMonthDay(timestamp: Date): string {\n    const date = new Date(timestamp);\n  \n  // Format to \"Month Day\" like \"January 22\"\n  const options: Intl.DateTimeFormatOptions = { month: 'long', day: 'numeric' };\n  return date.toLocaleDateString('en-US', options);\n}"
      },
      {
        "name": "getMessageSecondsDifference",
        "kind": "variable",
        "signature": "getMessageSecondsDifference = (\n    timestampA: string | Date,\n    timestampB: string | Date\n): number => {\n    const dateA = new Date(timestampA);\n    const dateB = new Date(timestampB);\n    const diffInS = Math.floor((dateA.getTime() - dateB.getTime()) / 1000);\n\n    return diffInS;\n}"
      },
      {
        "name": "formatChatTimestamp",
        "kind": "function",
        "signature": "export function formatChatTimestamp(timestamp: Date) {\n    const options = {\n        day: '2-digit',\n        month: 'short',\n        hour: '2-digit',\n        minute: '2-digit',\n    } as const;\n    return new Date(timestamp).toLocaleString('en-US', options);\n}"
      },
      {
        "name": "updateInitialThreadData",
        "kind": "function",
        "signature": "export function updateInitialThreadData(\n    initialThreadData: InitialThreadData[],\n    currentMessage: any,\n    thread_id: number\n) {\n    // Find the index of the object with the specified thread_id\n    const indexToMove = initialThreadData.findIndex(\n        (thread) => thread.thread_id === thread_id\n    );\n\n    // If the thread_id is not found, return the original array\n    if (indexToMove === -1) {\n        return initialThreadData;\n    }\n\n    // Update the entry of the object being moved\n    const movedThread = {\n        ...initialThreadData[indexToMove],\n        message: {\n            ...initialThreadData[indexToMove].message,\n            content: currentMessage,\n            created_at: new Date(Date.now()),\n        },\n    };\n\n    // Remove the object from its current position\n    initialThreadData.splice(indexToMove, 1);\n\n    // Move the object to the beginning of the array\n    initialThreadData.unshift(movedThread);\n    return initialThreadData;\n}"
      },
      {
        "name": "updateLastViewedThread",
        "kind": "function",
        "signature": "export function updateLastViewedThread(\n    thread: InitialThreadData,\n    initialThreadData: InitialThreadData[],\n    setInitialThreadData: any\n): void {\n    const threadIndex = initialThreadData.findIndex(\n        (t) => t.thread_id === thread.thread_id\n    );\n\n    if (threadIndex !== -1) {\n        // Create a new array with the updated thread\n        const updatedThreadData = [...initialThreadData];\n        const updatedMessage = {\n            ...updatedThreadData[threadIndex].message,\n            last_read_at: new Date(), // Set the last_read_at to the current date and time\n        };\n        updatedThreadData[threadIndex] = {\n            ...updatedThreadData[threadIndex],\n            message: updatedMessage,\n        };\n\n        // Update the state with the new array\n        setInitialThreadData(updatedThreadData);\n    }\n}"
      },
      {
        "name": "truncateMessageContent",
        "kind": "function",
        "signature": "export function truncateMessageContent(content: string, maxLength: number) {\n    if (typeof content !== 'string') {\n        throw new TypeError('Input must be a string');\n    }\n\n    return content.length <= maxLength\n        ? content\n        : content.slice(0, maxLength) + '...';\n}"
      },
      {
        "name": "hasMessageBeenRead",
        "kind": "function",
        "signature": "export function hasMessageBeenRead(\n    thread: InitialThreadData,\n    currentThread: InitialThreadData | null\n) {\n    if (thread.thread_id === currentThread?.thread_id) {\n        return true;\n    }\n\n    const createdAt = new Date(thread.message.created_at);\n    const lastReadAt = new Date(thread.message.last_read_at);\n\n    // Compare the dates in UTC to avoid timezone issues\n    if (createdAt.getTime() > lastReadAt.getTime()) {\n        return false;\n    } else {\n        return true;\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/message/message-util.ts",
      "bioverse-client/app/components/coordinator-portal/message-dashboard/preview-card/preview-card.tsx",
      "bioverse-client/app/components/coordinator-portal/message-dashboard/preview-card/search-preview-card.tsx",
      "bioverse-client/app/components/provider-portal/messages/components/provider-message-dashboard/preview-card/preview-card.tsx",
      "bioverse-client/app/components/provider-portal/messages/components/provider-message-dashboard/preview-card/search-preview-card.tsx",
      "bioverse-client/app/components/patient-portal/message/preview-list/preview-card/preview-card.tsx",
      "bioverse-client/_deprecated/chat_old_6.10/messagePreview.tsx",
      "bioverse-client/_deprecated/chat_old_6.10/messageMobile.tsx",
      "bioverse-client/_deprecated/chat_old_6.10/chatUI-old.tsx",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/tab-column/message/message-display.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/messages/components/messages-allpatients-content.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/message/message-display.tsx",
      "bioverse-client/app/components/patient-portal/message/thread-container/thread-message/thread-message.tsx",
      "bioverse-client/app/components/patient-portal/message/thread-container/thread-container-new.tsx",
      "bioverse-client/_deprecated/chat_old_6.10/chatInterface.tsx",
      "bioverse-client/_deprecated/chat_old_6.10/messageView.tsx",
      "bioverse-client/_deprecated/chat_old_6.10/chatInterface-old.tsx",
      "bioverse-client/_deprecated/chat_old_6.10/chatUI.tsx",
      "bioverse-client/_deprecated/chat_old_6.10/messageUi.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/message/message-v2-actions.ts",
    "exports": [
      {
        "name": "loadPatientThreadData",
        "kind": "function",
        "signature": "export async function loadPatientThreadData(\n    patient_id: string,\n): Promise<{ id: string; product: string; messages: any[] }[]> {\n    let thread_and_message_data: any[] = [];\n\n    const thread_array = await listAllThreadsForPatient(patient_id);\n\n    for (const thread of thread_array) {\n        const message_array = await getMessagesForThread(thread.id);\n\n        thread_and_message_data.push({\n            id: thread.id,\n            product: thread.product,\n            messages: [...message_array],\n        });\n    }\n\n    // console.log('THRHRHRHR ', thread_and_message_data[0].messages);\n\n    return thread_and_message_data;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/message/message-v2-actions.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/tab-column/message/message-display.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/messages/components/messages-allpatients-content.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/message/message-display.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/message/messageTest.ts",
    "exports": [
      {
        "name": "getMessages",
        "kind": "function",
        "signature": "export async function getMessages(userId: string, providerId: string) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('messages')\n        .select('*')\n        .in('sender_id', [userId, providerId])\n        .in('provider_id', [userId, providerId])\n        .order('created_at', { ascending: true });\n\n    if (error) {\n        return { error: error.message, data: null };\n    }\n\n    return { data, error: null };\n}"
      },
      {
        "name": "sendMessage",
        "kind": "function",
        "signature": "export async function sendMessage(\n    sender_id: string,\n    provider_id: string,\n    message: string,\n) {\n    if (!sender_id || !provider_id || !message) {\n        console.error('Invalid sender_id, provider_id, or message:', {\n            sender_id,\n            provider_id,\n            message,\n        });\n        return {\n            error: 'Invalid sender_id, provider_id, or message',\n            data: null,\n        };\n    }\n\n    const supabase = createSupabaseServerComponentClient();\n    const { data, error } = await supabase\n        .from('messages')\n        .insert([{ sender_id, provider_id, message }])\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error sending message:', error);\n        return { error: error.message, data: null };\n    }\n\n    return { data };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/coordinator_activity_audit/coordinator_activity_audit-api.ts",
      "bioverse-client/app/utils/database/controller/messaging/messages/messages.ts",
      "bioverse-client/app/utils/actions/message/message-v2-actions.ts",
      "bioverse-client/app/utils/actions/message/messageTest.ts",
      "bioverse-client/app/components/patient-portal/message/thread-container/thread-container-new.tsx",
      "bioverse-client/app/components/patient-portal/message/thread-container/thread-container.tsx",
      "bioverse-client/_deprecated/chat_old_6.10/testing.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/pdp-api/pdp-api.ts",
    "exports": [
      {
        "name": "fetchProducts",
        "kind": "function",
        "signature": "export async function fetchProducts() {\n    const supabase = createSupabaseServerComponentClient();\n    const { data, error } = await supabase.from('products').select('*');\n\n    if (error) {\n        return { error: error.message, data: null };\n    }\n\n    return { data, error: null };\n}"
      },
      {
        "name": "fetchProduct",
        "kind": "function",
        "signature": "export async function fetchProduct(productId: any) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('products')\n        .select('*')\n        .eq('id', productId)\n        .single();\n\n    console.log('Fetching product with ID:', productId);\n    if (!productId) {\n        console.error('Product ID is undefined');\n        return { error: 'Product ID is undefined', data: null };\n    }\n\n    if (error) {\n        console.error('Error fetching product:', error);\n        return { error: error.message, data: null };\n    }\n\n    return { data, error: null };\n}"
      },
      {
        "name": "deleteProduct",
        "kind": "function",
        "signature": "export async function deleteProduct(productId: number, productHref: string) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { error: deletePriceError } = await supabase\n        .from('product_price')\n        .delete()\n        .filter('reference_id', 'eq', productId)\n        .or('product_href.eq.' + productHref);\n\n    if (deletePriceError) {\n        console.error(\n            'Error deleting related product prices:',\n            deletePriceError,\n        );\n        return { error: deletePriceError.message, data: null };\n    }\n\n    const { error: deleteProductError } = await supabase\n        .from('products')\n        .delete()\n        .match({ id: productId });\n\n    if (deleteProductError) {\n        console.error('Error deleting product:', deleteProductError);\n        return { error: deleteProductError.message, data: null };\n    }\n\n    return {\n        data: 'Product and dependencies successfully deleted',\n        error: null,\n    };\n}"
      },
      {
        "name": "updateProduct",
        "kind": "function",
        "signature": "export async function updateProduct(productId: any, updatedProductInfo: any) {\n    const supabase = createSupabaseServerComponentClient();\n\n    // Filter out empty fields\n    const nonEmptyFields = Object.keys(updatedProductInfo).reduce(\n        (acc, key) => {\n            if (updatedProductInfo[key] !== '') {\n                acc[key] = updatedProductInfo[key];\n            }\n            return acc;\n        },\n        {} as ProductInfo,\n    );\n\n    const { data, error } = await supabase\n        .from('products')\n        .update(nonEmptyFields)\n        .match({ id: productId });\n\n    if (error) {\n        console.error('Error updating product:', error);\n        return { error: error.message, data: null };\n    }\n\n    return { data, error: null };\n}"
      },
      {
        "name": "updateProductPrice",
        "kind": "function",
        "signature": "export async function updateProductPrice(\n    productId: any,\n    updatedPriceInfo: any,\n) {\n    const supabase = createSupabaseServerComponentClient();\n    console.log('updatedPriceInfo:', updatedPriceInfo);\n    const { data, error } = await supabase\n        .from('product_price')\n        .update(updatedPriceInfo)\n        .match({\n            reference_id: productId,\n            variant_index: updatedPriceInfo.variant_index,\n        });\n\n    if (error) {\n        console.error('Error updating product price:', error);\n        return { error: error.message, data: null };\n    }\n\n    return { data, error: null };\n}"
      },
      {
        "name": "createProduct",
        "kind": "function",
        "signature": "export async function createProduct(newProductInfo: any) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data: productData, error: productError } = await supabase\n        .from('products')\n        .insert([newProductInfo])\n        .select();\n\n    if (productError) {\n        console.error('Error in creating product:', productError);\n        console.error('Error details:', productError.details);\n        console.error('Error hint:', productError.hint);\n        throw new Error(productError.message);\n    }\n\n    if (!Array.isArray(productData) || productData.length === 0) {\n        throw new Error('No product data returned from Supabase.');\n    }\n\n    return productData[0];\n}"
      },
      {
        "name": "createProductPrice",
        "kind": "function",
        "signature": "export async function createProductPrice(\n    productId: any,\n    productHerf: any,\n    variantList: any,\n) {\n    const supabase = createSupabaseServerComponentClient();\n\n    if (\n        !variantList ||\n        !variantList.variants ||\n        variantList.variants.length === 0\n    ) {\n        console.log('No variants to process');\n        return;\n    }\n\n    for (const variant of variantList.variants) {\n        console.log(\n            'variant.subcription_includes_bullets:',\n            JSON.stringify(variant.subcription_includes_bullets),\n        );\n        const isone_timeComplete =\n            variant.one_time &&\n            variant.one_time.length > 0 &&\n            variant.one_time[0].marketPrice !== null &&\n            variant.one_time[0].checkoutPrice !== null &&\n            variant.one_time[0].originalPrice !== null &&\n            variant.one_time[0].subcription_subtext !== '' &&\n            variant.one_time[0].subcription_includes_bullets !== '';\n\n        const isMonthlyComplete =\n            variant.monthly &&\n            variant.monthly.length > 0 &&\n            variant.monthly[0].marketPrice !== null &&\n            variant.monthly[0].checkoutPrice !== null &&\n            variant.monthly[0].originalPrice !== null &&\n            variant.monthly[0].subcription_subtext !== '' &&\n            variant.monthly[0].subcription_includes_bullets !== '';\n\n        const isquarterlyComplete =\n            variant.quarterly &&\n            variant.quarterly.length > 0 &&\n            variant.quarterly[0].marketPrice !== null &&\n            variant.quarterly[0].checkoutPrice !== null &&\n            variant.quarterly[0].originalPrice !== null &&\n            variant.quarterly[0].subcription_subtext !== '' &&\n            variant.quarterly[0].subcription_includes_bullets !== '';\n        const priceData = {\n            reference_id: productId,\n            product_href: productHerf,\n\n            one_time: isone_timeComplete\n                ? [\n                      {\n                          marketPrice: variant.one_time[0].marketPrice,\n                          checkoutPrice: variant.one_time[0].checkoutPrice,\n                          originalPrice: variant.one_time[0].originalPrice,\n                          subcription_subtext:\n                              variant.one_time[0].subcription_subtext,\n                          subcription_includes_bullets:\n                              variant.one_time[0].subcription_includes_bullets,\n                      },\n                  ]\n                : null,\n            monthly: isMonthlyComplete\n                ? [\n                      {\n                          marketPrice: variant.monthly[0].marketPrice,\n                          checkoutPrice: variant.monthly[0].checkoutPrice,\n                          originalPrice: variant.monthly[0].originalPrice,\n                          subcription_subtext:\n                              variant.monthly[0].subcription_subtext,\n                          subcription_includes_bullets:\n                              variant.monthly[0].subcription_includes_bullets,\n                      },\n                  ]\n                : null,\n            quarterly: isquarterlyComplete\n                ? [\n                      {\n                          marketPrice: variant.quarterly[0].marketPrice,\n                          checkoutPrice: variant.quarterly[0].checkoutPrice,\n                          originalPrice: variant.quarterly[0].originalPrice,\n                          subcription_subtext:\n                              variant.quarterly[0].subcription_subtext,\n                          subcription_includes_bullets:\n                              variant.quarterly[0].subcription_includes_bullets,\n                      },\n                  ]\n                : null,\n            variant: variant.variant,\n            variant_index: variant.variant_index,\n        };\n        console.log('priceData: ++++++++', priceData);\n        const { error } = await supabase\n            .from('product_price')\n            .insert([priceData]);\n\n        if (error) {\n            console.error('Error creating product price for variant:', error);\n            throw new Error(error.message);\n        }\n    }\n\n    return { message: 'Product prices for all variants created successfully' };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(administration)/admin/pdpapi/page.tsx",
      "bioverse-client/app/utils/actions/pdp-api/pdp-api.ts",
      "bioverse-client/app/(administration)/admin/pdpapi/[id]/productNameSection.tsx",
      "bioverse-client/app/(administration)/admin/pdpapi/[id]/variant.tsx",
      "bioverse-client/app/(administration)/admin/pdpapi/[id]/page.tsx",
      "bioverse-client/app/utils/actions/intake/product-data.ts",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/new-checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v2/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3-abtest/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/ed-checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/product-overview/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3-zbp/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/new-checkout/page.tsx",
      "bioverse-client/_deprecated/checkout-test/page.tsx",
      "bioverse-client/app/utils/database/api-controller/product_prices/product-prices.ts",
      "bioverse-client/_deprecated/priceapi/_components/priceEditAPI/main-container.tsx",
      "bioverse-client/app/(administration)/admin/pdpapi/create-product/page.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/prescription-subscriptions/prescription-subscriptions-actions.ts",
    "exports": [
      {
        "name": "updateRenewalCount",
        "kind": "function",
        "signature": "export async function updateRenewalCount(\n    order_id: number | string,\n    orderType: OrderType\n) {\n    const supabase = createSupabaseServiceClient();\n    if (orderType === OrderType.Order) {\n        const { data, error } = await getOrderDetailsById(Number(order_id));\n\n        if (!data || !data.subscription_id) {\n            console.error('Unable to update renewal count for order', order_id);\n            return;\n        }\n\n        const { data: rpcData, error: rpcError } = await supabase.rpc(\n            'increment_renewal_count',\n            { subscription_id_: data.subscription_id }\n        );\n\n        if (rpcError) {\n            console.error('Error updating renewal count:', rpcError, data);\n        }\n    } else {\n        const renewalOrder = await getRenewalOrder(String(order_id));\n\n        if (!renewalOrder) {\n            console.error(\n                'Unable to update renewal count for renewal order',\n                order_id\n            );\n            return;\n        }\n\n        const { data: rpcData, error: rpcError } = await supabase.rpc(\n            'increment_renewal_count',\n            { subscription_id_: renewalOrder.subscription_id }\n        );\n\n        if (rpcError) {\n            console.error(\n                'Error updating renewal count:',\n                rpcError,\n                renewalOrder\n            );\n        }\n    }\n}"
      },
      {
        "name": "getAllGLP1SubscriptionsForProduct",
        "kind": "function",
        "signature": "export async function getAllGLP1SubscriptionsForProduct(\n    customer_id: string\n): Promise<PrescriptionSubscription[] | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('prescription_subscriptions')\n        .select('*')\n        .in('product_href', [WEIGHT_LOSS_PRODUCT_HREF])\n        .eq('patient_id', customer_id);\n\n    if (error) {\n        console.error(\n            'Error doesCustomerHaveOrderWithProduct',\n            error,\n            customer_id\n        );\n        return null;\n    }\n\n    return data as PrescriptionSubscription[];\n}"
      },
      {
        "name": "getAllActiveGLP1SubscriptionsForProduct",
        "kind": "function",
        "signature": "export async function getAllActiveGLP1SubscriptionsForProduct(\n    customer_id: string\n): Promise<PrescriptionSubscription[]> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('prescription_subscriptions')\n        .select('*')\n        .in('product_href', WEIGHT_LOSS_PRODUCT_HREF)\n        .eq('patient_id', customer_id)\n        .eq('status', 'active');\n\n    if (error) {\n        console.error(\n            'Error doesCustomerHaveOrderWithProduct active subs',\n            error,\n            customer_id\n        );\n        return [];\n    }\n\n    return data as PrescriptionSubscription[];\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/prescription_subscriptions/prescription_subscriptions.ts",
      "bioverse-client/app/utils/actions/prescription-subscriptions/prescription-subscriptions-actions.ts",
      "bioverse-client/app/api/easypost/route.tsx",
      "bioverse-client/app/services/pharmacy-integration/empower/send-script.ts",
      "bioverse-client/app/services/pharmacy-integration/curexa/curexa-actions.ts",
      "bioverse-client/app/services/pharmacy-integration/gogomeds/ggm-actions.ts",
      "bioverse-client/app/services/pharmacy-integration/tmc/tmc-actions.ts",
      "bioverse-client/app/utils/database/controller/questionnaires/questionnaire.ts",
      "bioverse-client/app/utils/database/controller/orders/create-order.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/provider/active-subscriptions.ts",
    "exports": [
      {
        "name": "getActiveSubscriptionInfobyPatientId",
        "kind": "function",
        "signature": "export async function getActiveSubscriptionInfobyPatientId(patientId: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: subscriptionData, error: patientDataFetchError } = await supabase\n        .from('prescription_subscriptions')\n        .select(\n            `\n            id,\n            order_id,\n            product_href,\n            orders!prescription_subscriptions_order_id_fkey ( id, assigned_dosage, product_href )          \n            `\n        )\n        .eq('patient_id', patientId)\n        .eq('status', 'active')\n        .returns<ActiveSub[]>();\n\n    if (patientDataFetchError) {\n        console.log('Patient Subscriptions TS: ', patientDataFetchError.message);\n        return { data: null, error: patientDataFetchError };\n    }\n\n    return { data: subscriptionData, error: null };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/provider/active-subscriptions.ts",
      "bioverse-client/app/components/provider-coordinator-shared/order-charts/components/ActiveSubscriptionsPill.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/provider/announcements.ts",
    "exports": [
      {
        "name": "getDefaultAnnouncementRoles",
        "kind": "function",
        "signature": "export async function getDefaultAnnouncementRoles(): Promise<BV_AUTH_TYPE[]> {\n    return DEFAULT_ANNOUNCEMENT_ROLES;\n}"
      },
      {
        "name": "uploadAnnouncementImage",
        "kind": "function",
        "signature": "export async function uploadAnnouncementImage(\n    formData: FormData\n): Promise<string> {\n    const supabase = createSupabaseServiceClient();\n\n    const file = formData.get('file') as File;\n\n    const uuid = crypto.randomUUID();\n    const fileExt = file.name.split('.').pop();\n    const fileName = `${uuid}.${fileExt}`;\n    const imagePath = `announcement-images/${fileName}`;\n\n    let { error } = await supabase.storage\n        .from('bioverse-images')\n        .upload(imagePath, file);\n\n    if (error) {\n        throw error;\n    }\n\n    return imagePath;\n}"
      },
      {
        "name": "createAnnouncement",
        "kind": "function",
        "signature": "export async function createAnnouncement(\n    announcement: Announcement\n): Promise<void> {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase.from('announcements').insert(announcement);\n\n    if (error) {\n        throw error;\n    }\n}"
      },
      {
        "name": "getAnnouncementHistory",
        "kind": "function",
        "signature": "export async function getAnnouncementHistory(): Promise<Announcement[]> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('announcements')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        throw error;\n    }\n\n    return addImageUrlsToAnnouncements(data);\n}"
      },
      {
        "name": "getAnnouncementsForProvider",
        "kind": "function",
        "signature": "export async function getAnnouncementsForProvider(\n    providerId: UUID,\n    role: BV_AUTH_TYPE\n): Promise<Announcement[]> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: receiptData, error: receiptError } = await supabase\n        .from('announcement_receipts')\n        .select('updated_at')\n        .eq('user_id', providerId)\n        .single();\n\n    if (receiptError && receiptError.code !== 'PGRST116') {\n        throw receiptError;\n    }\n\n    const lastViewedAt = receiptData?.updated_at\n        ? new Date(receiptData.updated_at)\n        : new Date(0);\n    // const lastViewedAt = new Date(0);\n\n    const { data: announcementsData, error: announcementsError } =\n        await supabase\n            .from('announcements')\n            .select('*')\n            .contains('roles', [role])\n            .gt(\n                'updated_at',\n                new Date(\n                    lastViewedAt.getTime() + MS_TO_WAIT_FOR_NEW_ANNOUNCEMENTS\n                ).toISOString()\n            );\n\n    if (announcementsError && announcementsError.code !== 'PGRST116') {\n        throw announcementsError;\n    }\n\n    return announcementsData || [];\n}"
      },
      {
        "name": "updateAnnouncementReceipt",
        "kind": "function",
        "signature": "export async function updateAnnouncementReceipt(\n    announcementReceipt: AnnoucementReciept\n): Promise<void> {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('announcement_receipts')\n        .upsert(announcementReceipt, { onConflict: 'user_id' });\n\n    if (error) {\n        throw error;\n    }\n}"
      },
      {
        "name": "addImageUrlsToAnnouncements",
        "kind": "function",
        "signature": "export async function addImageUrlsToAnnouncements(\n    announcements: Announcement[]\n): Promise<Announcement[]> {\n    const supabase = createSupabaseServiceClient();\n\n    return announcements.map((announcement) => {\n        if (!announcement.image_path) {\n            return { ...announcement, image_url: '' };\n        }\n\n        const { data } = supabase.storage\n            .from('bioverse-images')\n            .getPublicUrl(announcement.image_path);\n\n        const imageUrl = data?.publicUrl || '';\n        return { ...announcement, image_url: imageUrl };\n    });\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/provider/announcements.ts",
      "bioverse-client/app/components/admin/announcements/announcements-container.tsx",
      "bioverse-client/app/components/admin/announcements/announcement-history.tsx",
      "bioverse-client/app/components/provider-portal/welcome/ProviderAnnouncements.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/provider/auth.ts",
    "exports": [
      {
        "name": "completeProviderSignup",
        "kind": "variable",
        "signature": "completeProviderSignup = async () => {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: activeSession } = await supabase.auth.getSession();\n    if (!activeSession.session)\n        return {\n            error: 'Something went wrong. The user has not been successfully signed up and logged in',\n            data: null,\n        };\n    const providerId = activeSession.session.user.id;\n\n    // update profile role\n    const { data: profilesData, error: profilesError } = await supabase\n        .from('profiles')\n        .update({ authorization: 'provider' })\n        .eq('id', providerId);\n    if (profilesError) return { error: profilesError.message, data: null };\n\n    // add record to providers table\n    const { data: providersData, error: providersError } = await supabase\n        .from('providers')\n        .insert({\n            id: providerId,\n            // other signup data\n        });\n    if (providersError) return { error: providersError.message, data: null };\n\n    return {\n        data: {\n            profilesData,\n            providersData,\n        },\n    };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/provider/auth.ts",
      "bioverse-client/app/(employee)/(provider-portal)/provider-auth/signup/page.tsx",
      "bioverse-client/app/components/login/forms/v2/sign-up-form-v2.tsx",
      "bioverse-client/app/components/login/forms/signUpForm.tsx",
      "bioverse-client/app/components/login/login-drawer/drawer-specific-forms/sign-up-form-drawer.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/provider/check-for-renewal-order.ts",
    "exports": [
      {
        "name": "checkForRenewalOrder",
        "kind": "function",
        "signature": "export async function checkForRenewalOrder(renewal_order_id: string) {\n\n    const supabase = createSupabaseServiceClient();\n    const { data: subscriptionData, error: patientDataFetchError } = await supabase\n        .from('renewal_orders')\n        .select(\n            `\n            id,\n            assigned_pharmacy,\n            variant_index,\n            dosage_suggestion_variant_indexes,\n            dosage_selection_completed,\n            order_status\n            `\n        )\n        .eq('renewal_order_id', renewal_order_id)\n        .single();\n    if (patientDataFetchError) {\n        console.log('Renewal Order TS: ', patientDataFetchError.message);\n        return { data: null, error: patientDataFetchError };\n    }\n    return { data: subscriptionData, error: null };\n\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/provider/check-for-renewal-order.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/CoordinatorConfirmDosage.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/provider/dashboard-scripts.ts",
    "exports": [
      {
        "name": "getProviderDashboardTasks",
        "kind": "function",
        "signature": "export async function getProviderDashboardTasks(user_id: string) {\n    const licensed_states = await getProviderLicensedStatesWithID(user_id);\n\n    const { data: orders, error: orders_error } =\n        await getAllOrdersForTaskQueue(licensed_states ?? []);\n\n    const { data: renewalOrders, error: renewalOrdersError } =\n        await getAllRenewalOrdersForTaskQueue(licensed_states ?? []);\n\n    const provider_messages = await getProviderMessageStatusTags(\n        licensed_states ?? []\n    );\n\n    const ordersMapped = mapOriginalOrdersToPatientDetails(orders);\n    const renewalOrdersMapped = mapRenewalOrdersToPatientDetails(renewalOrders);\n\n    return {\n        orders: ordersMapped,\n        renewalOrders: renewalOrdersMapped,\n        combined: concat(provider_messages, renewalOrdersMapped, ordersMapped),\n        provider_messages: provider_messages,\n    };\n}"
      },
      {
        "name": "ProviderDashboardFetchV1",
        "kind": "function",
        "signature": "export async function ProviderDashboardFetchV1() {\n    const { data: completeOrderData, error: orderError } =\n        await getAllOrdersForProviderOrderTablev2();\n\n    // const { data: leadProviderOrderData, error: leadProviderError } =\n    //     await getLeadProviderOrders();\n\n    const renewalOrderData = await getAllRenewalOrdersForProviderOrderTablev2();\n\n    if (!completeOrderData && orderError) {\n        console.error(\n            'Order Fetching for general orders failed. error message: ',\n            orderError.message\n        );\n    }\n    const generalOrders = prescriptionRequestToProviderDashboardv2(\n        completeOrderData ?? []\n    );\n\n    // const leadProviderOrders = prescriptionRequestToProviderDashboardv2(\n    //     leadProviderOrderData ?? []\n    // );\n\n    const renewalOrders = renewalOrderToProviderDashboard(renewalOrderData);\n\n    const mergedOrders = concat(renewalOrders, generalOrders);\n\n    const licensed_states = await getProviderLicensedStates();\n\n    const stateFilteredOrders = mergedOrders.filter((order) => {\n        if (!order.deliveryState) {\n            return true;\n        }\n        return licensed_states?.includes(order.deliveryState as USStates);\n    });\n\n    return {\n        generalOrders: stateFilteredOrders,\n        // leadProviderOrders: leadProviderOrders,\n    };\n}"
      },
      {
        "name": "getLeadProviderOrderStatusTags",
        "kind": "function",
        "signature": "export async function getLeadProviderOrderStatusTags() {\n    const { data, status } = await getStatusTags(\n        100,\n        StatusTag.LeadProvider,\n        null,\n        'prod'\n    );\n\n    return data;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/provider/dashboard-scripts.ts",
      "bioverse-client/app/components/provider-portal/order-table/components/provider-dashboard-table.tsx",
      "bioverse-client/_deprecated/clinical-intake-flow/order-table/components/order-table-provider.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/provider/get-suggested-dosages.ts",
    "exports": [
      {
        "name": "getSuggestedDosages",
        "kind": "function",
        "signature": "export async function getSuggestedDosages(productHref: string, suggestedDosageIndices: Number[]) {\n\n    const supabase = createSupabaseServiceClient();\n    const { data: dosageData, error: patientDataFetchError } = await supabase\n        .from('product_variants')\n        .select(\n            `\n            id,\n            vial,\n            cadence,\n            vial_dosages,\n            dosages,\n            pharmacy,\n            variant_index,\n            price_data\n            `\n        )\n        .eq('product_href', productHref)\n        .in('variant_index', suggestedDosageIndices)\n\n\n    if (patientDataFetchError) {\n        console.log('Suggested Dosages TS: ', patientDataFetchError.message);\n        return { data: null, error: patientDataFetchError };\n    }\n    return { data: dosageData, error: null };\n\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/provider/get-suggested-dosages.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/CoordinatorConfirmDosage.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/provider/parsers.ts",
    "exports": [
      {
        "name": "prescriptionRequestToProviderDashboard",
        "kind": "variable",
        "signature": "prescriptionRequestToProviderDashboard = (\n    res: any[]\n): PatientOrderProviderDetails[] =>\n    res.map((orderItem) => ({\n        id: orderItem.id,\n        patientId: orderItem.customer_uid,\n        patientName: `${orderItem.first_name} ${orderItem.last_name}`,\n        requestSubmissionTime: orderItem.created_at,\n        deliveryState: orderItem.state,\n        prescription: orderItem.name + ', ' + orderItem.variant_text,\n        approvalStatus: orderItem.order_status,\n        licensePhotoUrl: orderItem.license_photo_url ?? '',\n        selfiePhotoUrl: orderItem.selfie_photo_url ?? '',\n        statusTag: orderItem.statusTag,\n        vial_dosages: orderItem.vial_dosages,\n        productName: orderItem.name,\n        variant: orderItem.variant,\n        subscriptionType: orderItem.subscription_type,\n        status_tag_id: orderItem.status_tag_id,\n    }))"
      },
      {
        "name": "prescriptionRequestToProviderDashboardv2",
        "kind": "variable",
        "signature": "prescriptionRequestToProviderDashboardv2 = (\n    res: any[]\n): PatientOrderProviderDetails[] =>\n    res.map((orderItem) => {\n        return {\n            id: orderItem.order_id,\n            patientId: orderItem.customer_uid,\n            patientName: `${orderItem.first_name} ${orderItem.last_name}`,\n            requestSubmissionTime: orderItem.created_at,\n            deliveryState: orderItem.state,\n            prescription: orderItem.name + ', ' + orderItem.variant_text,\n            approvalStatus: orderItem.order_status,\n            licensePhotoUrl: orderItem.license_photo_url ?? '',\n            selfiePhotoUrl: orderItem.selfie_photo_url ?? '',\n            statusTag: orderItem.status_tag,\n            statusTags: orderItem.status_tags,\n            vial_dosages: orderItem.vial_dosages,\n            productName: orderItem.name,\n            variant: orderItem.variant,\n            subscriptionType: orderItem.subscription_type,\n            status_tag_id: orderItem.status_tag_id,\n        };\n    })"
      },
      {
        "name": "renewalOrderToProviderDashboard",
        "kind": "variable",
        "signature": "renewalOrderToProviderDashboard = (\n    renewalOrders: RenewalOrderProviderOverview[]\n): PatientOrderProviderDetails[] => {\n    return renewalOrders.map((renewalOrder: RenewalOrderProviderOverview) => ({\n        id: renewalOrder.renewal_order_id,\n        patientId: renewalOrder.id,\n        patientName: `${renewalOrder.first_name} ${renewalOrder.last_name}`,\n        requestSubmissionTime: renewalOrder.submission_time,\n        deliveryState: renewalOrder.state,\n        prescription: `${renewalOrder.name}, ${renewalOrder.variant_text}`,\n        approvalStatus: renewalOrder.order_status,\n        licensePhotoUrl: renewalOrder.license_photo_url ?? '',\n        selfiePhotoUrl: renewalOrder.selfie_photo_url ?? '',\n        statusTag: renewalOrder.status_tag,\n        statusTags: renewalOrder.status_tags,\n        vial_dosages: renewalOrder.vial_dosages ?? undefined,\n        productName: renewalOrder.name,\n        variant: renewalOrder.variant,\n        subscriptionType: renewalOrder.subscription_type,\n        status_tag_id: renewalOrder.status_tag_id,\n    }));\n}"
      },
      {
        "name": "generalIntakeToProviderDisplay",
        "kind": "variable",
        "signature": "generalIntakeToProviderDisplay = (res: any): IntakeData[] =>\n    res\n        ? Object.entries(res).map(([_, [v]]: [any, any]) => ({\n              question: v.question,\n              answer: v.answer,\n          }))\n        : []"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/provider/dashboard-scripts.ts",
      "bioverse-client/app/utils/actions/provider/parsers.ts",
      "bioverse-client/app/components/provider-portal/order-table/utils/assigned-order-fetch-helper.ts",
      "bioverse-client/_deprecated/clinical-intake-flow/order-table/utils/assigned-order-fetch-helper.ts",
      "bioverse-client/app/utils/actions/admin/dashboard-scripts.ts",
      "bioverse-client/app/utils/actions/admin/parsers.ts",
      "bioverse-client/app/(administration)/admin/order-administration/_components/admin-parser.ts",
      "bioverse-client/_deprecated/clinical-intake-flow/clinical-intake-flow.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/provider/patient-intake.ts",
    "exports": [
      {
        "name": "getGeneralPatientIntakeData",
        "kind": "function",
        "signature": "export async function getGeneralPatientIntakeData(patientId: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('profiles')\n        .select('first_name, last_name')\n        .eq('id', patientId)\n        .single();\n    if (error) return { error: error, data: null };\n\n    return { data: data, error: null };\n}"
      },
      {
        "name": "getGeneralPatientIntakeDataOld",
        "kind": "variable",
        "signature": "getGeneralPatientIntakeDataOld = async (patientId: string) => {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('profiles')\n        .select('first_name, last_name')\n        .eq('id', patientId)\n        .single();\n    if (error) return { error: error.message, data: null };\n\n    return { data };\n}"
      },
      {
        "name": "updatePatientDoseSpotPatientId",
        "kind": "function",
        "signature": "export async function updatePatientDoseSpotPatientId(\n    userId: string,\n    doseSpotId: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('profiles')\n        .update({\n            dose_spot_id: doseSpotId,\n            personal_data_recently_changed: false,\n        })\n        .eq('id', userId)\n        .select();\n\n    if (error) {\n        console.log(\n            'Error updating doseSpot ID for patient ',\n            error.message,\n            ` ID attempted: ${doseSpotId}`\n        );\n        return { data: null, error: error };\n    }\n    return { data: data, error: error };\n}"
      },
      {
        "name": "updatePatientUpdateStatus",
        "kind": "function",
        "signature": "export async function updatePatientUpdateStatus(userId: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('profiles')\n        .update({ personal_data_recently_changed: false })\n        .eq('id', userId);\n\n    if (error) {\n        console.log('Error updating doseSpot ID for patient ', error.message);\n        return { data: null, error: error };\n    }\n\n    return { data: data, error: error };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/provider/patient-intake.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/dosespot/dose-spot-buttons/patient-creation.tsx",
      "bioverse-client/_deprecated/clinical-intake-flow/approval-buttons/finalize-order-button.tsx",
      "bioverse-client/_deprecated/clinical-intake-flow/approval-buttons/dose-spot-update-patient-button.tsx",
      "bioverse-client/_deprecated/clinical-intake-flow/approval-buttons/dose-spot-patient-creation-button.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/dosespot/dose-spot-buttons/patient-update.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/provider/patient-overview.ts",
    "exports": [
      {
        "name": "getPatientInformationById",
        "kind": "function",
        "signature": "export async function getPatientInformationById(patientId: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: patientData, error: patientDataFetchError } = await supabase\n        .from('profiles')\n        .select(\n            `\n            id,\n            email,\n            first_name,\n            last_name,\n            created_at,\n            date_of_birth,\n            sex_at_birth,\n            address_line1,\n            address_line2,\n            city,\n            state,\n            zip,\n            phone_number,\n            created_at,\n            dose_spot_id,\n            license_photo_url,\n            selfie_photo_url,\n            personal_data_recently_changed,\n            subscriptions:prescription_subscriptions!patient_id (\n                product_href,\n                variant_text\n            )\n        `\n        )\n        .eq('id', patientId)\n        .single();\n\n    if (patientDataFetchError) {\n        console.log('Patient Overview TS: ', patientDataFetchError.message);\n        return { data: null, error: patientDataFetchError };\n    }\n\n    return { data: patientData, error: null };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(testing_and_development)/olivier-dev/utils.ts",
      "bioverse-client/app/utils/classes/Pharmacy.ts",
      "bioverse-client/app/utils/classes/Scripts/BaseScriptHandler.ts",
      "bioverse-client/app/utils/actions/provider/patient-overview.ts",
      "bioverse-client/app/utils/actions/intake/order-util.ts",
      "bioverse-client/app/utils/actions/alternatives/weight-loss/alternative-weight-loss-actions.ts",
      "bioverse-client/app/utils/functions/pharmacy-helpers/bundle-to-single-vial-converter.ts",
      "bioverse-client/app/utils/functions/prescription-scripts/hallandale-approval-script-generator.ts",
      "bioverse-client/app/utils/functions/prescription-scripts/empower-approval-script-generator.ts",
      "bioverse-client/app/utils/functions/prescription-scripts/boothwyn-script-generator.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/StripeInvoicePaidJobHandler.ts",
      "bioverse-client/app/(employee)/(coordinator-portal)/coordinator/tasks/[taskId]/page.tsx",
      "bioverse-client/app/(employee)/(coordinator-portal)/coordinator/orders/[orderId]/page.tsx",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/utils/data-fetching/coordinator-thread-data-fetch.ts",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/utils/coordinator-task-data-fetch.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/CoordinatorConfirmDosage.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/utils/data-fetch/intake-view-datafetch.ts",
      "bioverse-client/app/api/renewal/autoship/route.ts",
      "bioverse-client/app/api/supabase/annual-glp1/route.ts",
      "bioverse-client/app/api/supabase/split-shipment-glp1/route.ts",
      "bioverse-client/app/(patient-portal)/dosage-selection/[product]/[variant_index]/page.tsx",
      "bioverse-client/app/(patient-portal)/dosage/first-time/[order_id]/[variant_index]/page.tsx",
      "bioverse-client/app/services/pharmacy-integration/revive/revive-patient-api.ts",
      "bioverse-client/_deprecated/patient-intakes/[orderId]/page.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/provider/prescription-requests.ts",
    "exports": [
      {
        "name": "getAllReviewableOrdersFromOrdersTable",
        "kind": "function",
        "signature": "export async function getAllReviewableOrdersFromOrdersTable() {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select(\n            `\n    *,\n    product:products!product_href (\n      name\n    ),\n    patient:profiles!customer_uid (\n      first_name,\n      last_name,\n      state\n    )\n    `,\n        )\n        .in('order_status', [\n            'Unapproved-NoCard',\n            'Unapproved-CardDown',\n            'Approved-NoCard',\n            'Approved-CardDown',\n            'Pending-Customer-Response',\n            'Denied-CardDown',\n            'Denied-NoCard',\n        ])\n        .order('created_at', { ascending: false });\n\n    if (error) return { error: error, data: null };\n\n    return { data: data, error: null };\n}"
      },
      {
        "name": "getAllPrescribableOrdersFromOrdersTable",
        "kind": "function",
        "signature": "export async function getAllPrescribableOrdersFromOrdersTable() {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select(\n            `\n    *,\n    product:products!product_href (\n      name\n    ),\n    patient:profiles!customer_uid (\n      first_name,\n      last_name,\n      state\n    )\n    `,\n        )\n        .in('order_status', [\n            'Payment-Completed',\n            'Denied-CardDown',\n            'Denied-NoCard',\n            'Pending-Customer-Response',\n            'Approved-NoCard',\n            'Approved-CardDown',\n            'Approved-NoCard-Finalized',\n            'Approved-CardDown-Finalized',\n        ])\n        .order('created_at', { ascending: false });\n\n    if (error) return { error: error.message, data: null };\n\n    return { data: data, error: null };\n}"
      },
      {
        "name": "getOrderByPatientId",
        "kind": "function",
        "signature": "export async function getOrderByPatientId(patientId: string) {\n    console.log(patientId);\n    const supabase = createSupabaseServerComponentClient();\n    const { data, error } = await supabase\n        .from('orders')\n        .select(\n            `\n      id,\n      created_at,\n      variant_text,\n      address_line1,\n      address_line2,\n      state,\n      zip,\n      city,\n      product_href,\n      product:products!product_href (\n        name\n      )\n    `,\n        )\n        .eq('customer_uid', patientId)\n        .eq('environment', process.env.NEXT_PUBLIC_ENVIRONMENT);\n\n    if (error) {\n        return { data: null, error: error };\n    }\n\n    return { data: data, error: null };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/provider/prescription-requests.ts",
      "bioverse-client/app/(testing_and_development)/olivier-dev/utils.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/provider/provider-dosespot.ts",
    "exports": [
      {
        "name": "getProviderNotificationCount",
        "kind": "function",
        "signature": "export async function getProviderNotificationCount() {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const doseSpotId = await getCurrentProviderDoseSpotId();\n\n    const { data: countData, error: countError } = await supabase\n        .from('dose_spot_provider_notifications')\n        .select('*')\n        .eq('clinician_id', doseSpotId)\n        .single();\n\n    if (countError) {\n        return { data: 0 };\n    }\n\n    const count =\n        countData.pending_prescription_count +\n        countData.transmission_error_count +\n        countData.refill_request_count +\n        countData.change_request_count;\n\n    return { data: count };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/provider/provider-dosespot.ts",
      "bioverse-client/app/components/provider-portal/nav-bar/dose-spot-notifications/dose-spot-notification-chip.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/provider/update-renewal-order-metadata.ts",
    "exports": [
      {
        "name": "updateRenewalOrderMetadata",
        "kind": "function",
        "signature": "export async function updateRenewalOrderMetadata(renewal_order_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('renewal_orders')\n        .update({\n            metadata: {\n                coordinatorDosageSelected: true,\n            }\n          })\n        .eq('renewal_order_id', renewal_order_id);\n\n    if (error) {\n        console.log('Error updating metadata: ', error.message);\n        return { data: null, error };\n    }\n\n    return { data, error: null };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(testing_and_development)/ben-dev/page.tsx",
      "bioverse-client/app/utils/database/controller/renewal_orders/renewal_orders.ts",
      "bioverse-client/app/utils/actions/provider/update-renewal-order-metadata.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/CoordinatorConfirmDosage.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/quarterly-final-review-dialog.tsx",
      "bioverse-client/app/api/revive/send-script/route.ts",
      "bioverse-client/app/api/hallandale/send-script/route.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/questionnaires/questionnaire-actions.ts",
    "exports": [
      {
        "name": "getNextQuestionForHersPersonalHistory",
        "kind": "function",
        "signature": "export async function getNextQuestionForHersPersonalHistory(\n    currentScreen: string,\n    conditions: string[]\n): Promise<{ next_question_id: string; skip_set: boolean }> {\n    type ConditionType = keyof typeof CONDITIONS_TO_QUESTION_ID;\n    const CONDITIONS_TO_QUESTION_ID = {\n        'Medullary thyroid cancer': '2332',\n        'Multiple endocrine neoplasia type-2': '2333',\n        Pancreatitis: '2334',\n        'Gastroparesis (delayed stomach emptying)': '2335',\n        'Diabetes type 2': '2336',\n        'Long QT syndrome': '2337',\n    };\n    var nextCondition: ConditionType;\n    if (currentScreen === 'base') {\n        nextCondition = conditions[0] as ConditionType;\n    } else {\n        const currentScreenIndex = conditions.indexOf(currentScreen) + 1;\n        if (\n            currentScreenIndex >= conditions.length ||\n            currentScreenIndex === 0\n        ) {\n            // Send to other medical conditions\n            return {\n                next_question_id: '2338',\n                skip_set: false,\n            };\n        } else {\n            nextCondition = conditions[currentScreenIndex] as ConditionType;\n        }\n    }\n    const next_question_id = CONDITIONS_TO_QUESTION_ID[nextCondition];\n\n    return {\n        next_question_id,\n        skip_set: false,\n    };\n}"
      },
      {
        "name": "getNextQuestionForHersPersonalHistoryMaster",
        "kind": "function",
        "signature": "export async function getNextQuestionForHersPersonalHistoryMaster(\n    user_id: string,\n    currentScreen: string\n) {\n    const questionData = await getQuestionAnswerWithQuestionID('2331', user_id);\n\n    if (questionData && questionData.answer) {\n        const needsMoreLogic = getCommonStringsSorted(\n            questionData.answer.answer.formData,\n            HERS_PERSONAL_HISTORY_REQUIRING_EXTRA_LOGIC\n        );\n\n        const nextQuestion = await getNextQuestionForHersPersonalHistory(\n            currentScreen,\n            needsMoreLogic\n        );\n\n        return nextQuestion;\n    }\n\n    // Push to other medical conditions\n    return {\n        next_question_id: '2338',\n        skip_set: false,\n    };\n}"
      },
      {
        "name": "getNextQuestionForHersLogic",
        "kind": "function",
        "signature": "export async function getNextQuestionForHersLogic(\n    currentScreen: string,\n    conditions: string[]\n): Promise<{ next_question_id: string; skip_set: boolean }> {\n    type ConditionType = keyof typeof CONDITIONS_TO_QUESTION_ID;\n    const CONDITIONS_TO_QUESTION_ID = {\n        'Hypertension (high blood pressure)': '2319',\n        'Heart attack': '2321',\n        'Heart disease (coronary artery disease)': '2321',\n        'Liver issues': '2322',\n        'Stroke, mini stroke, or TIA': '2324',\n        Cancer: '2325',\n        Glaucoma: '2328',\n    };\n    var nextCondition: ConditionType;\n    if (currentScreen === 'base') {\n        nextCondition = conditions[0] as ConditionType;\n    } else {\n        const currentScreenIndex = conditions.indexOf(currentScreen) + 1;\n        if (\n            currentScreenIndex >= conditions.length ||\n            currentScreenIndex === 0\n        ) {\n            // Send to other medical conditions\n            return {\n                next_question_id: '2330',\n                skip_set: false,\n            };\n        } else {\n            nextCondition = conditions[currentScreenIndex] as ConditionType;\n        }\n    }\n    const next_question_id = CONDITIONS_TO_QUESTION_ID[nextCondition];\n\n    return {\n        next_question_id,\n        skip_set: false,\n    };\n}"
      },
      {
        "name": "getNextQuestionForHersLogicMaster",
        "kind": "function",
        "signature": "export async function getNextQuestionForHersLogicMaster(\n    user_id: string,\n    currentScreen: string\n) {\n    const questionData = await getQuestionAnswerWithQuestionID('2318', user_id);\n\n    if (questionData && questionData.answer) {\n        const needsMoreLogic = getCommonStringsSorted(\n            questionData.answer.answer.formData,\n            HERS_CONDITIONS_REQUIRING_EXTRA_LOGIC\n        );\n\n        const nextQuestion = await getNextQuestionForHersLogic(\n            currentScreen,\n            needsMoreLogic\n        );\n\n        return nextQuestion;\n    }\n\n    // Push to other medical conditions\n    return {\n        next_question_id: '2330',\n        skip_set: false,\n    };\n}"
      },
      {
        "name": "getQuestionnaireVersion",
        "kind": "function",
        "signature": "export async function getQuestionnaireVersion(\n    product_href: string\n): Promise<number> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('products')\n        .select('current_question_set_version')\n        .eq('href', product_href)\n        .single();\n\n    if (error) {\n        return 1;\n    }\n\n    if (data && data.current_question_set_version) {\n        return data.current_question_set_version;\n    }\n\n    return 1;\n}"
      },
      {
        "name": "shouldCreateCheckupQuestionnaire",
        "kind": "function",
        "signature": "export async function shouldCreateCheckupQuestionnaire(\n    product_href: string,\n    version_number: number\n) {\n    try {\n        const supabase = createSupabaseServiceClient();\n\n        const questionnaire_name = `${product_href}-checkup-${version_number}`;\n\n        const { data: version_data, error: version_error } = await supabase\n            .from('products')\n            .select('checkup_questionnaire_set_version')\n            .eq('href', product_href)\n            .single();\n\n        if (version_error) {\n            console.error(version_error, version_error.message);\n            return null;\n        }\n\n        console.log(version_data);\n\n        const { data, error } = await supabase\n            .from('questionnaire_questionnaires')\n            .select('*')\n            .eq('product_name', questionnaire_name)\n            .eq(\n                'question_set_version',\n                version_data.checkup_questionnaire_set_version\n            )\n            .maybeSingle();\n\n        console.log('DATA', data);\n\n        if (error) {\n            console.error(\n                'Error fetching questionnaire for name',\n                questionnaire_name\n            );\n            return;\n        }\n\n        if (isEmpty(data) || !data) {\n            // Get questionnaire version\n\n            // Fetch highest id\n            const { data: idData, error } = await supabase\n                .from('questionnaire_questionnaires')\n                .select('id')\n                .order('id', { ascending: false })\n                .limit(1)\n                .single();\n\n            // Create questionnaire\n            const { data: createData, error: createError } = (await supabase\n                .from('questionnaire_questionnaires')\n                .insert({\n                    product_name: questionnaire_name,\n                    type: 'check_up',\n                    id: idData?.id + 1,\n                    question_set_version:\n                        version_data.checkup_questionnaire_set_version,\n                })\n                .select()\n                .single()) as {\n                data: Questionnaire | null;\n                error: Error | null;\n            };\n\n            if (createError || !createData || !createData.id) {\n                console.error(\n                    'Error creating questionnaire',\n                    error,\n                    createError,\n                    createData\n                );\n                return;\n            }\n\n            // Fetch highest id\n            const { data: questionIdData, error: questionIdError } =\n                await supabase\n                    .from('questionnaire_questions')\n                    .select('id')\n                    .order('id', { ascending: false })\n                    .limit(1)\n                    .single();\n\n            // Check whether the current medication is WL or non-WL\n\n            const isNonWL = NON_WL_PRODUCT_HREFS.includes(product_href);\n\n            // Create questions\n            let questions;\n            if (isNonWL) {\n                questions = await constructNonWeightlossCheckupQuestions(\n                    questionIdData?.id\n                );\n            } else {\n                questions = await constructWeightlossCheckupQuestions(\n                    questionIdData?.id\n                );\n            }\n\n            const { data: questionData, error: questionError } = await supabase\n                .from('questionnaire_questions')\n                .insert(questions)\n                .select();\n\n            if (questionError || !questionData) {\n                console.error('Error inserting questions', questionError);\n            }\n\n            // Create questionnaire junctions\n            const questionnaire_id = createData?.id;\n\n            const {\n                data: questionJunctionIdData,\n                error: questionIdJunctionError,\n            } = await supabase\n                .from('questionnaire_junction')\n                .select('id')\n                .order('id', { ascending: false })\n                .limit(1)\n                .single();\n\n            if (error || !questionJunctionIdData) {\n                console.error(\n                    'Error with questionnaire junction',\n                    questionJunctionIdData\n                );\n            }\n\n            const junctionData = await constructCheckupJunction(\n                questionData as Question[],\n                questionnaire_id,\n                questionJunctionIdData?.id + 1\n            );\n\n            const {\n                data: questionnaireJunctionData,\n                error: questionnaireJunctionError,\n            } = await supabase\n                .from('questionnaire_junction')\n                .insert(junctionData);\n\n            if (questionnaireJunctionError) {\n                console.error(\n                    'Error adding junction to table',\n                    questionnaireJunctionError\n                );\n            }\n            console.log('created questionnaire successfully');\n        } else {\n            console.log('Did not create questionnaire');\n        }\n    } catch (error) {\n        console.error(\n            'Error in shouldCreateCheckupQuestionnaire',\n            error,\n            product_href,\n            version_number\n        );\n    }\n    return true;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/questionnaires/questionnaire-actions.ts",
      "bioverse-client/app/components/intake-v2/questions/functions/questions-functions.ts",
      "bioverse-client/app/utils/database/controller/products/products.ts",
      "bioverse-client/app/components/intake-v3/pages/demographic-wl-v3.tsx",
      "bioverse-client/app/(patient-portal)/check-up/[product_href]/question/[question_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/check-up/[product_href]/page.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/questionnaires/questionnaire-question-constants.ts",
    "exports": [
      {
        "name": "constructWeightlossCheckupQuestions",
        "kind": "function",
        "signature": "export async function constructWeightlossCheckupQuestions(\n    last_question_id: number\n): Promise<Question[]> {\n    let counter = last_question_id + 1;\n    let weightlossQuestions = cloneDeep(\n        WEIGHTLOSS_CHECKUP_QUESTIONS_VERSION_THREE\n    );\n\n    for (\n        let i = 0;\n        i < WEIGHTLOSS_CHECKUP_QUESTIONS_VERSION_THREE.length;\n        i++\n    ) {\n        weightlossQuestions[i]['id'] = counter;\n\n        // FOR GLP-1 Checkup Weekly Dose\n        if (\n            weightlossQuestions[i].question.custom_name ===\n            'glp-checkup-weekly-dose'\n        ) {\n            weightlossQuestions[i].question.referenceQuestionId = counter - 1;\n        }\n\n        counter += 1;\n    }\n    return weightlossQuestions;\n}"
      },
      {
        "name": "constructNonWeightlossCheckupQuestions",
        "kind": "function",
        "signature": "export async function constructNonWeightlossCheckupQuestions(\n    last_question_id: number\n): Promise<Question[]> {\n    let counter = last_question_id + 1;\n    let questions = cloneDeep(NON_WL_CHECKUP_QUESTIONS);\n\n    for (let i = 0; i < NON_WL_CHECKUP_QUESTIONS.length; i++) {\n        questions[i]['id'] = counter;\n        counter += 1;\n    }\n\n    return questions;\n}"
      },
      {
        "name": "constructCheckupJunction",
        "kind": "function",
        "signature": "export async function constructCheckupJunction(\n    questions: Question[],\n    questionnaire_id: number,\n    last_question_id: number\n) {\n    let priority = 0;\n    let res = [];\n\n    for (let i = 0; i < questions.length; i++) {\n        res.push({\n            questionnaire_id,\n            priority,\n            question_id: questions[i]['id'],\n            id: last_question_id + i,\n        });\n        priority += 10;\n    }\n    return res;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/questionnaires/questionnaire-actions.ts",
      "bioverse-client/app/utils/actions/questionnaires/questionnaire-question-constants.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/questionnaires/weightloss-questions/weightloss-questions-v1.ts",
    "exports": [
      {
        "name": "WEIGHTLOSS_CHECKUP_QUESTIONS_VERSION_ONE",
        "kind": "variable",
        "signature": "WEIGHTLOSS_CHECKUP_QUESTIONS_VERSION_ONE: Question[] = [\n    {\n        question: {\n            type: 'input',\n            label: ['lbs.'],\n            question: 'What is your current weight?',\n            fieldCount: 1,\n            placeholder: [],\n        },\n    },\n    {\n        question: {\n            type: 'input',\n            question:\n                \"Please confirm which medication and dosage you're taking\",\n            fieldCount: 1,\n            placeholder: ['Tell us which medication and dosage you’re taking.'],\n            multiline: true,\n        },\n    },\n    {\n        question: {\n            type: 'logic',\n            steps: [\n                {\n                    step: 1,\n                    type: 'mcq',\n                    options: ['Yes', 'No'],\n                    question: 'Are you happy with your current dosage?',\n                    nextStepReq: 'No',\n                },\n                {\n                    step: 2,\n                    type: 'input',\n                    placeholder: 'Tell us more.',\n                },\n            ],\n            stepCount: 2,\n        },\n    },\n    {\n        question: {\n            type: 'logic',\n            steps: [\n                {\n                    step: 1,\n                    type: 'mcq',\n                    options: ['Yes', 'No'],\n                    question:\n                        'Would you like to continue with the same medication at a higher dosage?',\n                    nextStepReq: 'Yes',\n                },\n                {\n                    step: 2,\n                    type: 'input',\n                    placeholder: 'Tell us more.',\n                },\n            ],\n            stepCount: 2,\n        },\n    },\n    {\n        question: {\n            type: 'logic',\n            steps: [\n                {\n                    step: 1,\n                    type: 'mcq',\n                    options: ['No', 'Yes'],\n                    question:\n                        'Are you currently experiencing any side effects from your weight loss medication?',\n                    nextStepReq: 'Yes',\n                },\n                {\n                    step: 2,\n                    type: 'input',\n                    placeholder: 'Tell us more.',\n                },\n            ],\n            stepCount: 2,\n        },\n    },\n    {\n        question: {\n            type: 'input',\n            question:\n                'Tell us anything else you’d like your provider to know when refilling your medication.',\n            fieldCount: 1,\n            placeholder: ['Tell us more.'],\n            multiline: true,\n        },\n    },\n    {\n        question: {\n            type: 'checkbox',\n            options: [\n                'Yes, something has changed about my medical history',\n                'No, I don’t have any changes to report',\n            ],\n            question:\n                'Since the last time you reported your medical information, has there been any change in your medical history?',\n            placeholder: 'Please select an option.',\n            singleChoice: true,\n        },\n    },\n    {\n        question: {\n            type: 'input',\n            question:\n                'Please tell us what’s new with your health, including new medical conditions or diagnoses.',\n            fieldCount: 1,\n            placeholder: [\"Tell us what's new.\"],\n            multiline: true,\n        },\n    },\n    {\n        question: {\n            type: 'checkbox',\n            options: [\n                'Yes, I am taking a new medication',\n                'No, I don’t have any changes to report',\n            ],\n            question:\n                'Since the last time you reported your medical information, are you taking any new medications?',\n            placeholder: 'Please select an option.',\n            singleChoice: true,\n        },\n    },\n    {\n        question: {\n            type: 'input',\n            question: 'Please list any new medications you are taking.',\n            fieldCount: 1,\n            placeholder: ['Tell us the names and dosages.'],\n            multiline: true,\n        },\n    },\n]"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/questionnaires/weightloss-questions/weightloss-questions-v1.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/questionnaires/weightloss-questions/weightloss-questions-v2.ts",
    "exports": [
      {
        "name": "WEIGHTLOSS_CHECKUP_QUESTIONS_VERSION_TWO",
        "kind": "variable",
        "signature": "WEIGHTLOSS_CHECKUP_QUESTIONS_VERSION_TWO: Question[] = [\n    {\n        question: {\n            type: 'input',\n            label: ['lbs.'],\n            question: 'What is your current weight?',\n            fieldCount: 1,\n            placeholder: [],\n        },\n    },\n    {\n        question: {\n            type: 'checkbox',\n            other: true,\n            options: [\n                'Compounded Semaglutide',\n                'Compounded Tirzepatide',\n                'Wegovy® (Semaglutide)',\n                'Ozempic® (Semaglutide)',\n                'Mounjaro® (Tirzepatide)',\n            ],\n            question: \"Please confirm which medication you're taking\",\n            singleChoice: true,\n        },\n    },\n    {\n        question: {\n            type: 'checkbox',\n            options: ['1 week', '2 weeks', '3 weeks', '4 weeks'],\n            question: 'How many weeks have you been taking this dose?',\n            singleChoice: true,\n        },\n    },\n    {\n        question: {\n            type: 'custom',\n            question:\n                'What was the most recent weekly dose of [previous answer] you took?',\n            skippable: false,\n            custom_name: 'glp-checkup-weekly-dose',\n        },\n    },\n    {\n        question: {\n            type: 'logic',\n            steps: [\n                {\n                    step: 1,\n                    type: 'mcq',\n                    options: ['Yes', 'No'],\n                    question: 'Are you happy with your current dosage?',\n                    nextStepReq: 'No',\n                },\n                {\n                    step: 2,\n                    type: 'input',\n                    placeholder: 'Tell us more.',\n                },\n            ],\n            stepCount: 2,\n        },\n    },\n    {\n        question: {\n            type: 'logic',\n            steps: [\n                {\n                    step: 1,\n                    type: 'mcq',\n                    options: ['Yes', 'No'],\n                    question:\n                        'Would you like to continue with the same medication at a higher dosage?',\n                    nextStepReq: 'Yes',\n                },\n                {\n                    step: 2,\n                    type: 'input',\n                    placeholder: 'Tell us more.',\n                },\n            ],\n            stepCount: 2,\n        },\n    },\n    {\n        question: {\n            type: 'logic',\n            steps: [\n                {\n                    step: 1,\n                    type: 'mcq',\n                    options: ['No', 'Yes'],\n                    question:\n                        'Are you currently experiencing any side effects from your weight loss medication?',\n                    nextStepReq: 'Yes',\n                },\n                {\n                    step: 2,\n                    type: 'input',\n                    placeholder: 'Tell us more.',\n                },\n            ],\n            stepCount: 2,\n        },\n    },\n    {\n        question: {\n            type: 'input',\n            question:\n                'Tell us anything else you’d like your provider to know when refilling your medication.',\n            fieldCount: 1,\n            placeholder: ['Tell us more.'],\n            multiline: true,\n        },\n    },\n    {\n        question: {\n            type: 'checkbox',\n            options: [\n                'Yes, something has changed about my medical history',\n                'No, I don’t have any changes to report',\n            ],\n            question:\n                'Since the last time you reported your medical information, has there been any change in your medical history?',\n            placeholder: 'Please select an option.',\n            singleChoice: true,\n        },\n    },\n    {\n        question: {\n            type: 'input',\n            question:\n                'Please tell us what’s new with your health, including new medical conditions or diagnoses.',\n            fieldCount: 1,\n            placeholder: [\"Tell us what's new.\"],\n            multiline: true,\n        },\n    },\n    {\n        question: {\n            type: 'checkbox',\n            options: [\n                'Yes, I am taking a new medication',\n                'No, I don’t have any changes to report',\n            ],\n            question:\n                'Since the last time you reported your medical information, are you taking any new medications?',\n            placeholder: 'Please select an option.',\n            singleChoice: true,\n        },\n    },\n    {\n        question: {\n            type: 'input',\n            question: 'Please list any new medications you are taking.',\n            fieldCount: 1,\n            placeholder: ['Tell us the names and dosages.'],\n            multiline: true,\n        },\n    },\n]"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/questionnaires/weightloss-questions/weightloss-questions-v2.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/questionnaires/weightloss-questions/weightloss-questions-v3.ts",
    "exports": [
      {
        "name": "WEIGHTLOSS_CHECKUP_QUESTIONS_VERSION_THREE",
        "kind": "variable",
        "signature": "WEIGHTLOSS_CHECKUP_QUESTIONS_VERSION_THREE: Question[] = [\n    {\n        question: {\n            type: 'input',\n            label: ['lbs.'],\n            question: 'What is your current weight?',\n            fieldCount: 1,\n            placeholder: [],\n        },\n    },\n    {\n        question: {\n            type: 'checkbox',\n            other: true,\n            options: [\n                'Compounded Semaglutide',\n                'Compounded Tirzepatide',\n                'Wegovy® (Semaglutide)',\n                'Ozempic® (Semaglutide)',\n                'Mounjaro® (Tirzepatide)',\n            ],\n            question: \"Please confirm which medication you're taking\",\n            singleChoice: true,\n        },\n    },\n    {\n        question: {\n            type: 'custom',\n            question:\n                'What was the most recent weekly dose of [previous answer] you took?',\n            skippable: false,\n            custom_name: 'glp-checkup-weekly-dose',\n        },\n    },\n    {\n        question: {\n            type: 'checkbox',\n            options: ['1 week', '2 weeks', '3 weeks', '4 weeks'],\n            question: 'How many weeks have you been taking this dose?',\n            singleChoice: true,\n        },\n    },\n    {\n        question: {\n            type: 'logic',\n            steps: [\n                {\n                    step: 1,\n                    type: 'mcq',\n                    options: ['Yes', 'No'],\n                    question: 'Are you happy with your current dosage?',\n                    nextStepReq: 'No',\n                },\n                {\n                    step: 2,\n                    type: 'input',\n                    placeholder: 'Tell us more.',\n                },\n            ],\n            stepCount: 2,\n        },\n    },\n    {\n        question: {\n            type: 'logic',\n            subtitle: 'Most patients will increase their dosage at this point.',\n            steps: [\n                {\n                    step: 1,\n                    type: 'mcq',\n                    options: ['Yes', 'No'],\n                    question:\n                        'Would you like to continue with the same medication at a higher dosage?',\n                    nextStepReq: 'Yes',\n                },\n                {\n                    step: 2,\n                    type: 'input',\n                    placeholder: 'Tell us more.',\n                },\n            ],\n            stepCount: 2,\n        },\n    },\n    {\n        question: {\n            type: 'logic',\n            steps: [\n                {\n                    step: 1,\n                    type: 'mcq',\n                    options: ['No', 'Yes'],\n                    question:\n                        'Are you currently experiencing any side effects from your weight loss medication?',\n                    nextStepReq: 'Yes',\n                },\n                {\n                    step: 2,\n                    type: 'input',\n                    placeholder: 'Tell us more.',\n                },\n            ],\n            stepCount: 2,\n        },\n    },\n    {\n        question: {\n            type: 'custom',\n            question:\n                \"Tell us anything else you'd like your provider to know when refilling your medication.\",\n            custom_name: 'wl-checkin-anythingelse',\n            skippable: false,\n        },\n    },\n    {\n        question: {\n            type: 'logic',\n            steps: [\n                {\n                    step: 1,\n                    type: 'mcq',\n                    options: [\n                        \"No, I don't have any changes to report\",\n                        'Yes, something has changed about my medical history',\n                    ],\n                    question:\n                        'Are you currently experiencing any side effects from your weight loss medication?',\n                    nextStepReq:\n                        'Yes, something has changed about my medical history',\n                },\n                {\n                    step: 2,\n                    type: 'input',\n                    question:\n                        \"Please tell us what's new with your health, including new medical conditions or diagnoses.\",\n                },\n            ],\n            stepCount: 2,\n        },\n    },\n    {\n        question: {\n            type: 'logic',\n            steps: [\n                {\n                    step: 1,\n                    type: 'mcq',\n                    options: [\n                        \"No, I don't have any changes to report\",\n                        'Yes, I am taking a new medication',\n                    ],\n                    question:\n                        'Since last time you reported your medical information, are you taking any new medications?',\n                    nextStepReq: 'Yes, I am taking a new medication',\n                },\n                {\n                    step: 2,\n                    type: 'input',\n                    question: 'Please list any new medications you are taking.',\n                },\n            ],\n            stepCount: 2,\n        },\n    },\n]"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/questionnaires/weightloss-questions/weightloss-questions-v3.ts",
      "bioverse-client/app/utils/actions/questionnaires/questionnaire-question-constants.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/stripe/stripe-webhook-actions.ts",
    "exports": [
      {
        "name": "sendCheckInCustomerIOEvent",
        "kind": "function",
        "signature": "export async function sendCheckInCustomerIOEvent(\n    patient_id: string,\n    stripe_subscription_id: string,\n    product_href: string,\n) {\n    const subscription = await getStripeSubscription(stripe_subscription_id);\n\n    const renewalDate = new Date(subscription.current_period_end * 1000);\n\n    const formattedRenewalDate = `${(renewalDate.getMonth() + 1)\n        .toString()\n        .padStart(2, '0')}/${renewalDate\n        .getDate()\n        .toString()\n        .padStart(2, '0')}/${renewalDate.getFullYear()}`;\n\n    await logPatientAction(patient_id, PatientActionTask.CHECKIN_FORM_SENT, {\n        product_href,\n    });\n\n    await triggerEvent(patient_id, WL_CHECKIN, {\n        checkin_url: `https://app.gobioverse.com/check-up/${product_href}`,\n        order_date: formattedRenewalDate,\n    });\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/stripe/stripe-webhook-actions.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/subscriptions/components/subscription-accordion.tsx",
      "bioverse-client/app/api/stripe/webhook/invoice-paid/route.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/actions/subscriptions/subscription-actions.ts",
    "exports": [
      {
        "name": "createSubscriptionWithOrderDataDeprecated",
        "kind": "function",
        "signature": "export async function createSubscriptionWithOrderDataDeprecated(\n    orderData: Order,\n    providerId: string,\n    stripe_subscription_id: string\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { data: newlyCreatedSubscription, error: subscriptionCreationError } =\n        await supabase.from('prescription_subscriptions').insert([\n            {\n                patient_id: orderData.customer_uid,\n                provider_id: providerId,\n                last_updated: new Date(),\n                product_href: orderData.product_href,\n                next_refill_date: null,\n                variant_text: orderData.variant_text,\n                subscription_type: orderData.subscription_type,\n                order_id: orderData.orderId,\n                stripe_subscription_id: stripe_subscription_id,\n            },\n        ]);\n\n    if (subscriptionCreationError) {\n        console.log(\n            'subscription-actions.ts - subscription creation error. Message: ' +\n                subscriptionCreationError.message\n        );\n    }\n}"
      },
      {
        "name": "getScriptDetails",
        "kind": "function",
        "signature": "export async function getScriptDetails(subscriptionId: number) {\n    const supabase = await createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('prescription_subscriptions')\n        .select('last_used_script')\n        .eq('id', subscriptionId)\n        .single();\n\n    if (error) {\n        console.error(\n            'Getting Script Details Error for Subscription',\n            subscriptionId\n        );\n        return null;\n    }\n    return data.last_used_script;\n}"
      },
      {
        "name": "getSubscriptionDetails",
        "kind": "function",
        "signature": "export async function getSubscriptionDetails(\n    subscriptionId: number\n): Promise<SubscriptionDetailsResponse> {\n    const supabase = await createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .rpc('get_subscription_details', {\n            subscription_id_: subscriptionId,\n        })\n        .single();\n\n    if (error) {\n        console.error(\n            'Getting Subscription Details Error for Subscription',\n            subscriptionId\n        );\n        console.error(error);\n        return {\n            status: Status.Failure,\n            data: {\n                name: '',\n                href: '',\n                variant: '',\n                image_ref: [],\n                address_line1: '',\n                address_line2: '',\n                state: '',\n                city: '',\n                zip: '',\n                stripe_subscription_id: '',\n                subscription_type: '',\n                image_ref_transparent: [],\n                order_id: -1,\n                renewal_count: -1,\n                created_at: '',\n                status: SubscriptionStatus.Canceled,\n                recent_variants: [],\n            },\n        };\n    }\n    return {\n        status: Status.Success,\n        data,\n    } as SubscriptionDetailsResponse;\n}"
      },
      {
        "name": "updatePrescriptionSubscription",
        "kind": "function",
        "signature": "export async function updatePrescriptionSubscription(\n    subscription_id: number,\n    updated_payload: Partial<PrescriptionSubscription>\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('prescription_subscriptions')\n        .update(updated_payload)\n        .eq('id', subscription_id);\n\n    if (error) {\n        console.error(\n            'Error updating renewal order order_status',\n            error,\n            updated_payload\n        );\n    }\n}"
      },
      {
        "name": "getPrescriptionSubscription",
        "kind": "function",
        "signature": "export async function getPrescriptionSubscription(\n    subscription_id: number\n): Promise<PrescriptionSubscription | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('prescription_subscriptions')\n        .select('*')\n        .eq('id', subscription_id)\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            'Error doesCustomerHaveOrderWithProduct',\n            error,\n            subscription_id\n        );\n        return null;\n    }\n\n    if (!data) {\n        console.error('Could not fetch subscription for user', subscription_id);\n        return null;\n    }\n\n    return data as PrescriptionSubscription;\n}"
      },
      {
        "name": "getLastVariantIndexForSubscription",
        "kind": "function",
        "signature": "export async function getLastVariantIndexForSubscription(\n    subscription_id: number\n) {\n    const subscription = await getPrescriptionSubscription(subscription_id);\n\n    if (!subscription) {\n        console.error('Could not find stripe subscription', subscription_id);\n        return null;\n    }\n\n    const x = getRenewalOrderBySubscriptionId;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/subscriptions/subscription-actions.ts",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/cancel-flow/[subscription_id]/feedback/[question_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/manage/[subscription_id]/page.tsx",
      "bioverse-client/app/(testing_and_development)/ben-dev/page.tsx",
      "bioverse-client/app/(testing_and_development)/olivier-dev/utils.ts",
      "bioverse-client/app/(administration)/admin/stripe-api/stripe-api-actions.ts",
      "bioverse-client/app/utils/database/controller/prescription_subscriptions/prescription_subscriptions.ts",
      "bioverse-client/app/utils/actions/intake/order-util.ts",
      "bioverse-client/app/api/customerio/webhook/route.ts",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/refill/[subscription_id]/confirm/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/refill/[subscription_id]/feedback/[question_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/refill/[subscription_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/resume/[subscription_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/cancel-flow/[subscription_id]/cancel/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/cancel-flow/[subscription_id]/information/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/cancel-flow/[subscription_id]/confirm/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/cancel-flow/[subscription_id]/change-refill/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/[subscription_id]/page.tsx",
      "bioverse-client/app/utils/database/controller/orders/create-order.ts",
      "bioverse-client/app/utils/database/controller/orders/process-manual-order.ts",
      "bioverse-client/app/utils/classes/Scripts/BoothwynScriptHandler.ts",
      "bioverse-client/app/utils/classes/Scripts/EmpowerScriptHandler.ts",
      "bioverse-client/app/utils/classes/Scripts/ReviveScriptHandler.ts",
      "bioverse-client/app/utils/classes/Scripts/HallandaleScriptHandler.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/StripeInvoicePaidJobHandler.ts",
      "bioverse-client/app/api/stripe/webhook/invoice-paid/route.ts",
      "bioverse-client/app/services/pharmacy-integration/util/utils.ts",
      "bioverse-client/app/(testing_and_development)/olivier-dev/page.tsx",
      "bioverse-client/app/(testing_and_development)/dev/send-script/components/ConvertBundleToMonthly.tsx",
      "bioverse-client/app/(testing_and_development)/dev/send-script/helpers.tsx",
      "bioverse-client/app/utils/database/controller/renewal_orders/renewal_orders.ts",
      "bioverse-client/app/utils/database/controller/messaging/messages/messages.ts",
      "bioverse-client/app/utils/classes/CommsScheduler/CommsSchedule.ts",
      "bioverse-client/app/utils/classes/CommsScheduler/MonthlyCheckInComms.ts",
      "bioverse-client/app/utils/classes/CommsScheduler/ThreeMonthCheckInComms.ts",
      "bioverse-client/app/utils/classes/Dashboard.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/IDAndSelfieCheckJobHandler.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/SendPrescriptionJobHandler.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/RenewalValidationJobHandler.ts",
      "bioverse-client/app/utils/functions/jobs/jobs.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/resend-script-confirmation.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/utils/intake-helpers.ts",
      "bioverse-client/app/services/stripe/subscriptions.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/classes/CommsScheduler/AnnuallyCheckInComms.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/classes/CommsScheduler/BiannuallyCheckInComms.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/classes/CommsScheduler/CommsSchedule.ts",
    "exports": [
      {
        "name": "MONTHLY_COMMS_FINAL_STEP_ID",
        "kind": "variable",
        "signature": "MONTHLY_COMMS_FINAL_STEP_ID = 1"
      },
      {
        "name": "QUARTERLY_COMMS_FINAL_STEP_ID",
        "kind": "variable",
        "signature": "QUARTERLY_COMMS_FINAL_STEP_ID = 5"
      },
      {
        "name": "BIANNUALLY_COMMS_FINAL_STEP_ID",
        "kind": "variable",
        "signature": "BIANNUALLY_COMMS_FINAL_STEP_ID = 11"
      },
      {
        "name": "ANNUALLY_COMMS_FINAL_STEP_ID",
        "kind": "variable",
        "signature": "ANNUALLY_COMMS_FINAL_STEP_ID = 23"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/classes/CommsScheduler/CommsSchedule.ts",
      "bioverse-client/app/utils/classes/CommsScheduler/MonthlyCheckInComms.ts",
      "bioverse-client/app/services/stripe/subscriptions.ts",
      "bioverse-client/app/utils/classes/CommsScheduler/ThreeMonthCheckInComms.ts",
      "bioverse-client/app/services/customerio/event_names.ts",
      "bioverse-client/app/utils/classes/CommsScheduler/BiannuallyCheckInComms.ts",
      "bioverse-client/app/utils/classes/CommsScheduler/AnnuallyCheckInComms.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/classes/CommsScheduler/MonthlyCheckInComms.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/classes/CommsScheduler/ThreeMonthCheckInComms.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/classes/Dashboard.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/classes/DosingChangeController/DosageChangeConstantIndex.ts",
    "exports": [
      {
        "name": "DOSING_SWAP_EQUIVALENCE_CONSTANTS",
        "kind": "variable",
        "signature": "DOSING_SWAP_EQUIVALENCE_CONSTANTS: DosingChangeEquivalenceOptionMetadata[] =\n    [\n        {\n            dosingEquivalence: DosageChangeEquivalenceCodes.SEMAGLUTIDE_0_25,\n            dosing: '0.25 mg weekly Semaglutide',\n            product_href: PRODUCT_HREF.SEMAGLUTIDE,\n            product_description: {\n                monthly: 'Semaglutide 0.25 mg dosing',\n                quarterly: 'Semaglutide 0.25mg, 0.5mg, 1.25mg dosing',\n                biannually: 'Semaglutide 0.25 mg x6 dosing',\n            },\n            sigs: {\n                monthly: [\n                    'Inject 50 units (0.25 mg of semaglutide)  subcutaneously once a week for four weeks',\n                ],\n                quarterly: [\n                    'Month 1 Inject 25 units (0.25 mg of semaglutide) subcutaneously once per week for weeks 1-4',\n                    'Month 2 Inject 50 units (0.5 mg of semaglutide) subcutaneously once per week for weeks 5-8',\n                    'Month 3 Inject 25 units (1.25 mg of semaglutide) subcutaneously once per week for weeks 9-12',\n                ],\n                biannually: [\n                    'Month 1-6: Inject 10 units (0.25 mg of semaglutide) subcutaneously once per week',\n                ],\n            },\n        },\n        {\n            dosingEquivalence: DosageChangeEquivalenceCodes.SEMAGLUTIDE_0_5,\n            dosing: '0.5 mg weekly Semaglutide',\n            product_href: PRODUCT_HREF.SEMAGLUTIDE,\n            product_description: {\n                monthly: 'Semaglutide 0.5 mg dosing',\n                quarterly: 'Semaglutide 0.5mg, 1.25mg, 2.5mg dosing',\n                biannually: 'Semaglutide 0.5 mg x6 dosing',\n            },\n            sigs: {\n                monthly: [\n                    'Inject 20 units (0.5 mg of semaglutide) subcutaneously once per week for 4 weeks',\n                ],\n                quarterly: [\n                    'Month 1 Inject 10 units (0.5 mg of semaglutide) subcutaneously once per week for weeks 1-4',\n                    'Month 2 Inject 20 units (0.5 mg of semaglutide) subcutaneously once per week for weeks 5-8',\n                    'Month 3 Inject 20 units (0.5 mg of semaglutide) subcutaneously once per week for weeks 9-12',\n                ],\n                biannually: [\n                    'Month 1-6:  Inject 20 units (0.5 mg of semaglutide) subcutaneously once per week',\n                ],\n            },\n        },\n        {\n            dosingEquivalence: DosageChangeEquivalenceCodes.SEMAGLUTIDE_1_25,\n            dosing: '1.25 mg weekly Semaglutide',\n            product_href: PRODUCT_HREF.SEMAGLUTIDE,\n            product_description: {\n                monthly: 'Semaglutide 1.25 mg dosing',\n                quarterly: 'Semaglutide 1.25 mg x3 dosing',\n                biannually:\n                    'Semaglutide 1.25 mg, 1.25 mg, 1.25 mg, 2.5 mg, 2.5 mg, 2.5 mg dosing',\n            },\n            sigs: {\n                monthly: [\n                    'Inject 50 units (1.25 mg of semaglutide) subcutaneously once per week for 4 weeks',\n                ],\n                quarterly: [\n                    'Months 1-3 Inject 25 units (1.25 mg of semaglutide) subcutaneously once per week for weeks 1-12 or as directed by your provider',\n                ],\n                biannually: [\n                    'Month 1-3: Inject 50 units (1.25 mg of semaglutide) subcutaneously once per week, ',\n                    'Month 3-6: Inject 100 units (2.5 mg of semaglutide) subcutaneously once per week for 12 weeks',\n                ],\n            },\n        },\n        {\n            dosingEquivalence: DosageChangeEquivalenceCodes.SEMAGLUTIDE_2_5,\n            dosing: '2.5 mg weekly Semaglutide',\n            product_href: PRODUCT_HREF.SEMAGLUTIDE,\n            product_description: {\n                monthly: 'Semaglutide 2.5 mg dosing',\n                quarterly: 'Semaglutide 2.5mg x3 dosing',\n            },\n            sigs: {\n                monthly: [\n                    'Inject 50 units (2.5 mg of semaglutide)  subcutaneously once a week for four weeks',\n                ],\n                quarterly: [\n                    'Months 1-3 Inject 50 units (2.5 mg of semaglutide) subcutaneously once per week for weeks 1-12 or as directed by your provider',\n                ],\n            },\n        },\n        {\n            dosing: '2.5 mg weekly Tirzepatide',\n            dosingEquivalence: DosageChangeEquivalenceCodes.TIRZEPATIDE_2_5,\n            product_href: PRODUCT_HREF.TIRZEPATIDE,\n            product_description: {\n                monthly: 'Tirzepatide 2.5 mg dosing',\n                quarterly: 'Tirzepatide 2.5 mg, 5 mg, 5 mg dosing',\n                biannually: 'Tirzepatide 2.5 mg x6 dosing',\n            },\n\n            sigs: {\n                monthly: [\n                    'Inject 31 units (2.5 mg of tirzepatide) subcutaneously once a week for four weeks',\n                ],\n                quarterly: [\n                    'Month 1 Inject 31 units (2.5 mg of tirzepatide) subcutaneously once per week for weeks 1-4 ',\n                    'Months 2 Inject 31 units ( 2.5 mg of tirzepatide) subcutaneously once per week for weeks 5-12 or check-in with your provider for further instructions',\n                    'Months 3 Inject 31 units ( 2.5 mg of tirzepatide) subcutaneously once per week for weeks 5-12 or check-in with your provider for further instructions',\n                ],\n                biannually: [\n                    'Month 1-6: Inject 25 units (2.5 mg of Tirzepatide) subcutaneously once per week',\n                ],\n            },\n        },\n        {\n            dosing: '5 mg weekly Tirzepatide',\n            dosingEquivalence: DosageChangeEquivalenceCodes.TIRZEPATIDE_5,\n            product_href: PRODUCT_HREF.TIRZEPATIDE,\n            product_description: {\n                monthly: 'Tirzepatide 5 mg dosing',\n                quarterly: 'Tirzepatide 5 mg x3 dosing',\n            },\n\n            sigs: {\n                monthly: [\n                    'Inject 62 units (5 mg of tirzepatide) subcutaneously once a week for four weeks',\n                ],\n                quarterly: [\n                    'Month 1 Inject 50 units (5 mg of tirzepatide) subcutaneously once per week for weeks 1-4 ',\n                    'Month 2 Inject 50 units (5 mg of tirzepatide) subcutaneously once per week for weeks 5-8 ',\n                    'Month 3 Inject 50 units (5 mg of tirzepatide) subcutaneously once per week for weeks 9-12',\n                ],\n            },\n        },\n        {\n            dosing: '7.5 mg weekly Tirzepatide',\n            dosingEquivalence: DosageChangeEquivalenceCodes.TIRZEPATIDE_7_5,\n            product_href: PRODUCT_HREF.TIRZEPATIDE,\n            product_description: {\n                monthly: 'Tirzepatide 7.5 mg dosing',\n                quarterly: 'Tirzepatide 7.5 x3 mg dosing',\n            },\n            sigs: {\n                monthly: [\n                    'Inject 44 units (7.5 mg of tirzepatide) subcutaneously once a week for four weeks',\n                ],\n                quarterly: [\n                    'Month 1 Inject 75 units (7.5 mg of tirzepatide) subcutaneously once per week for weeks 1-4 ',\n                    'Month 2 Inject 75 units (7.5 mg of tirzepatide) subcutaneously once per week for weeks 5-8 ',\n                    'Month 3 Inject 75 units (7.5 mg of tirzepatide) subcutaneously once per week for weeks 9-12',\n                ],\n            },\n        },\n        {\n            dosing: '10 mg weekly Tirzepatide',\n            dosingEquivalence: DosageChangeEquivalenceCodes.TIRZEPATIDE_10,\n            product_href: PRODUCT_HREF.TIRZEPATIDE,\n            product_description: {\n                monthly: 'Tirzepatide 10 mg dosing',\n                quarterly: 'Tirzepatide 10 mg x3 dosing',\n                biannually: 'Tirzepatide 10 mg x6 dosing',\n            },\n            sigs: {\n                monthly: [\n                    'Inject 100 units (10 mg of Tirzepatide) subcutaneously once per week for 4 weeks',\n                ],\n                quarterly: [\n                    'Month 1 Inject 100 units (10 mg of tirzepatide) subcutaneously once per week for weeks 1-4 ',\n                    'Month 2 Inject 100 units (10 mg of tirzepatide) subcutaneously once per week for weeks 5-8 ',\n                    'Month 3 Inject 100 units (10 mg of tirzepatide) subcutaneously once per week for weeks 9-12',\n                ],\n                biannually: [\n                    'Month 1-6: Inject 100 units (10 mg of Tirzepatide) subcutaneously once per week',\n                ],\n            },\n        },\n        {\n            dosing: '12.5 mg weekly Tirzepatide',\n            dosingEquivalence: DosageChangeEquivalenceCodes.TIRZEPATIDE_12_5,\n            product_href: PRODUCT_HREF.TIRZEPATIDE,\n            product_description: {\n                monthly: 'Tirzepatide 12.5 mg dosing',\n                quarterly: 'Tirzepatide 12.5 mg x3 dosing',\n            },\n            sigs: {\n                monthly: [\n                    'Inject 156 units (12.5 mg of tirzepatide) subcutaneously once a week for one week (week 1)',\n                ],\n                quarterly: [\n                    'Month 1 Inject 125 units (12.5 mg of tirzepatide) subcutaneously once per week for weeks 1-4 ',\n                    'Month 2 Inject 125 units (12.5 mg of tirzepatide) subcutaneously once per week for weeks 5-8 ',\n                    'Month 3 Inject 125 units (12.5 mg of tirzepatide) subcutaneously once per week for weeks 9-12',\n                ],\n            },\n        },\n    ]"
      },
      {
        "name": "getDosingOptionByDosageChangeEquivalenceCode",
        "kind": "function",
        "signature": "export function getDosingOptionByDosageChangeEquivalenceCode(\n    dosing: DosageChangeEquivalenceCodes\n): DosingChangeEquivalenceOptionMetadata | undefined {\n    return DOSING_SWAP_EQUIVALENCE_CONSTANTS.find(\n        (option) => option.dosingEquivalence === dosing\n    );\n}"
      },
      {
        "name": "dosageChangeMacroReplacementTextMap",
        "kind": "variable",
        "signature": "dosageChangeMacroReplacementTextMap: DosageChangeMacroReplacementMap =\n    {\n        [DosageChangeEquivalenceCodes.SEMAGLUTIDE_0_25]:\n            'I recommend to change your dose to semaglutide 0.25 mg. The price for a 1 month supply is $289 and for a 3 month supply including 0.25mg, 0.5mg, 1.25mg is $477.15. Finally the price for a 6 month supply is $834.00 including 0.25 mg dosing.',\n        [DosageChangeEquivalenceCodes.SEMAGLUTIDE_0_5]:\n            'I recommend to change your dose to semaglutide 0.5 mg. The price for a 1 month supply is $289 and for a 3 month supply including 0.5mg, 1.25mg and 2.5mg is $808.92. Finally the price for a 6 month supply is $1,494.00 including 0.5mg, 0.5mg, 1.25mg, 1.25mg, 2.5mg, 2.5mg dosing.',\n        [DosageChangeEquivalenceCodes.SEMAGLUTIDE_1_25]:\n            'I recommend to change your dose to semaglutide 1.25 mg. The price for a 1 month supply is $289 and for a 3 month supply including 1.25mg, 1.25mg, 1.25mg is $603.92. Finally the price for a 6 month supply is $1,674.00 including 1.25mg, 1.25mg, 1.25mg, 2.5mg, 2.5mg, 2.5mg dosing.',\n        [DosageChangeEquivalenceCodes.SEMAGLUTIDE_2_5]:\n            'I recommend to change your dose to semaglutide 2.5 mg. The price for a 1 month supply is $449 and for a 3 month supply including 2.5mg, 2.5mg, 2.5mg is $1024.92.',\n        [DosageChangeEquivalenceCodes.TIRZEPATIDE_2_5]:\n            'I recommend to change your dose to tirzepatide 2.5mg as part of your treatment plan. The price for a 1 month supply vial is $449 and for a 3 month supply including 2.5mg, 5mg and 5mg the price is $702.92. Finally the price for a 6 month supply is $1314 including 2.5 mg dosing.',\n        [DosageChangeEquivalenceCodes.TIRZEPATIDE_5]:\n            'I recommend to change your dose to tirzepatide 5mg as part of your treatment plan. The price for a 1 month supply vial is $449 and for a 3 month supply including 5mg, 7.5mg and 7.5mg the price is $1186.92.',\n        [DosageChangeEquivalenceCodes.TIRZEPATIDE_7_5]:\n            'I recommend to change your dose to tirzepatide 7.5mg as part of your treatment plan. The price for a 1 month supply is $529 and for a 3 month supply including 7.5mg, 7.5mg, 7.5mg the price is $1399.',\n        [DosageChangeEquivalenceCodes.TIRZEPATIDE_10]:\n            'I recommend to change your dose to tirzepatide 10mg as part of your treatment plan. The price for a 1 month supply is $799 and for a 3 month supply including 10mg, 10mg and 10mg the price is $1599. Finally the price for a 6 month supply is $3174 including 10 mg dosing.',\n        [DosageChangeEquivalenceCodes.TIRZEPATIDE_12_5]:\n            'I  recommend to change your dose to tirzepatide 12.5mg as part of your treatment plan. The price for a 1 month supply is $799 and for a 3 month supply including 12.5mg, 12.5mg and 12.5mg the price is $1999.',\n    }"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/classes/DosingChangeController/DosageChangeConstantIndex.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approve-and-prescribe-confirmation-details/dosage-change/dosage-change-component.tsx",
      "bioverse-client/app/(patient-portal)/dosage/first-time/[order_id]/page.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/classes/DosingChangeController/DosageChangeController.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/classes/DosingChangeController/DosageChangeEquivalenceMap.ts",
    "exports": [
      {
        "name": "DOSAGE_EQUIVALENCE_MAP",
        "kind": "variable",
        "signature": "DOSAGE_EQUIVALENCE_MAP: DosageChangeEquivalenceMap = {\n    [PRODUCT_HREF.SEMAGLUTIDE]: {\n        [DosageChangeEquivalenceCodes.SEMAGLUTIDE_0_25]: {\n            monthly: 2,\n            quarterly: 6,\n            biannually: 15,\n            annually: 37,\n        },\n        [DosageChangeEquivalenceCodes.SEMAGLUTIDE_0_5]: {\n            monthly: 3,\n            quarterly: 8,\n            biannually: 16,\n            annually: 39,\n        },\n        [DosageChangeEquivalenceCodes.SEMAGLUTIDE_1_25]: {\n            monthly: 4,\n            quarterly: 7,\n            biannually: 20,\n            annually: 41,\n        },\n        [DosageChangeEquivalenceCodes.SEMAGLUTIDE_2_5]: {\n            monthly: 5,\n            quarterly: 10,\n            //Biannual price for this concentration as 1st vial does not exist.\n        },\n    },\n    [PRODUCT_HREF.TIRZEPATIDE]: {\n        [DosageChangeEquivalenceCodes.TIRZEPATIDE_2_5]: {\n            monthly: 3,\n            quarterly: 6,\n            biannually: 24,\n            annually: 40,\n        },\n        [DosageChangeEquivalenceCodes.TIRZEPATIDE_5]: {\n            monthly: 4,\n            quarterly: 8,\n        },\n        [DosageChangeEquivalenceCodes.TIRZEPATIDE_7_5]: {\n            monthly: 5,\n            quarterly: 9,\n        },\n        [DosageChangeEquivalenceCodes.TIRZEPATIDE_10]: {\n            monthly: 10,\n            quarterly: 12,\n            biannually: 25,\n        },\n        [DosageChangeEquivalenceCodes.TIRZEPATIDE_12_5]: {\n            monthly: 11,\n            quarterly: 13,\n        },\n    },\n}"
      },
      {
        "name": "getDosageEquivalenceCodeFromVariantIndex",
        "kind": "function",
        "signature": "export function getDosageEquivalenceCodeFromVariantIndex(\n    productHref: PRODUCT_HREF,\n    variantIndex: number\n): DosageChangeEquivalenceCodes | undefined {\n    /**\n     * Within the switch, I am targeting variantIndex and if it matches a variant index case it will return the resultant equivalence code.\n     * For variant indices of cadencies greater than monthly:\n     * The first month's dosage corresponds to the equivalence it will provide.\n     */\n\n    // For Semaglutide\n    if (productHref === PRODUCT_HREF.SEMAGLUTIDE) {\n        switch (variantIndex) {\n            case 2:\n            case 6:\n            case 12:\n            case 15:\n            case 18:\n            case 22:\n            case 26:\n            case 33:\n            case 37:\n            case 38:\n            case 45:\n            case 49:\n            case 56:\n            case 60:\n            case 64:\n            case 65:\n            case 68:  \n            case 69:\n                return DosageChangeEquivalenceCodes.SEMAGLUTIDE_0_25;\n            case 3:\n            case 8:\n            case 11:\n            case 13:\n            case 16:\n            case 19:\n            case 23:\n            case 28:\n            case 32:\n            case 36:\n            case 39:\n            case 40:\n            case 46:\n            case 52:\n            case 55:\n            case 59:\n            case 61:\n            case 66:\n            case 67:\n            case 70:\n            case 71:\n                return DosageChangeEquivalenceCodes.SEMAGLUTIDE_0_5;\n            case 4:\n            case 7:\n            case 9: \n            case 14:\n            case 17:\n            case 20:\n            case 21:\n            case 24: \n            case 27:\n            case 29:\n            case 31:\n            case 34:\n            case 35:\n            case 41:\n            case 42:\n            case 43:\n            case 44:\n            case 47:\n            case 50:\n            case 51:\n            case 53:\n            case 57:\n            case 58:\n            case 62:\n            case 72:\n            case 73:\n                return DosageChangeEquivalenceCodes.SEMAGLUTIDE_1_25;\n            case 5:\n            case 9:\n            case 10:\n            case 25:\n            case 30:\n            case 44:\n            case 48:\n            case 54:\n            case 63:\n                return DosageChangeEquivalenceCodes.SEMAGLUTIDE_2_5;\n        }\n    }\n\n    // For Tirzepatide\n    if (productHref === PRODUCT_HREF.TIRZEPATIDE) {\n        switch (variantIndex) {\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 6:\n            case 14:\n            case 16:\n            case 24:\n            case 26:\n            case 27:\n            case 30:\n            case 35:\n            case 40:\n            case 41:\n            case 42:\n            case 47:\n            case 52:\n            case 57:\n            case 58:\n            case 59:\n            case 60: \n                return DosageChangeEquivalenceCodes.TIRZEPATIDE_2_5;\n            case 4:\n            case 7:\n            case 8:\n            case 17:\n            case 18:\n            case 19:\n            case 31:\n            case 36:\n            case 43:\n            case 48:\n            case 53:\n                return DosageChangeEquivalenceCodes.TIRZEPATIDE_5;\n            case 5:\n            case 8:\n            case 9:\n            case 20:\n            case 37:\n            case 32:\n            case 44:\n            case 49:\n            case 54:\n                return DosageChangeEquivalenceCodes.TIRZEPATIDE_7_5;\n            case 10:\n            case 12:\n            case 15:\n            case 21:\n            case 25:\n            case 28:\n            case 38:\n            case 33:\n            case 45:\n            case 50:\n            case 55:\n                return DosageChangeEquivalenceCodes.TIRZEPATIDE_10;\n            case 11:\n            case 13:\n            case 22:\n            case 23:\n            case 29:\n            case 39:\n            case 34:\n            case 46:\n            case 51:\n            case 56:\n                return DosageChangeEquivalenceCodes.TIRZEPATIDE_12_5;\n        }\n    }\n\n    return undefined;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/classes/DosingChangeController/DosageChangeEquivalenceMap.ts",
      "bioverse-client/app/utils/classes/DosingChangeController/DosageChangeController.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/RenewalValidationJobHandler.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/StripeInvoicePaidJobHandler.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/RenewalOrderTabRow.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/classes/DosingChangeController/DosageChangeModel.d.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/classes/Pharmacy.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/classes/ProductVariant/BestPharmacyMatrix.ts",
    "exports": [
      {
        "name": "findVariantPharmacyByState",
        "kind": "function",
        "signature": "export function findVariantPharmacyByState(\n    matrixMap: BestPharmacyMatrixMap,\n    equivalenceCode: string,\n    state: USStates\n): PharmacySearchResult {\n    // Default return value if no match is found\n    const defaultResult: PharmacySearchResult = {\n        variantIndex: -1,\n        pharmacy: '',\n        found: false,\n    };\n\n    // Check if equivalence code exists in matrix map\n    const stateSearches = matrixMap[equivalenceCode];\n    if (!stateSearches) {\n        return defaultResult;\n    }\n\n    // Find the first matching state entry\n    const matchingStateSearch = stateSearches.find(\n        (search: MatrixStateSearch) => search.allowedStates.includes(state)\n    );\n\n    if (!matchingStateSearch) {\n        return defaultResult;\n    }\n\n    // Return the found pharmacy information\n    return {\n        variantIndex: matchingStateSearch.variantPharmacy.variantIndex,\n        pharmacy: matchingStateSearch.variantPharmacy.pharmacy,\n        found: true,\n    };\n}"
      },
      {
        "name": "BEST_PHARMACY_MATRIX_MAP",
        "kind": "variable",
        "signature": "BEST_PHARMACY_MATRIX_MAP: BestPharmacyMatrixMap = {\n    /**\n     * SEMAGLUTIDE EQUIVALENCE MAPPINGS:\n     */\n\n    [EquivalenceCodes.SEMA1MO_0_25_MG]: [\n        {\n            allowedStates: [\n                USStates.California,\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.Michigan,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 45,\n                pharmacy: 'boothwyn',\n            },\n        },\n    ],\n\n    [EquivalenceCodes.SEMA2MO_0_5_MG]: [\n        {\n            allowedStates: [],\n            variantPharmacy: {\n                variantIndex: 55,\n                pharmacy: 'revive',\n            },\n        },\n        {\n            allowedStates: [USStates.California],\n            variantPharmacy: {\n                variantIndex: 46,\n                pharmacy: 'boothwyn',\n            },\n        },\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n                USStates.Michigan,\n            ],\n            variantPharmacy: {\n                variantIndex: 3,\n                pharmacy: 'empower',\n            },\n        },\n    ],\n\n    [EquivalenceCodes.SEMA3MO_1_25_MG]: [\n        //1.25 mg semaglutide\n        {\n            allowedStates: [\n                USStates.California,\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.Michigan,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 47,\n                pharmacy: 'boothwyn',\n            },\n        },\n    ],\n\n    [EquivalenceCodes.SEMA4MO_2_5_MG]: [\n        {\n            allowedStates: [\n                USStates.California,\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.Michigan,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 48,\n                pharmacy: 'boothwyn',\n            },\n        },\n    ],\n\n    [EquivalenceCodes.SEMA5QU]: [\n        //.25 .5 1.25\n        {\n            allowedStates: [USStates.California],\n            variantPharmacy: {\n                variantIndex: 49,\n                pharmacy: 'boothwyn',\n            },\n        },\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n                USStates.Michigan,\n            ],\n            variantPharmacy: {\n                variantIndex: 56,\n                pharmacy: PHARMACY.REVIVE,\n            },\n        },\n        {\n            allowedStates: [],\n            variantPharmacy: {\n                variantIndex: 6,\n                pharmacy: PHARMACY.EMPOWER,\n            },\n        },\n    ],\n\n    [EquivalenceCodes.SEMA6QU]: [\n        //1.25 1.25 1.25\n        {\n            allowedStates: [USStates.California],\n            variantPharmacy: {\n                variantIndex: 51,\n                pharmacy: PHARMACY.BOOTHWYN,\n            },\n        },\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.Michigan,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 57,\n                pharmacy: PHARMACY.REVIVE,\n            },\n        },\n    ],\n\n    [EquivalenceCodes.SEMA7QU]: [\n        //.5 1.25 2.5\n        {\n            allowedStates: [USStates.California],\n            variantPharmacy: {\n                variantIndex: 52,\n                pharmacy: PHARMACY.BOOTHWYN,\n            },\n        },\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.Michigan,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 59,\n                pharmacy: PHARMACY.REVIVE,\n            },\n        },\n    ],\n\n    [EquivalenceCodes.SEMA8QU]: [\n        //.5 .5 .5\n        {\n            allowedStates: [],\n            variantPharmacy: {\n                variantIndex: 12,\n                pharmacy: PHARMACY.HALLANDALE,\n            },\n        },\n    ],\n\n    [EquivalenceCodes.SEMA9QU]: [\n        //1.25 1.25 2.5\n        {\n            allowedStates: [USStates.California],\n            variantPharmacy: {\n                variantIndex: 51,\n                pharmacy: PHARMACY.BOOTHWYN,\n            },\n        },\n        {\n            allowedStates: [],\n            variantPharmacy: {\n                variantIndex: 43,\n                pharmacy: PHARMACY.HALLANDALE,\n            },\n        },\n        {\n            allowedStates: [],\n            variantPharmacy: {\n                variantIndex: 58,\n                pharmacy: PHARMACY.REVIVE,\n            },\n        },\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.Michigan,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n                USStates.Michigan,\n            ],\n            variantPharmacy: {\n                variantIndex: 21,\n                pharmacy: PHARMACY.EMPOWER,\n            },\n        },\n    ],\n\n    [EquivalenceCodes.SEMA10QU]: [\n        //1.25 2.5 2.5\n        // {\n        //     allowedStates: [USStates.California, USStates.Michigan],\n        //     variantPharmacy: {\n        //         variantIndex: 53,\n        //         pharmacy: PHARMACY.BOOTHWYN,\n        //     },\n        // },\n        // {\n        //     allowedStates: [\n        //         USStates.Colorado,\n        //         USStates.Florida,\n        //         USStates.Illinois,\n        //         USStates.Indiana,\n        //         USStates.NewJersey,\n        //         USStates.NorthCarolina,\n        //         USStates.Ohio,\n        //         USStates.Pennsylvania,\n        //         USStates.Texas,\n        //         USStates.Virginia,\n        //         USStates.Washington,\n        //     ],\n        //     variantPharmacy: {\n        //         variantIndex: 44,\n        //         pharmacy: PHARMACY.HALLANDALE,\n        //     },\n        // },\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n                USStates.Michigan,\n            ],\n            variantPharmacy: {\n                variantIndex: 9,\n                pharmacy: PHARMACY.EMPOWER,\n            },\n        },\n    ],\n\n    [EquivalenceCodes.SEMA11QU]: [\n        //2.5 2.5 2.5\n        {\n            allowedStates: [],\n            variantPharmacy: {\n                variantIndex: 54,\n                pharmacy: 'boothwyn',\n            },\n        },\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.Michigan,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 10,\n                pharmacy: PHARMACY.EMPOWER,\n            },\n        },\n    ],\n\n    [EquivalenceCodes.SEMA12BIAN]: [\n        //2.5 x 6 bian\n        {\n            allowedStates: [\n                // USStates.Colorado,\n                // USStates.Florida,\n                // USStates.Illinois,\n                // USStates.Indiana,\n                // USStates.NewJersey,\n                // USStates.NorthCarolina,\n                // USStates.Ohio,\n                // USStates.Pennsylvania,\n                // USStates.Texas,\n                // USStates.Virginia,\n                // USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 15,\n                pharmacy: 'hallandale',\n            },\n        },\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n                USStates.Michigan,\n            ],\n            variantPharmacy: {\n                variantIndex: 64,\n                pharmacy: PHARMACY.REVIVE,\n            },\n        },\n    ],\n\n    [EquivalenceCodes.SEMA13BIAN]: [\n        {\n            allowedStates: [\n                // USStates.Colorado,\n                // USStates.Florida,\n                // USStates.Illinois,\n                // USStates.Indiana,\n                // USStates.NewJersey,\n                // USStates.NorthCarolina,\n                // USStates.Ohio,\n                // USStates.Pennsylvania,\n                // USStates.Texas,\n                // USStates.Virginia,\n                // USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 16,\n                pharmacy: 'hallandale',\n            },\n        },\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n                USStates.Michigan,\n            ],\n            variantPharmacy: {\n                variantIndex: 66,\n                pharmacy: PHARMACY.REVIVE,\n            },\n        },\n    ],\n\n    [EquivalenceCodes.SEMA14BIAN]: [\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 17,\n                pharmacy: 'hallandale',\n            },\n        },\n    ],\n\n    [EquivalenceCodes.SEMA15BIAN]: [\n        {\n            allowedStates: [\n                // USStates.Colorado,\n                // USStates.Florida,\n                // USStates.Illinois,\n                // USStates.Indiana,\n                // USStates.NewJersey,\n                // USStates.NorthCarolina,\n                // USStates.Ohio,\n                // USStates.Pennsylvania,\n                // USStates.Texas,\n                // USStates.Virginia,\n                // USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 18,\n                pharmacy: 'hallandale',\n            },\n        },\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n                USStates.Michigan,\n            ],\n            variantPharmacy: {\n                variantIndex: 68,\n                pharmacy: PHARMACY.REVIVE,\n            },\n        },\n    ],\n\n    [EquivalenceCodes.SEMA16BIAN]: [\n        {\n            allowedStates: [\n                // USStates.Colorado,\n                // USStates.Florida,\n                // USStates.Illinois,\n                // USStates.Indiana,\n                // USStates.NewJersey,\n                // USStates.NorthCarolina,\n                // USStates.Ohio,\n                // USStates.Pennsylvania,\n                // USStates.Texas,\n                // USStates.Virginia,\n                // USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 19,\n                pharmacy: 'hallandale',\n            },\n        },\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n                USStates.Michigan,\n            ],\n            variantPharmacy: {\n                variantIndex: 70,\n                pharmacy: PHARMACY.REVIVE,\n            },\n        },\n    ],\n\n    [EquivalenceCodes.SEMA17BIAN]: [\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n                USStates.Michigan,\n            ],\n            variantPharmacy: {\n                variantIndex: 72,\n                pharmacy: PHARMACY.REVIVE,\n            },\n        },\n    ],\n\n    [EquivalenceCodes.SEMA18BIAN]: [\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n                USStates.Michigan,\n            ],\n            variantPharmacy: {\n                variantIndex: 74,\n                pharmacy: PHARMACY.REVIVE,\n            },\n        },\n    ],\n\n    [EquivalenceCodes.SEMA18ANN]: [\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 37,\n                pharmacy: 'hallandale',\n            },\n        },\n    ],\n\n    [EquivalenceCodes.SEMA19ANN]: [\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 39,\n                pharmacy: 'hallandale',\n            },\n        },\n    ],\n\n    [EquivalenceCodes.SEMA20ANN]: [\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 41,\n                pharmacy: 'hallandale',\n            },\n        },\n    ],\n\n    /**\n     * Tirzepatide\n     */\n    [EquivalenceCodes.TIRZ1MO]: [\n        //2.5 mg\n        {\n            allowedStates: [\n                USStates.California,\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.Michigan,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 42,\n                pharmacy: 'boothwyn',\n            },\n        },\n    ],\n\n    [EquivalenceCodes.TIRZ2MO]: [\n        //5 mg\n        {\n            allowedStates: [\n                USStates.California,\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.Michigan,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 43,\n                pharmacy: 'boothwyn',\n            },\n        },\n    ],\n\n    [EquivalenceCodes.TIRZ3MO]: [\n        //7.5 mg\n        {\n            allowedStates: [USStates.California],\n            variantPharmacy: {\n                variantIndex: 44,\n                pharmacy: PHARMACY.BOOTHWYN,\n            },\n        },\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.Michigan,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 5,\n                pharmacy: PHARMACY.EMPOWER,\n            },\n        },\n    ],\n\n    [EquivalenceCodes.TIRZ4MO]: [\n        //10 mg\n        {\n            allowedStates: [\n                USStates.California,\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.Michigan,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 45,\n                pharmacy: 'boothwyn',\n            },\n        },\n    ],\n\n    [EquivalenceCodes.TIRZ5MO]: [\n        //12.5 mg\n        {\n            allowedStates: [\n                USStates.California,\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.Michigan,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 46,\n                pharmacy: PHARMACY.BOOTHWYN,\n            },\n        },\n    ],\n\n    [EquivalenceCodes.TIRZ6QU]: [\n        //(2.5, 5, 5) MG Dosing Quarterly\n        {\n            allowedStates: [],\n            variantPharmacy: {\n                variantIndex: 35,\n                pharmacy: 'boothwyn',\n            },\n        },\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.Michigan,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 6,\n                pharmacy: PHARMACY.EMPOWER,\n            },\n        },\n    ],\n\n    /**\n     * Q 5-5-5 may be deprecated and not offered on site anymore.\n     */\n    [EquivalenceCodes.TIRZ7QU]: [\n        //(5, 5, 5) MG Dosing Quarterly\n        {\n            allowedStates: [],\n            variantPharmacy: {\n                variantIndex: 17,\n                pharmacy: 'hallandale',\n            },\n        },\n    ],\n\n    /**\n     * Q 5-5-7.5 may be deprecated and not offered on site anymore.\n     */\n    [EquivalenceCodes.TIRZ8QU]: [\n        //(5, 5, 7.5) MG Dosing Quarterly\n        {\n            allowedStates: [],\n            variantPharmacy: {\n                variantIndex: 19,\n                pharmacy: 'hallandale',\n            },\n        },\n    ],\n\n    [EquivalenceCodes.TIRZ9QU]: [\n        //(5, 7.5, 7.5) MG Dosing Quarterly\n        {\n            allowedStates: [],\n            variantPharmacy: {\n                variantIndex: 36,\n                pharmacy: PHARMACY.BOOTHWYN,\n            },\n        },\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.Michigan,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 8,\n                pharmacy: PHARMACY.EMPOWER,\n            },\n        },\n    ],\n\n    [EquivalenceCodes.TIRZ10QU]: [\n        //(7.5, 7.5, 7.5) MG Dosing Quarterly\n        {\n            allowedStates: [],\n            variantPharmacy: {\n                variantIndex: 37,\n                pharmacy: PHARMACY.BOOTHWYN,\n            },\n        },\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.Michigan,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 9,\n                pharmacy: PHARMACY.EMPOWER,\n            },\n        },\n    ],\n\n    [EquivalenceCodes.TIRZ11QU]: [\n        //(10, 10, 10) MG Dosing Quarterly\n        {\n            allowedStates: [],\n            variantPharmacy: {\n                variantIndex: 38,\n                pharmacy: PHARMACY.BOOTHWYN,\n            },\n        },\n        {\n            allowedStates: [\n                USStates.California,\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.Michigan,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 28,\n                pharmacy: PHARMACY.EMPOWER,\n            },\n        },\n    ],\n\n    [EquivalenceCodes.TIRZ12QU]: [\n        //(12.5, 12.5, 12.5) MG Dosing Quarterly\n        {\n            allowedStates: [],\n            variantPharmacy: {\n                variantIndex: 39,\n                pharmacy: PHARMACY.BOOTHWYN,\n            },\n        },\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.Michigan,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 29,\n                pharmacy: PHARMACY.EMPOWER,\n            },\n        },\n    ],\n\n    [EquivalenceCodes.TIRZ13BIAN]: [\n        {\n            allowedStates: [\n                // USStates.Colorado,\n                // USStates.Florida,\n                // USStates.Illinois,\n                // USStates.Indiana,\n                // USStates.NewJersey,\n                // USStates.NorthCarolina,\n                // USStates.Ohio,\n                // USStates.Pennsylvania,\n                // USStates.Texas,\n                // USStates.Virginia,\n                // USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 24,\n                pharmacy: 'hallandale',\n            },\n        },\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n                USStates.Michigan,\n            ],\n            variantPharmacy: {\n                variantIndex: 57,\n                pharmacy: PHARMACY.REVIVE,\n            },\n        },\n    ],\n\n    [EquivalenceCodes.TIRZ14BIAN]: [\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 25,\n                pharmacy: 'hallandale',\n            },\n        },\n    ],\n\n    [EquivalenceCodes.TIRZ15BIAN]: [\n        {\n            allowedStates: [\n                // USStates.Colorado,\n                // USStates.Florida,\n                // USStates.Illinois,\n                // USStates.Indiana,\n                // USStates.NewJersey,\n                // USStates.NorthCarolina,\n                // USStates.Ohio,\n                // USStates.Pennsylvania,\n                // USStates.Texas,\n                // USStates.Virginia,\n                // USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 27,\n                pharmacy: 'hallandale',\n            },\n        },\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n                USStates.Michigan,\n            ],\n            variantPharmacy: {\n                variantIndex: 59,\n                pharmacy: PHARMACY.REVIVE,\n            },\n        },\n    ],\n\n    [EquivalenceCodes.TIRZ16ANN]: [\n        {\n            allowedStates: [\n                USStates.Colorado,\n                USStates.Florida,\n                USStates.Illinois,\n                USStates.Indiana,\n                USStates.NewJersey,\n                USStates.NorthCarolina,\n                USStates.Ohio,\n                USStates.Pennsylvania,\n                USStates.Texas,\n                USStates.Virginia,\n                USStates.Washington,\n            ],\n            variantPharmacy: {\n                variantIndex: 40,\n                pharmacy: 'hallandale',\n            },\n        },\n    ],\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/classes/ProductVariant/ProductVariantController.ts",
      "bioverse-client/app/utils/classes/ProductVariant/BestPharmacyMatrix.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/classes/ProductVariant/ProductVarianceMap.ts",
    "exports": [
      {
        "name": "PRODUCT_VARIANCE_EQUIVALENCE_MAP",
        "kind": "variable",
        "signature": "PRODUCT_VARIANCE_EQUIVALENCE_MAP: ProductVariantEquivalenceMap = {\n    metformin: [\n        // Quarterly\n        {\n            variantIndices: [0],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.METFORMIN1QU,\n                productHref: PRODUCT_HREF.METFORMIN,\n                dosage: '1000 mg',\n                cadence: 'quarterly',\n                pharmacyMap: {\n                    curexa: 0,\n                },\n            },\n        },\n    ],\n    [PRODUCT_HREF.WL_CAPSULE]: [\n        // monthly\n        {\n            variantIndices: [0],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.CAPSULE1MO,\n                productHref: PRODUCT_HREF.WL_CAPSULE,\n                dosage: '',\n                cadence: 'monthly',\n                pharmacyMap: {\n                    empower: 0,\n                },\n            },\n        },\n        {\n            variantIndices: [1],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.CAPSULE2QU,\n                productHref: PRODUCT_HREF.WL_CAPSULE,\n                dosage: '',\n                cadence: 'quarterly',\n                pharmacyMap: {\n                    empower: 1,\n                },\n            },\n        },\n    ],\n    semaglutide: [\n        {\n            //0.25 MG Dosing Monthly\n            variantIndices: [0, 1, 2, 22, 45],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SEMA1MO_0_25_MG,\n                productHref: PRODUCT_HREF.SEMAGLUTIDE,\n                dosage: '0.25 mg',\n                cadence: 'monthly',\n                pharmacyMap: {\n                    empower: 2,\n                    boothwyn: 22,\n                },\n            },\n        },\n        {\n            //0.5 MG Dosing Monthly\n            variantIndices: [3, 13, 23, 32, 55, 46],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SEMA2MO_0_5_MG,\n                productHref: PRODUCT_HREF.SEMAGLUTIDE,\n                dosage: '0.5 mg',\n                cadence: 'monthly',\n                pharmacyMap: {\n                    empower: 3,\n                    hallandale: 13,\n                    boothwyn: 23,\n                    revive: 55,\n                },\n            },\n        },\n\n        {\n            //1.25 MG Dosing Monthly\n            variantIndices: [4, 14, 24, 47],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SEMA3MO_1_25_MG,\n                productHref: PRODUCT_HREF.SEMAGLUTIDE,\n                dosage: '1.25 mg',\n                cadence: 'monthly',\n                pharmacyMap: {\n                    empower: 4,\n                    boothwyn: 24,\n                },\n            },\n        },\n\n        {\n            //2.5 MG Dosing Monthly\n            variantIndices: [5, 25, 48],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SEMA4MO_2_5_MG,\n                productHref: PRODUCT_HREF.SEMAGLUTIDE,\n                dosage: '2.5 mg',\n                cadence: 'monthly',\n                pharmacyMap: {\n                    empower: 5,\n                    boothwyn: 25,\n                },\n            },\n        },\n\n        /**\n         * Quarterly Offers\n         */\n        {\n            //(.25 mg / .5 mg / 1.25 mg) MG Dosing Quarterly\n            variantIndices: [6, 11, 12, 26, 33, 56, 49],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SEMA5QU,\n                productHref: PRODUCT_HREF.SEMAGLUTIDE,\n                dosage: '(0.25, 0.5, 1.25) mg',\n                cadence: 'quarterly',\n                pharmacyMap: {\n                    empower: 6,\n                    hallandale: 12,\n                    boothwyn: 26,\n                    revive: 56,\n                },\n            },\n        },\n\n        {\n            //(1.25 mg / 1.25 mg / 1.25 mg) MG Dosing Quarterly\n            variantIndices: [7, 27, 34, 57, 50],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SEMA6QU,\n                productHref: PRODUCT_HREF.SEMAGLUTIDE,\n                dosage: '(1.25, 1.25, 1.25) mg',\n                cadence: 'quarterly',\n                pharmacyMap: {\n                    empower: 7,\n                    boothwyn: 27,\n                    revive: 57,\n                },\n            },\n        },\n\n        {\n            //(0.5 mg / 1.25 mg / 2.5 mg) MG Dosing Quarterly\n            variantIndices: [8, 28, 36, 59, 52],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SEMA7QU,\n                productHref: PRODUCT_HREF.SEMAGLUTIDE,\n                dosage: '(0.5, 1.25, 2.5) mg',\n                cadence: 'quarterly',\n                pharmacyMap: {\n                    empower: 8,\n                    boothwyn: 28,\n                    revive: 59,\n                },\n            },\n        },\n\n        {\n            //(0.5 x3) MG Dosing Quarterly\n            variantIndices: [12],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SEMA8QU,\n                productHref: PRODUCT_HREF.SEMAGLUTIDE,\n                dosage: '(0.5, 0.5, 0.5) mg',\n                cadence: 'quarterly',\n                pharmacyMap: {\n                    hallandale: 12,\n                },\n            },\n        },\n\n        {\n            //(1.25 mg / 1.25 mg / 2.5 mg) MG Dosing Quarterly\n            variantIndices: [21, 31, 35, 43, 58, 51],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SEMA9QU,\n                productHref: PRODUCT_HREF.SEMAGLUTIDE,\n                dosage: '(1.25, 1.25, 2.5) mg',\n                cadence: 'quarterly',\n                pharmacyMap: {\n                    empower: 21,\n                    boothwyn: 31,\n                    hallandale: 43,\n                    revive: 58,\n                },\n            },\n        },\n\n        {\n            //(1.25 mg / 2.5 mg / 2.5 mg) MG Dosing Quarterly\n            variantIndices: [9, 29, 44, 53],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SEMA10QU,\n                productHref: PRODUCT_HREF.SEMAGLUTIDE,\n                dosage: '(1.25, 2.5, 2.5) mg',\n                cadence: 'quarterly',\n                pharmacyMap: {\n                    empower: 9,\n                    boothwyn: 29,\n                    hallandale: 44,\n                },\n            },\n        },\n\n        {\n            //(2.5 mg / 2.5 mg / 2.5 mg) MG Dosing Quarterly\n            variantIndices: [10, 30, 54],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SEMA11QU,\n                productHref: PRODUCT_HREF.SEMAGLUTIDE,\n                dosage: '(2.5, 2.5, 2.5) mg',\n                cadence: 'quarterly',\n                pharmacyMap: {\n                    empower: 10,\n                    boothwyn: 30,\n                },\n            },\n        },\n\n        /**\n         * Biannual Offers:\n         */\n\n        {\n            //(0.25 mg, 0.25 mg, 0.25 mg, 0.25 mg, 0.25 mg, 0.25 mg) MG Dosing Biannually\n            variantIndices: [15, 64],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SEMA12BIAN,\n                productHref: PRODUCT_HREF.SEMAGLUTIDE,\n                dosage: '(0.25, 0.25, 0.25, 0.25, 0.25, 0.25) mg',\n                cadence: 'biannually',\n                pharmacyMap: {\n                    hallandale: 15,\n                    revive: 64,\n                },\n            },\n        },\n\n        {\n            //(0.5 mg, 0.5 mg, 0.5 mg, 0.5 mg, 0.5 mg, 0.5 mg) MG Dosing Biannually\n            variantIndices: [16, 66],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SEMA13BIAN,\n                productHref: PRODUCT_HREF.SEMAGLUTIDE,\n                dosage: '(0.5, 0.5, 0.5, 0.5, 0.5, 0.5) mg',\n                cadence: 'biannually',\n                pharmacyMap: {\n                    hallandale: 16,\n                    revive: 66,\n                },\n            },\n        },\n\n        {\n            //(1.25 mg, 1.25 mg, 1.25 mg, 1.25 mg, 1.25 mg, 1.25 mg) MG Dosing Biannually\n            variantIndices: [17],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SEMA14BIAN,\n                productHref: PRODUCT_HREF.SEMAGLUTIDE,\n                dosage: '(1.25, 1.25, 1.25, 1.25, 1.25, 1.25) mg',\n                cadence: 'biannually',\n                pharmacyMap: {\n                    hallandale: 17,\n                },\n            },\n        },\n\n        {\n            //(0.25 mg, 0.5 mg, 0.5 mg, 1 mg, 1 mg, 1 mg) MG Dosing Biannually\n            variantIndices: [18, 68],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SEMA15BIAN,\n                productHref: PRODUCT_HREF.SEMAGLUTIDE,\n                dosage: '(0.25, 0.5, 0.5, 1, 1, 1) mg',\n                cadence: 'biannually',\n                pharmacyMap: {\n                    hallandale: 18,\n                    revive: 68,\n                },\n            },\n        },\n\n        {\n            //(0.5 mg, 0.5 mg, 1.25 mg, 1.25 mg, 2.5 mg, 2.5 mg) MG Dosing Biannually\n            variantIndices: [19, 70],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SEMA16BIAN,\n                productHref: PRODUCT_HREF.SEMAGLUTIDE,\n                dosage: '(0.5, 0.5, 1.25, 1.25, 2.5, 2.5) mg',\n                cadence: 'biannually',\n                pharmacyMap: {\n                    hallandale: 19,\n                    revive: 70,\n                },\n            },\n        },\n\n        {\n            //(1.25 mg, 1.25 mg, 1.25 mg, 2.5 mg, 2.5 mg, 2.5 mg) MG Dosing Biannually\n            variantIndices: [20, 72],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SEMA17BIAN,\n                productHref: PRODUCT_HREF.SEMAGLUTIDE,\n                dosage: '(1.25, 1.25, 1.25, 2.5, 2.5, 2.5) mg',\n                cadence: 'biannually',\n                pharmacyMap: {\n                    hallandale: 20,\n                    revive: 72,\n                },\n            },\n        },\n\n        {\n            //(0.25, 0.5, 1, 1.25, 1.25, 1.25) MG Dosing Biannually\n            variantIndices: [74],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SEMA18BIAN,\n                productHref: PRODUCT_HREF.SEMAGLUTIDE,\n                dosage: '(0.25, 0.5, 1, 1.25, 1.25, 1.25) mg',\n                cadence: 'biannually',\n                pharmacyMap: {\n                    revive: 74,\n                },\n            },\n        },\n\n        /**\n         * Annual Offers\n         */\n        {\n            //(0.25, 0.5, 1, 1, 1, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25) MG Dosing Annually\n            variantIndices: [37],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SEMA18ANN,\n                productHref: PRODUCT_HREF.SEMAGLUTIDE,\n                dosage: '(0.25, 0.5, 1, 1, 1, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25) mg',\n                cadence: 'annually',\n                pharmacyMap: {\n                    hallandale: 37,\n                },\n            },\n        },\n\n        {\n            //(0.5, 0.5, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25) MG Dosing Annually\n            variantIndices: [39],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SEMA19ANN,\n                productHref: PRODUCT_HREF.SEMAGLUTIDE,\n                dosage: '(0.5, 0.5, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25) mg',\n                cadence: 'annually',\n                pharmacyMap: {\n                    hallandale: 39,\n                },\n            },\n        },\n\n        {\n            //(1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25) MG Dosing Annually\n            variantIndices: [41],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SEMA20ANN,\n                productHref: PRODUCT_HREF.SEMAGLUTIDE,\n                dosage: '(1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25mg) mg',\n                cadence: 'annually',\n                pharmacyMap: {\n                    hallandale: 41,\n                },\n            },\n        },\n    ],\n\n    tirzepatide: [\n        {\n            //2.5 MG Dosing Monthly\n            variantIndices: [0, 1, 2, 3, 14, 30, 42],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.TIRZ1MO,\n                productHref: PRODUCT_HREF.TIRZEPATIDE,\n                dosage: '2.5 mg',\n                cadence: 'monthly',\n                pharmacyMap: {\n                    empower: 3,\n                    hallandale: 14,\n                    boothwyn: 42,\n                },\n            },\n        },\n        {\n            //5 MG Dosing Monthly\n            variantIndices: [4, 31, 43],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.TIRZ2MO,\n                productHref: PRODUCT_HREF.TIRZEPATIDE,\n                dosage: '5 mg',\n                cadence: 'monthly',\n                pharmacyMap: {\n                    empower: 4,\n                    boothwyn: 43,\n                },\n            },\n        },\n\n        {\n            //7.5 MG Dosing Monthly\n            variantIndices: [5, 32, 44],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.TIRZ3MO,\n                productHref: PRODUCT_HREF.TIRZEPATIDE,\n                dosage: '7.5 mg',\n                cadence: 'monthly',\n                pharmacyMap: {\n                    empower: 5,\n                    boothwyn: 44,\n                },\n            },\n        },\n\n        {\n            //10 MG Dosing Monthly\n            variantIndices: [10, 15, 33, 45],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.TIRZ4MO,\n                productHref: PRODUCT_HREF.TIRZEPATIDE,\n                dosage: '10 mg',\n                cadence: 'monthly',\n                pharmacyMap: {\n                    empower: 10,\n                    hallandale: 15,\n                    boothwyn: 45,\n                },\n            },\n        },\n\n        {\n            //12.5 MG Dosing Monthly\n            variantIndices: [11, 23, 34, 46],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.TIRZ5MO,\n                productHref: PRODUCT_HREF.TIRZEPATIDE,\n                dosage: '10 mg',\n                cadence: 'monthly',\n                pharmacyMap: {\n                    empower: 11,\n                    hallandale: 23,\n                    boothwyn: 46,\n                },\n            },\n        },\n\n        /**\n         * Quarterly Offers:\n         */\n\n        {\n            //(2.5, 5, 5) MG Dosing Quarterly\n            variantIndices: [6, 7, 16, 35],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.TIRZ6QU,\n                productHref: PRODUCT_HREF.TIRZEPATIDE,\n                dosage: '(2.5, 5, 5) mg',\n                cadence: 'monthly',\n                pharmacyMap: {\n                    empower: 6,\n                    hallandale: 16,\n                    boothwyn: 35,\n                },\n            },\n        },\n\n        {\n            //(5, 5, 5) MG Dosing Quarterly\n            variantIndices: [17, 18],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.TIRZ7QU,\n                productHref: PRODUCT_HREF.TIRZEPATIDE,\n                dosage: '(5, 5, 5) mg',\n                cadence: 'quarterly',\n                pharmacyMap: {\n                    hallandale: 17,\n                },\n            },\n        },\n\n        {\n            //(5, 5, 7.5) MG Dosing Quarterly\n            variantIndices: [19],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.TIRZ8QU,\n                productHref: PRODUCT_HREF.TIRZEPATIDE,\n                dosage: '(5, 5, 7.5) mg',\n                cadence: 'quarterly',\n                pharmacyMap: {\n                    hallandale: 19,\n                },\n            },\n        },\n\n        {\n            //(5, 7.5, 7.5) MG Dosing Quarterly\n            variantIndices: [8, 36],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.TIRZ9QU,\n                productHref: PRODUCT_HREF.TIRZEPATIDE,\n                dosage: '(5, 7.5, 7.5) mg',\n                cadence: 'quarterly',\n                pharmacyMap: {\n                    empower: 8,\n                    boothwyn: 36,\n                },\n            },\n        },\n\n        {\n            //(7.5, 7.5, 7.5) MG Dosing Quarterly\n            variantIndices: [9, 20, 37],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.TIRZ10QU,\n                productHref: PRODUCT_HREF.TIRZEPATIDE,\n                dosage: '(7.5, 7.5, 7.5) mg',\n                cadence: 'quarterly',\n                pharmacyMap: {\n                    empower: 9,\n                    boothwyn: 37,\n                },\n            },\n        },\n\n        {\n            //(10, 10, 10) MG Dosing Quarterly\n            variantIndices: [12, 28, 21, 38],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.TIRZ11QU,\n                productHref: PRODUCT_HREF.TIRZEPATIDE,\n                dosage: '(10, 10, 10) mg',\n                cadence: 'quarterly',\n                pharmacyMap: {\n                    empower: 28,\n                    boothwyn: 38,\n                },\n            },\n        },\n\n        {\n            //(12.5, 12.5, 12.5) MG Dosing Quarterly\n            variantIndices: [13, 22, 29, 39],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.TIRZ12QU,\n                productHref: PRODUCT_HREF.TIRZEPATIDE,\n                dosage: '(12.5, 12.5, 12.5) mg',\n                cadence: 'quarterly',\n                pharmacyMap: {\n                    empower: 29,\n                    boothwyn: 39,\n                },\n            },\n        },\n\n        /**\n         * Biannual offers:\n         */\n\n        {\n            //(2.5, 2.5, 2.5, 2.5, 2.5, 2.5) MG Dosing Biannually\n            variantIndices: [24, 57],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.TIRZ13BIAN,\n                productHref: PRODUCT_HREF.TIRZEPATIDE,\n                dosage: '(2.5, 2.5, 2.5, 2.5, 2.5, 2.5) mg',\n                cadence: 'biannually',\n                pharmacyMap: {\n                    hallandale: 24,\n                    revive: 57,\n                },\n            },\n        },\n\n        {\n            //(10 mg, 10 mg, 10 mg, 10 mg, 10 mg, 10 mg) MG Dosing Biannually\n            variantIndices: [25],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.TIRZ14BIAN,\n                productHref: PRODUCT_HREF.TIRZEPATIDE,\n                dosage: '(10, 10, 10, 10, 10, 10) mg',\n                cadence: 'biannually',\n                pharmacyMap: {\n                    hallandale: 25,\n                },\n            },\n        },\n\n        // {\n        //     //(2.5 mg, 5 mg, 5 mg, 7.5 mg, 7.5 mg, 7.5 mg) MG Dosing Biannually\n        //     variantIndices: [26],\n        //     equivalence: {\n        //         productHref: PRODUCT_HREF.TIRZEPATIDE,\n        //         dosage: '(2.5, 5, 5, 7.5, 7.5, 7.5) mg',\n        //         cadence: 'biannually',\n        //         pharmacyMap: {\n        //             hallandale: 26,\n        //         },\n        //     },\n        // },\n\n        {\n            //(2.5 mg, 2.5 mg, 2.5 mg, 5 mg, 5 mg, 5 mg) MG Dosing Biannually\n            variantIndices: [26, 27, 59],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.TIRZ15BIAN,\n                productHref: PRODUCT_HREF.TIRZEPATIDE,\n                dosage: '(2.5, 2.5, 2.5, 5, 5, 5) mg',\n                cadence: 'biannually',\n                pharmacyMap: {\n                    hallandale: 27,\n                    revive: 59,\n                },\n            },\n        },\n\n        /**\n         * Annual Offers:\n         */\n        {\n            //(2.5, 2.5, 2.5, 2.5, 2.5, 2.5, 5, 5, 5, 5, 5, 5) MG Dosing Annually\n            variantIndices: [40],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.TIRZ16ANN,\n                productHref: PRODUCT_HREF.TIRZEPATIDE,\n                dosage: '(2.5, 2.5, 2.5, 2.5, 2.5, 2.5, 5, 5, 5, 5, 5, 5) mg',\n                cadence: 'annually',\n                pharmacyMap: {\n                    hallandale: 40,\n                },\n            },\n        },\n    ],\n    [PRODUCT_HREF.SERMORELIN]: [\n        {\n            // First Month Sermorelin\n            variantIndices: [0],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SERM1MO,\n                productHref: PRODUCT_HREF.SERMORELIN,\n                dosage: '10 mg',\n                cadence: 'monthly',\n                pharmacyMap: {\n                    boothwyn: 0,\n                },\n            },\n        },\n        {\n            // Monthly Sermorelin\n            variantIndices: [1],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SERM1MO,\n                productHref: PRODUCT_HREF.SERMORELIN,\n                dosage: '10 mg',\n                cadence: 'monthly',\n                pharmacyMap: {\n                    boothwyn: 1,\n                },\n            },\n        },\n        {\n            // Quarterly Sermorelin (3 month supply)\n            variantIndices: [2],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SERM2QU,\n                productHref: PRODUCT_HREF.SERMORELIN,\n                dosage: '10 mg x 3',\n                cadence: 'quarterly',\n                pharmacyMap: {\n                    boothwyn: 2,\n                },\n            },\n        },\n        {\n            // Biannual Sermorelin (6 month supply)\n            variantIndices: [3],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SERM3BIAN,\n                productHref: PRODUCT_HREF.SERMORELIN,\n                dosage: '10 mg x 6',\n                cadence: 'biannually',\n                pharmacyMap: {\n                    boothwyn: 3,\n                },\n            },\n        },\n        {\n            // A/B Test Biannual Sermorelin (6 month supply) - First Shipment\n            variantIndices: [74],\n            equivalence: {\n                equivalenceCode: EquivalenceCodes.SERM3BIAN,\n                productHref: PRODUCT_HREF.SERMORELIN,\n                dosage: '10 mg x 6',\n                cadence: 'biannually',\n                pharmacyMap: {\n                    boothwyn: 74,\n                },\n            },\n        },\n    ],\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/classes/ProductVariant/ProductVarianceMap.ts",
      "bioverse-client/app/utils/classes/ProductVariant/ProductVariantController.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/classes/ProductVariant/ProductVariantController.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/classes/ProductVariant/ProductVariantModel.d.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/classes/ProductVariant/constants/ProductEquivalencyConstants.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/classes/ProductVariant/constants/VariantPharmacyMap.ts",
    "exports": [
      {
        "name": "VARIANT_PHARMACY_MAP",
        "kind": "variable",
        "signature": "VARIANT_PHARMACY_MAP: VariantPharmacyMap = {\n    [PRODUCT_HREF.SEMAGLUTIDE]: {\n        0: 'empower',\n        1: 'empower',\n        2: 'empower',\n        3: 'empower',\n        4: 'empower',\n        5: 'empower',\n        6: 'empower',\n        7: 'empower',\n        8: 'empower',\n        9: 'empower',\n        10: 'empower',\n        11: 'hallandale',\n        12: 'hallandale',\n        13: 'hallandale',\n        14: 'hallandale',\n        15: 'hallandale',\n        16: 'hallandale',\n        17: 'hallandale',\n        18: 'hallandale',\n        19: 'hallandale',\n        20: 'hallandale',\n        21: 'empower',\n        22: 'boothwyn',\n        23: 'boothwyn',\n        24: 'boothwyn',\n        25: 'boothwyn',\n        26: 'boothwyn',\n        27: 'boothwyn',\n        28: 'boothwyn',\n        29: 'boothwyn',\n        30: 'boothwyn',\n        31: 'boothwyn',\n        32: 'revive',\n        33: 'revive',\n        34: 'revive',\n        35: 'revive',\n        36: 'revive',\n        37: 'hallandale',\n        38: 'hallandale',\n        39: 'hallandale',\n        40: 'hallandale',\n        41: 'hallandale',\n        42: 'hallandale',\n        43: 'hallandale',\n        44: 'hallandale',\n        45: 'boothwyn',\n        46: 'boothwyn',\n        47: 'boothwyn',\n        48: 'boothwyn',\n        49: 'boothwyn',\n        50: 'boothwyn',\n        51: 'boothwyn',\n        52: 'boothwyn',\n        53: 'boothwyn',\n        54: 'boothwyn',\n        55: 'revive',\n        56: 'revive',\n        57: 'revive',\n        58: 'revive',\n        59: 'revive',\n        60: 'boothwyn',\n        61: 'boothwyn',\n        62: 'boothwyn',\n        63: 'boothwyn',\n        64: 'revive',\n        65: 'revive',\n        66: 'revive',\n        67: 'revive',\n        68: 'revive',\n        69: 'revive',\n        70: 'revive',\n        71: 'revive',\n        72: 'revive',\n        73: 'revive',\n        \n    },\n    [PRODUCT_HREF.TIRZEPATIDE]: {\n        0: 'empower',\n        1: 'empower',\n        2: 'empower',\n        3: 'empower',\n        4: 'empower',\n        5: 'empower',\n        6: 'empower',\n        7: 'empower',\n        8: 'empower',\n        9: 'empower',\n        10: 'empower',\n        11: 'empower',\n        12: 'empower',\n        13: 'empower',\n        14: 'hallandale',\n        15: 'hallandale',\n        16: 'hallandale',\n        17: 'hallandale',\n        18: 'hallandale',\n        19: 'hallandale',\n        20: 'hallandale',\n        21: 'hallandale',\n        22: 'hallandale',\n        23: 'hallandale',\n        24: 'hallandale',\n        25: 'hallandale',\n        26: 'hallandale',\n        27: 'hallandale',\n        28: 'empower',\n        29: 'empower',\n        30: 'boothwyn',\n        31: 'boothwyn',\n        32: 'boothwyn',\n        33: 'boothwyn',\n        34: 'boothwyn',\n        35: 'boothwyn',\n        36: 'boothwyn',\n        37: 'boothwyn',\n        38: 'boothwyn',\n        39: 'boothwyn',\n        40: 'hallandale',\n        41: 'hallandale',\n        42: 'boothwyn',\n        43: 'boothwyn',\n        44: 'boothwyn',\n        45: 'boothwyn',\n        46: 'boothwyn',\n        47: 'revive',\n        48: 'revive',\n        49: 'revive',\n        50: 'revive',\n        51: 'revive',\n        52: 'boothwyn',\n        53: 'boothwyn',\n        54: 'boothwyn',\n        55: 'boothwyn',\n        56: 'boothwyn',\n        57: 'revive',\n        58: 'revive',\n        59: 'revive',\n        60: 'revive',\n    },\n    [PRODUCT_HREF.WL_CAPSULE]: {\n        0: 'empower',\n        1: 'empower',\n        2: 'empower',\n        3: 'empower',\n        4: 'empower',\n        5: 'empower',\n    },\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/classes/ProductVariant/constants/VariantPharmacyMap.ts",
      "bioverse-client/app/utils/classes/SigVisualizer/SigVisualizer.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/resend-script-confirmation.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/classes/Scripts/BaseScriptHandler.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/classes/Scripts/BoothwynScriptHandler.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/classes/Scripts/EmpowerScriptHandler.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/classes/Scripts/HallandaleScriptHandler.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/classes/Scripts/ReviveScriptHandler.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/classes/Scripts/ScriptHandlerFactory.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/classes/SigVisualizer/SigVisualizer.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/classes/SigVisualizer/sig-visualizer.d.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/clients/supabaseBrowserClient.ts",
    "exports": [
      {
        "name": "createSupabaseBrowserClient",
        "kind": "function",
        "signature": "export function createSupabaseBrowserClient() {\n    return createBrowserClient(\n        process.env.NEXT_PUBLIC_supabase_url!,\n        process.env.NEXT_PUBLIC_supabase_anon_key!\n    );\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(administration)/admin/pdpapi/create-product/page.tsx",
      "bioverse-client/app/(administration)/admin/pdpapi/[id]/productNameSection.tsx",
      "bioverse-client/app/(administration)/admin/pdpapi/[id]/page.tsx",
      "bioverse-client/app/utils/clients/supabaseBrowserClient.ts",
      "bioverse-client/app/utils/actions/auth/oauth.ts",
      "bioverse-client/app/utils/actions/provider/prescription-requests.ts",
      "bioverse-client/app/utils/actions/membership/order-history-actions.ts",
      "bioverse-client/app/components/navigation/components/client-side-navigation/account-menu/account-menu.tsx",
      "bioverse-client/app/components/patient-portal/labs/labs-content.tsx",
      "bioverse-client/app/components/patient-portal/patient-portal-client/patient-upload-document.tsx",
      "bioverse-client/app/components/patient-portal/patient-portal-client/patient-id-verification.tsx",
      "bioverse-client/app/components/patient-portal/message/thread-container/thread-container-new.tsx",
      "bioverse-client/app/components/patient-portal/account-information/phi-download-component.tsx",
      "bioverse-client/app/components/patient-portal/account-information/personal-information/photo-edit-drawer.tsx",
      "bioverse-client/app/components/patient-portal/order-history/orderItem.tsx",
      "bioverse-client/app/components/productPages/content-pages/supplements/supplement-product-page.tsx",
      "bioverse-client/app/components/productPages/biomarkers/biomarkers-box.tsx",
      "bioverse-client/app/components/intake-v3/pages/id-verification-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/id-verification-noskip-v3.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/glp-surgery-doc-upload.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/checkbox-logic/custom-checkboxes/custom-bloodwork-upload-v3.tsx",
      "bioverse-client/app/components/intake-v2/pages/id-verification.tsx",
      "bioverse-client/app/components/intake-v2/pages/skincare-upload.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/upload.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/glp-surgery-doc-upload.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/checkbox-logic/custom-checkboxes/custom-bloodwork-upload.tsx",
      "bioverse-client/app/components/login/ChangePassword.tsx",
      "bioverse-client/app/components/login/CheckEmail.tsx",
      "bioverse-client/app/components/login/mfa/mfaVerifyPageContents.tsx",
      "bioverse-client/app/components/login/mfa/mfaPageContents.tsx",
      "bioverse-client/app/components/login/login-drawer/login-drawer-container.tsx",
      "bioverse-client/app/components/login/ResetPassword.tsx",
      "bioverse-client/app/components/login/loginPageContents.tsx",
      "bioverse-client/app/components/login/PrivilegedLogin.tsx",
      "bioverse-client/app/hooks/useSessionTimeout.ts",
      "bioverse-client/_deprecated/clinical-intake-flow/order-table/components/order-table-provider.tsx",
      "bioverse-client/_deprecated/chat_old_6.10/chatUI-old.tsx",
      "bioverse-client/_deprecated/chat_old_6.10/chatUI.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/clients/supabaseReqResClient.ts",
    "exports": [
      {
        "name": "createSupabaseReqResClient",
        "kind": "function",
        "signature": "export function createSupabaseReqResClient(req: any, res: any) {\n    return createServerClient(\n        process.env.NEXT_PUBLIC_supabase_url!,\n        process.env.NEXT_PUBLIC_supabase_anon_key!,\n        {\n            cookies: {\n                get(name: string) {\n                    return getCookie(name, { req, res });\n                },\n                set(name: string, value: string, options: CookieOptions) {\n                    setCookie(name, value, { req, res, ...options });\n                },\n                remove(name: string, options: CookieOptions) {\n                    setCookie(name, '', { req, res, ...options });\n                },\n            },\n        },\n    );\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/clients/supabaseReqResClient.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/clients/supabaseServerClient.ts",
    "exports": [
      {
        "name": "createSupabaseServerClient",
        "kind": "function",
        "signature": "export function createSupabaseServerClient(serverComponent = false) {\n    const cookieStore = cookies();\n\n    return createServerClient(\n        process.env.NEXT_PUBLIC_supabase_url!,\n        process.env.NEXT_PUBLIC_supabase_anon_key!,\n        {\n            cookies: {\n                get(name: string) {\n                    return cookieStore.get(name)?.value;\n                },\n                set(name: string, value: string, options: CookieOptions) {\n                    if (serverComponent) return;\n                    cookieStore.set({ name, value, ...options });\n                },\n                remove(name: string, options: CookieOptions) {\n                    if (serverComponent) return;\n                    cookieStore.set({ name, value: '', ...options });\n                },\n            },\n        }\n    );\n}"
      },
      {
        "name": "createSupabaseServerComponentClient",
        "kind": "function",
        "signature": "export function createSupabaseServerComponentClient() {\n    return createSupabaseServerClient(true);\n}"
      },
      {
        "name": "createSupabaseServiceClient",
        "kind": "function",
        "signature": "export function createSupabaseServiceClient() {\n    return createClient(\n        process.env.NEXT_PUBLIC_supabase_url!,\n        process.env.SUPABASE_SERVICE_ROLE_KEY!,\n        {\n            auth: {\n                persistSession: false,\n                autoRefreshToken: false,\n                detectSessionInUrl: false,\n            },\n        }\n    );\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/auth/callback/route.ts",
      "bioverse-client/app/utils/clients/supabaseServerClient.ts",
      "bioverse-client/app/utils/actions/auth/session-reader.ts",
      "bioverse-client/app/utils/actions/auth/auth-actions.ts",
      "bioverse-client/app/utils/actions/auth/server-signIn-signOut.ts",
      "bioverse-client/app/utils/actions/provider/prescription-requests.ts",
      "bioverse-client/app/utils/actions/message/message-actions.ts",
      "bioverse-client/app/api/mixpanel/route.ts",
      "bioverse-client/app/(administration)/admin/stripe-api/stripe-api-actions.ts",
      "bioverse-client/app/utils/database/controller/shipping_status_audit/shipping_status_audit.ts",
      "bioverse-client/app/utils/database/controller/pharmacy-order-failures/pharmacy-order-failures.ts",
      "bioverse-client/app/utils/database/controller/ds_match_failures/ds-match-failures.ts",
      "bioverse-client/app/utils/database/controller/products/products.ts",
      "bioverse-client/app/utils/database/controller/dose_spot_webhook_audit/dose-spot-webhook-audit.ts",
      "bioverse-client/app/utils/database/controller/patient_providers/patient-providers.ts",
      "bioverse-client/app/utils/database/controller/providers/providers-api.ts",
      "bioverse-client/app/utils/database/controller/admin_order_cancel_audit/admin-order-cancel-audit.ts",
      "bioverse-client/app/utils/database/controller/mixpanel/mixpanel.ts",
      "bioverse-client/app/utils/database/controller/storage/face-pictures/face-picture-functions.ts",
      "bioverse-client/app/utils/database/controller/storage/license-selfie/license-selfie-functions.ts",
      "bioverse-client/app/utils/database/controller/patient_document_uploads/patient_document_uploads.ts",
      "bioverse-client/app/utils/database/controller/orders/address-in-most-recent-order.ts",
      "bioverse-client/app/utils/database/controller/orders/orders-api.ts",
      "bioverse-client/app/utils/database/controller/orders/order-matching-dose-spot.ts",
      "bioverse-client/app/utils/database/controller/profiles/profiles.ts",
      "bioverse-client/app/utils/database/controller/pharmacy_order_audit/pharmacy_order_audit.tsx",
      "bioverse-client/app/utils/database/controller/messaging/threads/threads.ts",
      "bioverse-client/app/utils/database/api-controller/product_prices/product-prices.ts",
      "bioverse-client/app/utils/database/api-controller/order_management/admin-order-management.ts",
      "bioverse-client/app/utils/actions/provider/active-subscriptions.ts",
      "bioverse-client/app/utils/actions/provider/patient-overview.ts",
      "bioverse-client/app/utils/actions/provider/update-renewal-order-metadata.ts",
      "bioverse-client/app/utils/actions/provider/get-suggested-dosages.ts",
      "bioverse-client/app/utils/actions/provider/check-for-renewal-order.ts",
      "bioverse-client/app/utils/actions/provider/patient-intake.ts",
      "bioverse-client/app/utils/actions/provider/provider-dosespot.ts",
      "bioverse-client/app/utils/actions/message/message-user.ts",
      "bioverse-client/app/utils/actions/message/messageTest.ts",
      "bioverse-client/app/utils/actions/subscriptions/subscription-actions.ts",
      "bioverse-client/app/utils/actions/intake/hhq-questionnaire.ts",
      "bioverse-client/app/utils/actions/intake/product-data.ts",
      "bioverse-client/app/utils/actions/intake/order-control.ts",
      "bioverse-client/app/utils/actions/pdp-api/pdp-api.ts",
      "bioverse-client/app/utils/actions/membership/membership-portal-actions.ts",
      "bioverse-client/app/utils/actions/membership/order-history-actions.ts",
      "bioverse-client/app/utils/functions/provider-portal/messages/admin-message-center.ts",
      "bioverse-client/app/(content)/prescriptions/[product]/page.tsx",
      "bioverse-client/app/api/dosespot/_event-type-cases/handlePrescriberNotificationCounts.ts",
      "bioverse-client/app/api/dosespot/_event-type-cases/handlePrescriptionResult.ts",
      "bioverse-client/app/api/patient-portal/messages/route.ts",
      "bioverse-client/app/api/patient-portal/phi/_deprecated_route.ts",
      "bioverse-client/app/api/patient-portal/phi/route.ts",
      "bioverse-client/app/(patient-portal)/portal/labs/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/registration/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/new-checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v2/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3-abtest/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/pre-id-v3-ap/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/product-overview/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/registration-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3-zbp/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/new-checkout/page.tsx",
      "bioverse-client/app/services/pharmacy-integration/gogomeds/update-order.ts",
      "bioverse-client/app/services/pharmacy-integration/tmc/tmc-actions.ts",
      "bioverse-client/app/services/stripe/charge-customer.ts",
      "bioverse-client/_deprecated/priceapi/price-api-actions.ts",
      "bioverse-client/_deprecated/imageapi/image-api-actions.ts",
      "bioverse-client/_deprecated/reviewapi/util/reviewapi-supabase.ts",
      "bioverse-client/_deprecated/reviewapi/[producthref]/page.tsx",
      "bioverse-client/_deprecated/checkout-test/page.tsx",
      "bioverse-client/app/(testing_and_development)/olivier-dev/utils.ts",
      "bioverse-client/app/(testing_and_development)/dev/send-script-empower/empower-script-search.ts",
      "bioverse-client/app/(testing_and_development)/dev/send-script-curexa/curexa-script-functions.ts",
      "bioverse-client/app/utils/database/storage/lab-work-documents/lab-work-documents.ts",
      "bioverse-client/app/utils/database/storage/skin-care-face-pictures/skin-care-face-uploads.ts",
      "bioverse-client/app/utils/database/storage/license-selfie/license-selfie.ts",
      "bioverse-client/app/utils/database/controller/site-error-audit/site_error_audit.ts",
      "bioverse-client/app/utils/database/controller/admin_controlled_items/admin-controlled-items.ts",
      "bioverse-client/app/utils/database/controller/escalations/escalations-api.ts",
      "bioverse-client/app/utils/database/controller/subscription_status_audit/subscription_stauts_audit.ts",
      "bioverse-client/app/utils/database/controller/renewal_order_audit/renewal_order_audit.ts",
      "bioverse-client/app/utils/database/controller/custom_orders/custom_orders_api.ts",
      "bioverse-client/app/utils/database/controller/customerio_audit/audit_customerio.ts",
      "bioverse-client/app/utils/database/controller/tasks/task-api.ts",
      "bioverse-client/app/utils/database/controller/coordinator_activity_audit/coordinator_activity_audit-api.ts",
      "bioverse-client/app/utils/database/controller/ai_generation_audit/ai_generation_audit_api.ts",
      "bioverse-client/app/utils/database/controller/questionnaires/questionnaire.ts",
      "bioverse-client/app/utils/database/controller/questionnaires/questionnaire_sessions.ts",
      "bioverse-client/app/utils/database/controller/payment_failure_audit/payment_failure_audit-api.ts",
      "bioverse-client/app/utils/database/controller/shipping_tracking_failed_audit/shipping-tracking-failed-audit.ts",
      "bioverse-client/app/utils/database/controller/internal_notes/internal-notes-api.ts",
      "bioverse-client/app/utils/database/controller/provider_activity_audit/provider_activity_audit-api.ts",
      "bioverse-client/app/utils/database/controller/payment_failures/payment-failures.ts",
      "bioverse-client/app/utils/database/controller/clinical_notes/clinical_notes_v2.ts",
      "bioverse-client/app/utils/database/controller/clinical_notes/clinical-notes.ts",
      "bioverse-client/app/utils/database/controller/action-items/action-items-actions.ts",
      "bioverse-client/app/utils/database/controller/stripe_audit/stripe_audit.ts",
      "bioverse-client/app/utils/database/controller/prescription_subscriptions/prescription_subscriptions.ts",
      "bioverse-client/app/utils/database/controller/marketing_opt_ins/marketing.tsx",
      "bioverse-client/app/utils/database/controller/job-scheduler/job-scheduler-actions.ts",
      "bioverse-client/app/utils/database/controller/macros/macros-api.ts",
      "bioverse-client/app/utils/database/controller/payment_error_audit/payment_error_audit.ts",
      "bioverse-client/app/utils/database/controller/patient-status-tags/patient-status-tags-api.ts",
      "bioverse-client/app/utils/database/controller/renewal_orders/renewal_orders.ts",
      "bioverse-client/app/utils/database/controller/product_variants/product_variants.ts",
      "bioverse-client/app/utils/database/controller/orders/create-manual-order.ts",
      "bioverse-client/app/utils/database/controller/payment_failure_tracker/payment_failure_tracker-api.ts",
      "bioverse-client/app/utils/database/controller/patient_action_history/patient-action-history.ts",
      "bioverse-client/app/utils/database/controller/patient_weight_audit/patient-weight-audit-api.ts",
      "bioverse-client/app/utils/database/controller/patient_combined_wl_answers_temp/patient_combined_wl_answers_temp_api.ts",
      "bioverse-client/app/utils/database/controller/messaging/messages/messages.ts",
      "bioverse-client/app/utils/database/controller/messaging/thread_members/thread_members.ts",
      "bioverse-client/app/utils/database/controller/messaging/thread_escalations/thread_escalations.ts",
      "bioverse-client/app/utils/database/controller/coordinator_tasks/coordinator-task-api.ts",
      "bioverse-client/app/utils/database/controller/revive_pharmacy_patient_data/revive_pharamacy_patient_data_api.ts",
      "bioverse-client/app/utils/database/controller/prescription_script_audit/prescription_script_audit.tsx",
      "bioverse-client/app/utils/database/controller/employees/employees-api.ts",
      "bioverse-client/app/utils/database/controller/order_data_audit/order_data_audit_api.ts",
      "bioverse-client/app/utils/database/api-controller/products/products.ts",
      "bioverse-client/app/utils/database/api-controller/discounts/database-discounts-api.ts",
      "bioverse-client/app/utils/actions/questionnaires/questionnaire-actions.ts",
      "bioverse-client/app/utils/actions/auth/change-email.ts",
      "bioverse-client/app/utils/actions/prescription-subscriptions/prescription-subscriptions-actions.ts",
      "bioverse-client/app/utils/actions/provider/announcements.ts",
      "bioverse-client/app/utils/actions/provider/dashboard-scripts.ts",
      "bioverse-client/app/utils/actions/provider/auth.ts",
      "bioverse-client/app/utils/actions/intake/order-util.ts",
      "bioverse-client/app/utils/actions/alternatives/weight-loss/alternative-weight-loss-actions.ts",
      "bioverse-client/app/utils/actions/check-up/check-up-actions.ts",
      "bioverse-client/app/utils/functions/coordinator-portal/time-tracker/coordinator-time-tracker-functions.ts",
      "bioverse-client/app/utils/functions/annual-glp1/annual-glp1-controller.ts",
      "bioverse-client/app/utils/functions/split-shipment-glp1/split-shipment-glp1-controller.ts",
      "bioverse-client/app/utils/functions/auth/password-reset/password-reset.ts",
      "bioverse-client/app/utils/functions/utils.ts",
      "bioverse-client/app/utils/functions/provider-portal/time-tracker/provider-time-tracker-functions.ts",
      "bioverse-client/app/utils/functions/clean-stale-orders/clean-stale-orders.ts",
      "bioverse-client/app/(employee)/(provider-portal)/provider/active-macros/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/active-renewal-options/page.tsx",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/utils/data-fetching/coordinator-thread-data-fetch.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/utils/license-selfies/signed-url-retriever.ts",
      "bioverse-client/app/components/coordinator-portal/upcoming-list/utils/upcoming-list-function.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/utils/license-selfies/signed-url-retriever.ts",
      "bioverse-client/app/components/provider-portal/csv-download/tx_patient_csv_data_fetch.ts",
      "bioverse-client/app/components/registered-nurse-portal/dashboard/utils/rn-dashboard-functions.ts",
      "bioverse-client/app/components/patient-portal/subscriptions/components/SubscriptionList/utils/SubscriptionItem-functions.ts",
      "bioverse-client/app/components/intake-v2/ed/utils/ed-order-update.ts",
      "bioverse-client/app/components/intake-v2/ed/utils/getVariantsForED.ts",
      "bioverse-client/app/api/user-profile/user-data/route.ts",
      "bioverse-client/app/api/patient-portal/phi/_supabase-function/handlePHIDataAcquisition.ts",
      "bioverse-client/app/api/stripe/webhook/subscriptions/route.ts",
      "bioverse-client/app/(patient-portal)/check-up/[product_href]/utils.ts",
      "bioverse-client/app/services/mixpanel/mixpanel-utils.ts",
      "bioverse-client/app/services/pharmacy-integration/revive/revive-order-api.ts",
      "bioverse-client/app/services/pharmacy-integration/revive/revive-patient-api.ts",
      "bioverse-client/app/services/pharmacy-integration/empower/send-script.ts",
      "bioverse-client/app/services/pharmacy-integration/curexa/curexa-actions.ts",
      "bioverse-client/app/services/pharmacy-integration/gogomeds/ggm-actions.ts",
      "bioverse-client/app/services/customerio/customerioApiFactory.ts",
      "bioverse-client/app/services/stripe/prices.ts",
      "bioverse-client/app/services/stripe/recharge.ts",
      "bioverse-client/app/services/stripe/subscriptions.ts",
      "bioverse-client/app/services/stripe/refunds.ts",
      "bioverse-client/_deprecated/check_up_apr_29/checkup-quesiton-swr-script.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/constants/VWO/vwo_test_mappings.ts",
    "exports": [
      {
        "name": "VWO_ACTIVE_TEST_ROUTE_MAPPING",
        "kind": "variable",
        "signature": "VWO_ACTIVE_TEST_ROUTE_MAPPING: VWO_ACTIVE_ROUTE_MAP = {\n    'global-no-6': {\n        [PRODUCT_HREF.WEIGHT_LOSS]: {\n            [INTAKE_ROUTE_V3.WEIGHT_LOSS_SUPPLY]: {\n                replacement_route: INTAKE_ROUTE_V3.WEIGHT_LOSS_SUPPLY_NO_6,\n            },\n        },\n    },\n}"
      },
      {
        "name": "VWO_REVERSION_MAPPING",
        "kind": "variable",
        "signature": "VWO_REVERSION_MAPPING: VWO_REVERSIONS = {\n    [INTAKE_ROUTE_V3.WEIGHT_LOSS_SUPPLY_NO_6]: {\n        original: INTAKE_ROUTE_V3.WEIGHT_LOSS_SUPPLY,\n    },\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/constants/VWO/vwo_test_mappings.ts",
      "bioverse-client/app/utils/functions/intake-route-controller.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/constants/clinical-note-template-latest-versions.ts",
    "exports": [
      {
        "name": "PRODUCT_TEMPLATE_LATEST_VERSION_MAP",
        "kind": "variable",
        "signature": "PRODUCT_TEMPLATE_LATEST_VERSION_MAP: TemplateVersionMap = {\n    [PRODUCT_HREF.SEMAGLUTIDE]: {\n        intake: 2,\n        renewal: 3,\n    },\n    [PRODUCT_HREF.TIRZEPATIDE]: {\n        intake: 2,\n        renewal: 3,\n    },\n    [PRODUCT_HREF.WL_CAPSULE]: {\n        intake: 1,\n        renewal: 1,\n    },\n    [PRODUCT_HREF.METFORMIN]: {\n        intake: 2,\n        renewal: 2,\n    },\n    [PRODUCT_HREF.NAD_INJECTION]: {\n        intake: 2,\n        renewal: 2,\n    },\n    [PRODUCT_HREF.NAD_NASAL_SPRAY]: {\n        intake: 2,\n        renewal: 2,\n    },\n    [PRODUCT_HREF.NAD_PATCHES]: {\n        intake: 2,\n        renewal: 2,\n    },\n    [PRODUCT_HREF.GLUTATIONE_INJECTION]: {\n        intake: 2,\n        renewal: 2,\n    },\n    [PRODUCT_HREF.B12_INJECTION]: {\n        intake: 2,\n        renewal: 2,\n    },\n    [PRODUCT_HREF.ED_GLOBAL]: {\n        intake: 2,\n        renewal: 2,\n    },\n    [PRODUCT_HREF.PEAK_CHEWS]: {\n        intake: 2,\n        renewal: 2,\n    },\n    [PRODUCT_HREF.RUSH_CHEWS]: {\n        intake: 2,\n        renewal: 2,\n    },\n    [PRODUCT_HREF.RUSH_MELTS]: {\n        intake: 2,\n        renewal: 2,\n    },\n    [PRODUCT_HREF.X_CHEWS]: {\n        intake: 2,\n        renewal: 2,\n    },\n    [PRODUCT_HREF.X_MELTS]: {\n        intake: 2,\n        renewal: 2,\n    },\n    [PRODUCT_HREF.TADALAFIL]: {\n        intake: 2,\n        renewal: 2,\n    },\n    [PRODUCT_HREF.SILDENAFIL]: {\n        intake: 2,\n        renewal: 2,\n    },\n    [PRODUCT_HREF.VIAGRA]: {\n        intake: 2,\n        renewal: 2,\n    },\n    [PRODUCT_HREF.CIALIS]: {\n        intake: 2,\n        renewal: 2,\n    },\n    [PRODUCT_HREF.TRETINOIN]: {\n        intake: 1,\n        renewal: 1,\n    },\n    [PRODUCT_HREF.FINASTERIDE_AND_MINOXIDIL]: {\n        intake: 1,\n        renewal: 1,\n    },\n    [PRODUCT_HREF.TELMISARTAN]: {\n        intake: 1,\n        renewal: 1,\n    },\n    [PRODUCT_HREF.ACARBOSE]: {\n        intake: 1,\n        renewal: 1,\n    },\n    [PRODUCT_HREF.CGM_SENSOR]: {\n        intake: 1,\n        renewal: 1,\n    },\n    [PRODUCT_HREF.ATORVASTATIN]: {\n        intake: 1,\n        renewal: 1,\n    },\n    [PRODUCT_HREF.ZOFRAN]: {\n        intake: 1,\n        renewal: 1,\n    },\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/clinical_notes/clinical_notes_v2.ts",
      "bioverse-client/app/utils/constants/clinical-note-template-latest-versions.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-creation-menu/creation-tab-content/note-creation/template-preview.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-templates/clinical-template-functions.ts",
      "bioverse-client/_deprecated/clinical_notes_v1/collapsible-note-template.tsx",
      "bioverse-client/_deprecated/clinical_notes_v1/clinical-note-template-deprecated.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/constants/clinical-note-template-product-map.ts",
    "exports": [
      {
        "name": "TEMPLATIZED_PRODUCT_LIST",
        "kind": "variable",
        "signature": "TEMPLATIZED_PRODUCT_LIST = [\n    //Templatized notes initial set\n    PRODUCT_HREF.SEMAGLUTIDE,\n    PRODUCT_HREF.TIRZEPATIDE,\n    PRODUCT_HREF.WL_CAPSULE,\n    PRODUCT_HREF.METFORMIN,\n    PRODUCT_HREF.NAD_INJECTION,\n    PRODUCT_HREF.NAD_NASAL_SPRAY,\n    PRODUCT_HREF.NAD_PATCHES,\n    PRODUCT_HREF.GLUTATIONE_INJECTION,\n    PRODUCT_HREF.B12_INJECTION,\n    PRODUCT_HREF.TRETINOIN,\n    PRODUCT_HREF.FINASTERIDE_AND_MINOXIDIL,\n    PRODUCT_HREF.TELMISARTAN,\n    PRODUCT_HREF.ACARBOSE,\n    PRODUCT_HREF.CGM_SENSOR,\n    PRODUCT_HREF.ATORVASTATIN,\n    PRODUCT_HREF.ZOFRAN,\n    //ED Products:\n    PRODUCT_HREF.ED_GLOBAL,\n    PRODUCT_HREF.PEAK_CHEWS,\n    PRODUCT_HREF.RUSH_CHEWS,\n    PRODUCT_HREF.RUSH_MELTS,\n    PRODUCT_HREF.X_CHEWS,\n    PRODUCT_HREF.X_MELTS,\n    PRODUCT_HREF.TADALAFIL,\n    PRODUCT_HREF.SILDENAFIL,\n    PRODUCT_HREF.VIAGRA,\n    PRODUCT_HREF.CIALIS,\n]"
      },
      {
        "name": "PRODUCT_TEMPLATE_MAPPING",
        "kind": "variable",
        "signature": "PRODUCT_TEMPLATE_MAPPING: ProductTemplateMap = {\n    [PRODUCT_HREF.SEMAGLUTIDE]: {\n        intake: {\n            1: GLP1_INTAKE_TEMPLATE,\n            2: GLP1_INTAKE_TEMPLATE_V2,\n        },\n        renewal: {\n            1: GLP1_RENEWAL_TEMPLATE,\n            2: GLP1_RENEWAL_TEMPLATE_V2,\n            3: GLP1_RENEWAL_TEMPLATE_V3,\n        },\n    },\n    [PRODUCT_HREF.TIRZEPATIDE]: {\n        intake: {\n            1: GLP1_INTAKE_TEMPLATE,\n            2: GLP1_INTAKE_TEMPLATE_V2,\n        },\n        renewal: {\n            1: GLP1_RENEWAL_TEMPLATE,\n            2: GLP1_RENEWAL_TEMPLATE_V2,\n            3: GLP1_RENEWAL_TEMPLATE_V3,\n        },\n    },\n    [PRODUCT_HREF.WL_CAPSULE]: {\n        intake: {\n            1: WL_CAPSULE_TEMPLATE,\n            2: WL_CAPSULE_TEMPLATE_V2,\n        },\n        renewal: {\n            1: WL_CAPSULE_TEMPLATE,\n            2: WL_CAPSULE_TEMPLATE_V2,\n        },\n    },\n    [PRODUCT_HREF.METFORMIN]: {\n        intake: {\n            1: METFORMIN_TEMPLATE,\n            2: METFORMIN_TEMPLATE_V2,\n        },\n        renewal: {\n            1: METFORMIN_TEMPLATE,\n            2: METFORMIN_TEMPLATE_V2,\n        },\n    },\n    [PRODUCT_HREF.NAD_INJECTION]: {\n        intake: {\n            1: NAD_INJECTION_TEMPLATE,\n            2: NAD_COMBINED_TEMPLATE_V2,\n        },\n        renewal: {\n            1: NAD_INJECTION_TEMPLATE,\n            2: NAD_COMBINED_TEMPLATE_V2,\n        },\n    },\n    [PRODUCT_HREF.NAD_NASAL_SPRAY]: {\n        intake: {\n            1: NAD_NASAL_SPRAY_TEMPLATE,\n            2: NAD_COMBINED_TEMPLATE_V2,\n        },\n        renewal: {\n            1: NAD_NASAL_SPRAY_TEMPLATE,\n            2: NAD_COMBINED_TEMPLATE_V2,\n        },\n    },\n    [PRODUCT_HREF.NAD_PATCHES]: {\n        intake: {\n            1: NAD_PATCHES_TEMPLATE,\n            2: NAD_COMBINED_TEMPLATE_V2,\n        },\n        renewal: {\n            1: NAD_PATCHES_TEMPLATE,\n            2: NAD_COMBINED_TEMPLATE_V2,\n        },\n    },\n    [PRODUCT_HREF.GLUTATIONE_INJECTION]: {\n        intake: {\n            1: GLUTATHIONE_INJECTION_TEMPLATE,\n            2: GLUTATHIONE_INJECTION_TEMPLATE_V2,\n        },\n        renewal: {\n            1: GLUTATHIONE_INJECTION_TEMPLATE,\n            2: GLUTATHIONE_INJECTION_TEMPLATE_V2,\n        },\n    },\n    [PRODUCT_HREF.B12_INJECTION]: {\n        intake: {\n            1: B12_TEMPLATE,\n            2: B12_TEMPLATE_V2,\n        },\n        renewal: {\n            1: B12_TEMPLATE,\n            2: B12_TEMPLATE_V2,\n        },\n    },\n    [PRODUCT_HREF.ED_GLOBAL]: {\n        intake: {\n            1: ED_TEMPLATE,\n            2: ED_TEMPLATE_V2,\n        },\n        renewal: {\n            1: ED_TEMPLATE,\n            2: ED_TEMPLATE_V2,\n        },\n    },\n    [PRODUCT_HREF.PEAK_CHEWS]: {\n        intake: {\n            1: ED_TEMPLATE,\n            2: ED_TEMPLATE_V2,\n        },\n        renewal: {\n            1: ED_TEMPLATE,\n            2: ED_TEMPLATE_V2,\n        },\n    },\n    [PRODUCT_HREF.RUSH_CHEWS]: {\n        intake: {\n            1: ED_TEMPLATE,\n            2: ED_TEMPLATE_V2,\n        },\n        renewal: {\n            1: ED_TEMPLATE,\n            2: ED_TEMPLATE_V2,\n        },\n    },\n    [PRODUCT_HREF.RUSH_MELTS]: {\n        intake: {\n            1: ED_TEMPLATE,\n            2: ED_TEMPLATE_V2,\n        },\n        renewal: {\n            1: ED_TEMPLATE,\n            2: ED_TEMPLATE_V2,\n        },\n    },\n    [PRODUCT_HREF.X_CHEWS]: {\n        intake: {\n            1: ED_TEMPLATE,\n            2: ED_TEMPLATE_V2,\n        },\n        renewal: {\n            1: ED_TEMPLATE,\n            2: ED_TEMPLATE_V2,\n        },\n    },\n    [PRODUCT_HREF.X_MELTS]: {\n        intake: {\n            1: ED_TEMPLATE,\n            2: ED_TEMPLATE_V2,\n        },\n        renewal: {\n            1: ED_TEMPLATE,\n            2: ED_TEMPLATE_V2,\n        },\n    },\n    [PRODUCT_HREF.TADALAFIL]: {\n        intake: {\n            1: ED_TEMPLATE,\n            2: ED_TEMPLATE_V2,\n        },\n        renewal: {\n            1: ED_TEMPLATE,\n            2: ED_TEMPLATE_V2,\n        },\n    },\n    [PRODUCT_HREF.SILDENAFIL]: {\n        intake: {\n            1: ED_TEMPLATE,\n            2: ED_TEMPLATE_V2,\n        },\n        renewal: {\n            1: ED_TEMPLATE,\n            2: ED_TEMPLATE_V2,\n        },\n    },\n    [PRODUCT_HREF.VIAGRA]: {\n        intake: {\n            1: ED_TEMPLATE,\n            2: ED_TEMPLATE_V2,\n        },\n        renewal: {\n            1: ED_TEMPLATE,\n            2: ED_TEMPLATE_V2,\n        },\n    },\n    [PRODUCT_HREF.CIALIS]: {\n        intake: {\n            1: ED_TEMPLATE,\n            2: ED_TEMPLATE_V2,\n        },\n        renewal: {\n            1: ED_TEMPLATE,\n            2: ED_TEMPLATE_V2,\n        },\n    },\n    [PRODUCT_HREF.TRETINOIN]: {\n        intake: {\n            1: SKIN_CARE_TEMPLATE,\n        },\n        renewal: {\n            1: SKIN_CARE_TEMPLATE,\n        },\n    },\n    [PRODUCT_HREF.FINASTERIDE_AND_MINOXIDIL]: {\n        intake: {\n            1: MINOXIDIL_FINASTERIDE_TEMPLATE,\n        },\n        renewal: {\n            1: MINOXIDIL_FINASTERIDE_TEMPLATE,\n        },\n    },\n    [PRODUCT_HREF.TELMISARTAN]: {\n        intake: {\n            1: TELMISARTAN_TEMPLATE,\n        },\n        renewal: {\n            1: TELMISARTAN_TEMPLATE,\n        },\n    },\n    [PRODUCT_HREF.ACARBOSE]: {\n        intake: {\n            1: ACARBOSE_TEMPLATE,\n        },\n        renewal: {\n            1: ACARBOSE_TEMPLATE,\n        },\n    },\n    [PRODUCT_HREF.CGM_SENSOR]: {\n        intake: {\n            1: CGM_SENSOR_TEMPLATE,\n        },\n        renewal: {\n            1: CGM_SENSOR_TEMPLATE,\n        },\n    },\n    [PRODUCT_HREF.ATORVASTATIN]: {\n        intake: {\n            1: ATORVASTATIN_TEMPLATE,\n        },\n        renewal: {\n            1: ATORVASTATIN_TEMPLATE,\n        },\n    },\n    [PRODUCT_HREF.ZOFRAN]: {\n        intake: {\n            1: ZOFRAN_TEMPLATE,\n        },\n        renewal: {\n            1: ZOFRAN_TEMPLATE,\n        },\n    },\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/clinical_notes/clinical_notes_v2.ts",
      "bioverse-client/app/utils/constants/clinical-note-template-product-map.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-creation-menu/note-creation-modal.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-templates/clinical-template-functions.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-creation-menu/creation-tab-content/note-creation/template-preview.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-components/clinical-template-render.tsx",
      "bioverse-client/_deprecated/clinical_notes_v1/collapsible-note-template.tsx",
      "bioverse-client/_deprecated/clinical_notes_v1/clinical-note-template-deprecated.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/constants/intake.ts",
    "exports": [
      {
        "name": "MEDICATION_DICTIONARY",
        "kind": "variable",
        "signature": "MEDICATION_DICTIONARY: MedicationDictionary = {\n    semaglutide: {\n        lowest_dosage: {\n            dosage: 0.25,\n            monthly_variant_index: 2,\n            bundle_variant_index: 12,\n        },\n        '0.25': {\n            dosage: 0.25,\n            monthly_variant_index: 2,\n            bundle_variant_index: 12,\n        },\n        '0.5': {\n            dosage: 0.5,\n            monthly_variant_index: 13,\n            bundle_variant_index: 8,\n        },\n        '1': {\n            dosage: 1,\n            monthly_variant_index: 14,\n            bundle_variant_index: 9,\n        },\n        '1.25': {\n            dosage: 1.25,\n            monthly_variant_index: 14,\n            bundle_variant_index: 7,\n        },\n        '1.75': {\n            dosage: 1.75,\n            monthly_variant_index: 5,\n            bundle_variant_index: 10,\n        },\n        '2.5': {\n            dosage: 2.5,\n            monthly_variant_index: 5,\n            bundle_variant_index: 10,\n        },\n    },\n    tirzepatide: {\n        lowest_dosage: {\n            dosage: 2.5,\n            monthly_variant_index: 3,\n            bundle_variant_index: 6,\n        },\n        '2.5': {\n            dosage: 2.5,\n            monthly_variant_index: 3,\n            bundle_variant_index: 6,\n        },\n        '5': {\n            dosage: 5,\n            monthly_variant_index: 4,\n            bundle_variant_index: 8,\n        },\n        '7.5': {\n            dosage: 7.5,\n            monthly_variant_index: 5,\n            bundle_variant_index: 9,\n        },\n        '10': {\n            dosage: 10,\n            monthly_variant_index: 15,\n            bundle_variant_index: 12,\n        },\n        '12.5': {\n            dosage: 12.5,\n            monthly_variant_index: 11,\n            bundle_variant_index: 13,\n        },\n    },\n}"
      },
      {
        "name": "MEDICATION_DICTIONARY_V3",
        "kind": "variable",
        "signature": "MEDICATION_DICTIONARY_V3: MedicationDictionaryV3 = {\n    semaglutide: {\n        lowest_dosage: {\n            dosage: 0.25,\n            monthly_variant_index: 2,\n            bundle_variant_index: 6,\n            biannual_variant_index: 68,\n            annual_variant_index: 37,\n        },\n        '0.25': {\n            dosage: 0.25,\n            monthly_variant_index: 2,\n            bundle_variant_index: 6,\n            biannual_variant_index: 68,\n            annual_variant_index: 37,\n        },\n        '0.5': {\n            dosage: 0.5,\n            monthly_variant_index: 13,\n            bundle_variant_index: 8,\n            biannual_variant_index: 70,\n            annual_variant_index: 39,\n        },\n        '1': {\n            dosage: 1,\n            monthly_variant_index: 14,\n            bundle_variant_index: 21,\n            biannual_variant_index: 72,\n        },\n        '1.25': {\n            dosage: 1.25,\n            monthly_variant_index: 14,\n            bundle_variant_index: 21,\n            biannual_variant_index: 72,\n            annual_variant_index: 41,\n        },\n        '1.75': {\n            dosage: 1.75,\n            monthly_variant_index: 5,\n            bundle_variant_index: 10,\n        },\n        '2.5': {\n            dosage: 2.5,\n            monthly_variant_index: 5,\n            bundle_variant_index: 10,\n        },\n    },\n    tirzepatide: {\n        lowest_dosage: {\n            dosage: 2.5,\n            monthly_variant_index: 3,\n            bundle_variant_index: 6,\n            biannual_variant_index: 59,\n            //annual_variant_index: 40,\n        },\n        '2.5': {\n            dosage: 2.5,\n            monthly_variant_index: 3,\n            bundle_variant_index: 6,\n            biannual_variant_index: 59,\n            //annual_variant_index: 40,\n        },\n        '5': {\n            dosage: 5,\n            monthly_variant_index: 4,\n            bundle_variant_index: 8,\n        },\n        '7.5': {\n            dosage: 7.5,\n            monthly_variant_index: 5,\n            bundle_variant_index: 9,\n        },\n        '10': {\n            dosage: 10,\n            monthly_variant_index: 10,\n            bundle_variant_index:\n                GLP1_NAMES_TO_INDEX.TIRZEPATIDE_QUARTERLY_136_MG_EMPOWER,\n            //biannual_variant_index: 25, //hallandale no longer offers tirzep\n        },\n        '12.5': {\n            dosage: 12.5,\n            monthly_variant_index: 11,\n            bundle_variant_index:\n                GLP1_NAMES_TO_INDEX.TIRZEPATIDE_QUARTERLY_170_MG_EMPOWER,\n        },\n    },\n    metformin: {\n        lowest_dosage: {\n            dosage: 1000,\n            monthly_variant_index: -1,\n            bundle_variant_index: 0,\n        },\n    },\n    [PRODUCT_HREF.WL_CAPSULE]: {\n        lowest_dosage: {\n            dosage: 10,\n            monthly_variant_index: 0,\n            bundle_variant_index: 1,\n        },\n    },\n}"
      },
      {
        "name": "MEDICATION_DICTIONARY_V3_CROSS_MAP",
        "kind": "variable",
        "signature": "MEDICATION_DICTIONARY_V3_CROSS_MAP: MedicationDictionaryV3CrossMap =\n    {\n        [PRODUCT_HREF.SEMAGLUTIDE]: {\n            '2.5': {\n                //2.5 mg tirzepatide = 0.5 mg semaglutide\n                dosage: 0.5,\n                monthly_variant_index: 13,\n                bundle_variant_index: 8,\n                biannual_variant_index: 19,\n                annual_variant_index: 39,\n            },\n            '5': {\n                //5 mg tirzepatide = 1.25 mg semaglutide\n                dosage: 1.25,\n                monthly_variant_index: 14,\n                bundle_variant_index: 21,\n                biannual_variant_index: 20,\n                annual_variant_index: 41,\n            },\n            '7.5': {\n                //7.5 mg tirzepatide = 1.25 mg semaglutide\n                dosage: 1.25,\n                monthly_variant_index: 14,\n                bundle_variant_index: 21,\n                biannual_variant_index: 20,\n                annual_variant_index: 41,\n            },\n            '10': {\n                //10 mg tirzepatide = 2.5 mg semaglutide\n                dosage: 2.5,\n                monthly_variant_index: 5,\n                bundle_variant_index: 10,\n            },\n            '12.5': {\n                //12.5 mg tirzepatide = 2.5 mg semaglutide\n                dosage: 2.5,\n                monthly_variant_index: 5,\n                bundle_variant_index: 10,\n            },\n        },\n        [PRODUCT_HREF.TIRZEPATIDE]: {\n            '0.25': {\n                //0.25 mg semaglutide = 2.5 mg tirzepatide\n                dosage: 2.5,\n                monthly_variant_index: 3,\n                bundle_variant_index: 6,\n                //biannual_variant_index: 27,\n                //annual_variant_index: 40,\n            },\n            '0.5': {\n                //0.5 mg semaglutide = 5 mg tirzepatide\n                dosage: 5,\n                monthly_variant_index: 4,\n                bundle_variant_index: 8,\n            },\n            '0.75': {\n                //0.75 mg semaglutide = 5 mg tirzepatide\n                dosage: 5,\n                monthly_variant_index: 4,\n                bundle_variant_index: 8,\n            },\n            '1': {\n                //1 mg semaglutide = 7.5 mg tirzepatide\n                dosage: 7.5,\n                monthly_variant_index: 5,\n                bundle_variant_index: 9,\n            },\n            '1.25': {\n                //1.25 mg semaglutide = 7.5 mg tirzepatide\n                dosage: 7.5,\n                monthly_variant_index: 5,\n                bundle_variant_index: 9,\n            },\n            '1.75': {\n                //1.75 mg semaglutide = 7.5 mg tirzepatide\n                dosage: 7.5,\n                monthly_variant_index: 5,\n                bundle_variant_index: 9,\n            },\n            '2.5': {\n                //2.5 mg semaglutide = 10 mg tirzepatide\n                dosage: 10,\n                monthly_variant_index: 10,\n                bundle_variant_index:\n                    GLP1_NAMES_TO_INDEX.TIRZEPATIDE_QUARTERLY_136_MG_EMPOWER,\n                //biannual_variant_index: 25,\n            },\n        },\n    }"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/constants/intake.ts",
      "bioverse-client/app/utils/actions/intake/wl-supply.ts",
      "bioverse-client/app/components/intake-v3/pages/wl-select-dosage-v3.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-select-dosage.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/constants/provider-portal/ProviderTasks.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/constants/templates/acarbose-templates.ts",
    "exports": [
      {
        "name": "ACARBOSE_TEMPLATE",
        "kind": "variable",
        "signature": "ACARBOSE_TEMPLATE: ClinicalNoteTemplate = {\n    version: 1,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                \"Pt agrees to asynchronous encounter via intake and consented to telehealth consent. Pt's identification confirmed via photo ID. Pt is determined to be appropriate for asynchronous care and is 18 or older\",\n                'Medication, allergies, med/surgical hx reviewed.',\n                'Denies diabetic ketoacidosis, liver cirrhosis, hx of IBD, colonic ulcerations, intestinal obstruction.',\n                'Pt denies breastfeeding.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx: Select all that applies:',\n            setting: 'Dx',\n            values: [\n                'R73.01 Impaired Fasting Glucose',\n                'R73.03 Pre-diabetes',\n                'E11.9 Type 2 diabetes mellitus without complications',\n                'R73.8 Hyperglycemia',\n                'E88.819 Insulin resistance',\n                'E66.01 Morbid Obesity due to excess calories',\n                'E66.3 Overweight',\n                'E66.9 Obesity',\n                'R63.5 Abnormal weight gain',\n                'Z72.3 Lack of physical exercise',\n                'Z83.3 Family history of diabetes mellitus',\n                'Z82.49 Family history of ischemic heart disease and other diseases of the circulatory system.',\n                'Z96.49 Presence of other endocrine implants',\n                'I10 Essential hypertension',\n                'Other',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'Acarbose (select one):',\n            values: [\n                'Approved. Follow-up in 3 months or prn.',\n                'Denied. Refer to PCP. ',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.DROPDOWN,\n            title: 'Dose: ',\n            values: [\n                '25 mg',\n                '25 mg prn (up to 8x/month)',\n                '25 mg BID',\n                '50 mg BID',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            title: '',\n            values: [\n                'Patient was provided information regarding medication instructions, precautions, side effects and lifestyle recommendations.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/constants/templates/acarbose-templates.ts",
      "bioverse-client/app/utils/constants/clinical-note-template-product-map.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/constants/templates/atorvastatin-templates.ts",
    "exports": [
      {
        "name": "ATORVASTATIN_TEMPLATE",
        "kind": "variable",
        "signature": "ATORVASTATIN_TEMPLATE: ClinicalNoteTemplate = {\n    version: 1,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                \"Patient agrees to asynchronous encounter via intake and consented to telehealth consent. Pt's identification confirmed via photo ID. Pt is determined to be appropriate for asynchronous care and is 18 or older\",\n                'Patient denies pregnancy/breastfeeding',\n                'Patient denies active liver disease or severe kidney disease',\n                'Medication, allergies, medical/surgical hx reviewed.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx: Select all that applies:',\n            setting: 'Dx',\n            values: [\n                'Z82.49 Family history of ischemic heart disease and other diseases of the circulatory system.',\n                'E78.00 Hypercholesterolemia',\n                'E78.1 Hypertriglyceridemia',\n                'E78.5 Hyperlipidemia',\n                'E88.81 Metabolic syndrome',\n                'E88.819 Insulin resistance',\n                'I10 Essential hypertension',\n                'R03.0 Elevated blood pressure reading',\n                'Other',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'Atorvastatin 10mg daily (select one):',\n            values: [\n                'Approved. Follow-up in 3 months or prn.',\n                'Denied. Refer to PCP. ',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            title: '',\n            values: [\n                'Patient was provided information regarding medication instructions, precautions, side effects and lifestyle recommendations.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/constants/templates/atorvastatin-templates.ts",
      "bioverse-client/app/utils/constants/clinical-note-template-product-map.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/constants/templates/b12-templates.ts",
    "exports": [
      {
        "name": "B12_TEMPLATE",
        "kind": "variable",
        "signature": "B12_TEMPLATE: ClinicalNoteTemplate = {\n    version: 1,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                'Patient agrees to asynchronous encounter via intake and consented to telehealth consent. Patients identification confirmed via photo ID. Patient is determined to be appropriate for asynchronous care and is 18 or older',\n                'Denies pregnancy/breastfeeding',\n                'Medications and allergies reviewed',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx: Select all that applies:',\n            setting: 'Dx',\n            values: [\n                'R41.9 Unspecified symptoms and signs involving cognitive functions and awareness',\n                'R53.8 Other malaise and fatigue',\n                'Other',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'B12 Injection: (Select one)',\n            values: [\n                'Approved. Follow-up in 3 months',\n                'Denied. Refer to PCP. ',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      },
      {
        "name": "B12_TEMPLATE_V2",
        "kind": "variable",
        "signature": "B12_TEMPLATE_V2: ClinicalNoteTemplate = {\n    version: 2,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                \"Pt agrees to asynchronous encounter via intake and consented to telehealth consent. Pt's identification confirmed via photo ID. Pt is determined to be appropriate for asynchronous care and is 18 or older\",\n                'Denies pregnancy/breastfeeding',\n                'Medications and allergies reviewed',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx: Select all that applies:',\n            setting: 'Dx',\n            values: [\n                'R41.9 Unspecified symptoms and signs involving cognitive functions and awareness',\n                'R53.8 Other malaise and fatigue',\n                'E56 Other vitamin deficiencies',\n                'Other',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'B12 Injection: (Select one)',\n            values: ['Approved. Follow-up in 3 months', 'Denied'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            title: '',\n            values: [\n                'Patient was provided information regarding medication instructions, precautions, side effects and lifestyle recommendations.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/constants/templates/b12-templates.ts",
      "bioverse-client/app/utils/constants/clinical-note-template-product-map.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/constants/templates/cgm-sensor-templates.ts",
    "exports": [
      {
        "name": "CGM_SENSOR_TEMPLATE",
        "kind": "variable",
        "signature": "CGM_SENSOR_TEMPLATE: ClinicalNoteTemplate = {\n    version: 1,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                \"Patient agrees to asynchronous encounter via intake and consented to telehealth consent. Pt's identification confirmed via photo ID. Pt is determined to be appropriate for asynchronous care and is 18 or older\",\n                'Patient denies pregnancy/breastfeeding',\n                'Medication, allergies, med/surgical history reviewed',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx: Select all that applies:',\n            setting: 'Dx',\n            values: [\n                'R73.01 Impaired Fasting Glucose',\n                'R73.03 Pre-diabetes',\n                'E11.9 Type 2 diabetes mellitus without complications',\n                'R73.8 Hyperglycemia',\n                'E88.819 Insulin resistance',\n                'E66.01 Morbid Obesity due to excess calories',\n                'E66.3 Overweight',\n                'E66.9 Obesity',\n                'R63.5 Abnormal weight gain',\n                'Z72.3 Lack of physical exercise',\n                'Z83.3 Family history of diabetes mellitus',\n                'Z82.49 Family history of ischemic heart disease and other diseases of the circulatory system.',\n                'Z96.49 Presence of other endocrine implants',\n                'I10 Essential hypertension',\n                'Other',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'CGM Freestyle libre (select one):',\n            values: [\n                'Approved. Follow-up in 3 months or prn.',\n                'Denied. Refer to PCP. ',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            title: '',\n            values: [\n                'Patient was provided information regarding medication instructions, precautions, side effects and lifestyle recommendations.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/constants/templates/cgm-sensor-templates.ts",
      "bioverse-client/app/utils/constants/clinical-note-template-product-map.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/constants/templates/ed-templates.ts",
    "exports": [
      {
        "name": "ED_TEMPLATE",
        "kind": "variable",
        "signature": "ED_TEMPLATE: ClinicalNoteTemplate = {\n    version: 1,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                'Patient agrees to asynchronous encounter via intake and consented to telehealth consent. Patients identification confirmed via photo ID. Patient is determined to be appropriate for asynchronous care and is 18 or older',\n                'Patient denies concomitant use of nitrates, \"poppers.\"',\n                'Patient denies serious heart, liver, or kidney problems.',\n                'Patient denies pregnancy/breastfeeding.',\n                'Patient is not on any CYP3A4 inhibitors.',\n                'Medical history, current medications and allergies reviewed.',\n                'Patient is a good candidate for ED medication.',\n                'Patient is aware not to take other ED medication within 24 hours of taking requested medicationl',\n                'Patient is counseled on potential side effects. ER/UC precautions given.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx (Select all that apply): ',\n            setting: 'Dx',\n            values: [\n                'N52.9 Male erectile dysfunction',\n                'F52.4 Premature ejaculation',\n                'None/Other (see note)',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            default: false,\n            title: 'Medication Approved:',\n            values: [\n                'Generic Cialis (tadalafil)',\n                'Generic Viagra (sildenafil)',\n                'Sildenafil/tadalafil',\n                'Sildenafil/oxytoxin',\n                'Tadalafil/oxytocin',\n                'Cialis',\n                'Viagra',\n                'None. Refer to PCP',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            default: false,\n            title: 'Dose (select one)',\n            values: [\n                '10 mg as needed',\n                '20 mg as needed',\n                '5 mg daily',\n                '10 mg daily',\n                '8.5 mg daily',\n                '36 mg daily',\n                '100iu/5mg daily',\n                '60 mg prn',\n                '100iu/5mg prn',\n                '5 mg prn',\n                '10 mg prn',\n                '25 mg prn',\n                '50 mg prn',\n                '81mg/12g prn',\n                '100 mg prn',\n                'N/A',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      },
      {
        "name": "ED_TEMPLATE_V2",
        "kind": "variable",
        "signature": "ED_TEMPLATE_V2: ClinicalNoteTemplate = {\n    version: 2,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                \"Patient agrees to asynchronous encounter via intake and consented to telehealth consent. Pt's identification confirmed via photo ID. Pt is determined to be appropriate for asynchronous care and is 18 or older\",\n                'Patient denies concomitant use of nitrates, \"poppers.\".',\n                'Patient denies serious heart, liver, or kidney problems.',\n                'Patient is not on any CYP3A4 inhibitors.',\n                'Medical history, current medications and allergies reviewed',\n                'Patient is a good candidate for ED medication.',\n                'Pt is aware not to take other ED medication within 24 hours of taking requested medication',\n                'Patient is counseled on potential side effects. ER/UC precautions given.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx (Select all that apply): ',\n            setting: 'Dx',\n            values: [\n                'N52.9 Male erectile dysfunction',\n                'F52.4 Premature ejaculation',\n                'None/Other (see note)',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            default: false,\n            title: 'Medication Approved:',\n            values: [\n                'Generic Cialis (tadalafil)',\n                'Generic Viagra (sildenafil)',\n                'Sildenafil/tadalafil',\n                'Sildenafil/oxytoxin',\n                'Tadalafil/oxytocin',\n                'Cialis',\n                'Viagra',\n                'None. Refer to PCP',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            default: false,\n            title: 'Dose (select one)',\n            values: [\n                '10 mg as needed',\n                '20 mg as needed',\n                '5 mg daily',\n                '10 mg daily',\n                '8.5 mg daily',\n                '36 mg daily',\n                '100iu/5mg daily',\n                '60 mg prn',\n                '100iu/5mg prn',\n                '5 mg prn',\n                '10 mg prn',\n                '25 mg prn',\n                '50 mg prn',\n                '81mg/12g prn',\n                '100 mg prn',\n                'N/A',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            title: '',\n            values: [\n                'Patient was provided information regarding medication instructions, precautions, side effects and lifestyle recommendations.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/constants/templates/nad-product-templates.ts",
      "bioverse-client/app/utils/constants/templates/ed-templates.ts",
      "bioverse-client/app/utils/constants/clinical-note-template-product-map.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/constants/templates/glp-1-templates.ts",
    "exports": [
      {
        "name": "GLP1_INTAKE_TEMPLATE",
        "kind": "variable",
        "signature": "GLP1_INTAKE_TEMPLATE: ClinicalNoteTemplate = {\n    version: 1,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                'Patient agrees to asynchronous encounter via intake and consented to telehealth consent. Patients identification confirmed via photo ID. Patient is determined to be appropriate for asynchronous care and is 18 or older',\n                'Patients medical intake (medical/ surgical history, current medications, and allergies) reviewed.',\n                'Patient does NOT have the following absolute contraindications: personal or family history of MEN2/ MTC, history of type 1 diabetes, history of pancreatitis, on insulin therapy, on a sulfonylurea.',\n                'Patient is NOT pregnant or breastfeeding.',\n                'Patient does NOT have a history of suicide attempts or active suicidal ideations.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Patient is approved for (select all that apply): ',\n            values: [\n                'Semaglutide',\n                'Tirzepatide',\n                'Ondansetron 4mg',\n                'None. Patient is not eligible for GLP-1s',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'Therapy status (select one): ',\n            values: ['Initiation', 'Continuation', 'Not applicable'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            default: false,\n            title: 'Titration schedule (select one): ',\n            values: ['Standard', 'Custom (Add in note)', 'Not applicable'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.DROPDOWN,\n            title: 'Starting Dose: ',\n            values: [\n                'Semaglutide 0.25mg',\n                'Semaglutide 0.5mg',\n                'Semaglutide 1.25mg',\n                'Semaglutide 2.5mg',\n                'Tirzepatide 2.5mg',\n                'Tirzepatide 5mg',\n                'Tirzepatide 7.5mg',\n                'Tirzepatide 10mg',\n                'Tirzepatide 12.5mg',\n                'None',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx (select all that apply): ',\n            setting: 'Dx',\n            custom: 'GLP1DX',\n            values: [\n                'E66.3 Overweight',\n                'E66.9 Obesity',\n                'E66.01 Morbid Obesity',\n                'E11.9 Type 2 Diabetes without complications',\n                'R73.03 Prediabetes',\n                'R73.01 Impaired Fasting Glucose',\n                'E88.81 Metabolic Syndrome',\n                'K21.9 GERD',\n                'E87.5 Hyperlipidemia',\n                'E78.1 Hypertriglyceridemia',\n                'I10.9 Essential Hypertension',\n                'I48.2 Chronic atrial fibrillation',\n                'N18.9 Chronic Kidney Disease',\n                'K76.0 NAFLD',\n                'E28.2 PCOS',\n                'F33.9 Major Depressive Disorder',\n                'F41.1 Generalized anxiety disorder',\n                'M79.2 Neuralgia and neuritis, unspecified',\n                'G47.33 Obstructive Sleep Apnea',\n                'M13.9 Osteoarthritis',\n                'M54.5 Low Back Pain, unspecified',\n                'M25.5 Pain in unspecified joint',\n                'Z72.4 Inappropriate Diet and Eating Habits',\n                'R11.0 Nausea',\n                'None of the above',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'Follow Up: ',\n            values: ['1 month', '3 month', 'N/A'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            custom: {\n                type: 'tooltip',\n                text: 'Standing Order',\n                hover: [\n                    'Patient is tolerating medication (mild side effects, lasting 1-2 days after injection), administered minimum of 2 injections, minimum duration of at least 14 days on a given dose, BMI ≥ 25, and:',\n                    'Losing < 6% of body weight in a month → Ok to increase, stay, or decrease the dose',\n                    'Losing ≥ 6% of body weight in a month → Decrease dose',\n                ],\n            },\n            values: ['Approved', 'Not approved (Add note)'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      },
      {
        "name": "GLP1_RENEWAL_TEMPLATE",
        "kind": "variable",
        "signature": "GLP1_RENEWAL_TEMPLATE: ClinicalNoteTemplate = {\n    version: 1,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                'Check-in reviewed',\n                'Medical history, medication and allergies reviewed and updated as needed',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'Plan (Select one): ',\n            values: [\n                'CONTINUE PROTOCOL. Patient is deemed suitable to continue on standard titration schedule.',\n                'DIFFERENT PROTOCOL. Titration schedule needs to be adjusted. Add note.',\n                'SWITCH MEDICATION. Patient is no longer approved to continue on current medication.',\n                'DISCONTINUE: Patient is not approved to continue on GLP1s',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.DROPDOWN,\n            title: 'Dose: ',\n            setting: 'dose-selection',\n            values: [\n                'Semaglutide 0.25mg',\n                'Semaglutide 0.5mg',\n                'Semaglutide 1mg',\n                'Semaglutide 1.25mg',\n                'Semaglutide 2.5mg',\n                'Tirzepatide 2.5mg',\n                'Tirzepatide 5mg',\n                'Tirzepatide 7.5mg',\n                'Tirzepatide 10mg',\n                'Tirzepatide 12.5mg',\n                'None',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'Follow-up (select one): ',\n            values: ['1 month', '3 month', 'N/A'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      },
      {
        "name": "GLP1_RENEWAL_TEMPLATE_V2",
        "kind": "variable",
        "signature": "GLP1_RENEWAL_TEMPLATE_V2: ClinicalNoteTemplate = {\n    version: 2,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                'Check-in reviewed',\n                'Medical history, medication and allergies reviewed and updated as needed',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'Plan (Select one): ',\n            values: [\n                'CONTINUE PROTOCOL. Patient is deemed suitable to continue on standard titration schedule.',\n                'DIFFERENT PROTOCOL. Titration schedule needs to be adjusted. Add note.',\n                'SWITCH MEDICATION. Patient is no longer approved to continue on current medication.',\n                'DISCONTINUE: Patient is not approved to continue on GLP1s',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            title: 'Dosing: ',\n            values: [\n                'Semaglutide 0.25mg',\n                'Semaglutide 0.5mg',\n                'Semaglutide 1.25mg',\n                'Semaglutide 2.5mg',\n                'Tirzepatide 2.5mg',\n                'Tirzepatide 5mg',\n                'Tirzepatide 7.5mg',\n                'Tirzepatide 10mg',\n                'Tirzepatide 12.5mg',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'Follow-up (select one): ',\n            values: ['1 month', '3 month', 'N/A'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      },
      {
        "name": "GLP1_INTAKE_TEMPLATE_V2",
        "kind": "variable",
        "signature": "GLP1_INTAKE_TEMPLATE_V2: ClinicalNoteTemplate = {\n    version: 2,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                `Patient agrees to asynchronous encounter via intake and consented to telehealth consent. Patient's identification confirmed via photo ID and selfie. Patient is determined to be appropriate for asynchronous care and is 18 or older`,\n                `Patient's medical intake (medical/ surgical history, current medications, and allergies) reviewed.`,\n                `Patient does NOT have the following absolute contraindications: personal or family history of MEN2/ MTC, history of type 1 diabetes, history of pancreatitis, on insulin therapy, on a sulfonylurea.`,\n                `Patient is NOT pregnant or breastfeeding.`,\n                `Patient does NOT have a history of suicide attempts or active suicidal ideations.`,\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx (select all that apply): ',\n            setting: 'Dx',\n            custom: 'GLP1DX',\n            values: [\n                'E66.3 Overweight',\n                'E66.9 Obesity',\n                'E66.01 Morbid Obesity',\n                'E11.9 Type 2 Diabetes without complications',\n                'R73.03 Prediabetes',\n                'R73.01 Impaired Fasting Glucose',\n                'E88.81 Metabolic Syndrome',\n                'K21.9 GERD',\n                'E87.5 Hyperlipidemia',\n                'E78.1 Hypertriglyceridemia',\n                'I10.9 Essential Hypertension',\n                'I48.2 Chronic atrial fibrillation',\n                'N18.9 Chronic Kidney Disease',\n                'K76.0 NAFLD',\n                'E28.2 PCOS',\n                'F33.9 Major Depressive Disorder',\n                'F41.1 Generalized anxiety disorder',\n                'M79.2 Neuralgia and neuritis, unspecified',\n                'G47.33 Obstructive Sleep Apnea',\n                'M13.9 Osteoarthritis',\n                'M54.5 Low Back Pain, unspecified',\n                'M25.5 Pain in unspecified joint',\n                'Z72.4 Inappropriate Diet and Eating Habits',\n                'R11.0 Nausea',\n                'None of the above',\n                'Other (Add in note)',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'WL treatment status (select one): ',\n            values: ['Initiation', 'Continuation', 'Not applicable'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Patient is approved for (select all that apply): ',\n            values: [\n                'Semaglutide',\n                'Tirzepatide',\n                'Metformin',\n                'Bioverse Weight Loss Capsules',\n                'Ondansetron 4mg',\n                'Pending (add note)',\n                'None. Patient is not eligible for any weight loss medications',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.DROPDOWN,\n            title: 'Starting Dose: ',\n            values: [\n                'Semaglutide 0.25mg',\n                'Semaglutide 0.5mg',\n                'Semaglutide 1mg',\n                'Semaglutide 1.25mg',\n                'Semaglutide 2.5mg',\n                'Tirzepatide 2.5mg',\n                'Tirzepatide 5mg',\n                'Tirzepatide 7.5mg',\n                'Tirzepatide 10mg',\n                'Tirzepatide 12.5mg',\n                'None',\n                'Other',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            default: false,\n            title: 'Pt is receiving: ',\n            values: [\n                '1-month supply',\n                '3-month supply',\n                '6-month supply',\n                'None. Pt is denied (Add denial reason in note)',\n                'Other. (Add a note)',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            custom: {\n                type: 'tooltip',\n                text: 'Standing Order',\n                hover: [\n                    'Patient with no reported side effects, administered minimum of 2 injections of a particular dose, minimum duration of at least 14 days on a given dose, BMI ≥ 22, and:',\n                    'Losing < 5% of body weight in a month → Eligible to increase, stay, or decrease dose',\n                    'Losing ≥ 5% of body weight in a month → Forward to provider',\n                ],\n            },\n            values: ['Approved', 'Not approved (Add note)'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            default: false,\n            title: 'Follow-up (select one): ',\n            values: ['1 month', '3 month', 'None. Refer to PCP'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            title: '',\n            values: [\n                'I have provided information regarding medication instructions, precautions, side effects and lifestyle recommendations to the patient.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      },
      {
        "name": "GLP1_RENEWAL_TEMPLATE_V3",
        "kind": "variable",
        "signature": "GLP1_RENEWAL_TEMPLATE_V3: ClinicalNoteTemplate = {\n    version: 3,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                'Check-in reviewed',\n                'Medical history, medication and allergies reviewed and updated as needed',\n                'Weight trends and side effects reviewed.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'Plan (Select one): ',\n            values: [\n                'CONTINUE PROTOCOL. Patient is deemed suitable to continue on standard titration schedule.',\n                'DIFFERENT PROTOCOL. Titration schedule needs to be adjusted. Add note.',\n                'SWITCH MEDICATION. Patient is no longer approved to continue on current medication.',\n                'DISCONTINUE: Patient is not approved to continue on GLP1s',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            title: 'Approved Dosage Options: ',\n            values: [\n                'Semaglutide 0.25mg',\n                'Semaglutide 0.5mg',\n                'Semaglutide 1mg',\n                'Semaglutide 1.25mg',\n                'Semaglutide 2.5mg',\n                'Tirzepatide 2.5mg',\n                'Tirzepatide 5mg',\n                'Tirzepatide 7.5mg',\n                'Tirzepatide 10mg',\n                'Tirzepatide 12.5mg',\n                'Other (Add in note)',\n                'None',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'Follow-up (select one): ',\n            values: [\n                '1 -month supply refill',\n                '3 -month supply refill',\n                '6 -month supply refill',\n                'Ondansetron prn nausea/vomiting',\n                'None. This is a check-in',\n                'None. Patient to discontinue WL medication',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            custom: {\n                type: 'tooltip',\n                text: 'Standing Order',\n                hover: [\n                    'Patient with no reported side effects, administered minimum of 2 injections of a particular dose, minimum duration of at least 14 days on a given dose, BMI ≥ 22, and:',\n                    'Losing < 5% of body weight in a month → Eligible to increase, stay, or decrease dose',\n                    'Losing ≥ 5% of body weight in a month → Forward to provider',\n                ],\n            },\n            values: ['Approved', 'Not approved (Add note)'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            default: false,\n            title: 'Follow-up (select one): ',\n            values: ['1 month', '3 month', 'None. Refer to PCP', 'N/A'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            title: '',\n            values: [\n                'I have provided information regarding medication instructions, precautions, side effects and lifestyle recommendations to the patient.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/constants/templates/glp-1-templates.ts",
      "bioverse-client/app/utils/constants/clinical-note-template-product-map.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/constants/templates/glutathione-injection-templates.ts",
    "exports": [
      {
        "name": "GLUTATHIONE_INJECTION_TEMPLATE",
        "kind": "variable",
        "signature": "GLUTATHIONE_INJECTION_TEMPLATE: ClinicalNoteTemplate = {\n    version: 1,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                'Patient agrees to asynchronous encounter via intake and consented to telehealth consent. Patients identification confirmed via photo ID. Patient is determined to be appropriate for asynchronous care and is 18 or older',\n                'No sulfa allergy or milk intolerance',\n                'Denies pregnancy/breastfeeding',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx: Select all that applies: ',\n            setting: 'Dx',\n            values: [\n                'L81.4 Melanin hyperpigmentation',\n                'R23.4 Changes in skin texture',\n                'R53.8 Other malaise and fatigue',\n                'R63.5 Abnormal weight gain',\n                'E88.819 Insulin resistance',\n                'R41.9 Unspecified symptoms and signs involving cognitive functions and awareness',\n                'Other',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'Glutathione Injection: (Select one)',\n            values: [\n                'Approved. Follow-up in 3 months',\n                'Denied. Refer to PCP. ',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      },
      {
        "name": "GLUTATHIONE_INJECTION_TEMPLATE_V2",
        "kind": "variable",
        "signature": "GLUTATHIONE_INJECTION_TEMPLATE_V2: ClinicalNoteTemplate = {\n    version: 2,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                \"Pt agrees to asynchronous encounter via intake and consented to telehealth consent. Pt's identification confirmed via photo ID. Pt is determined to be appropriate for asynchronous care and is 18 or older\",\n                'No sulfa allergy or milk intolerance',\n                'Denies pregnancy/breastfeeding',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx: Select all that applies: ',\n            setting: 'Dx',\n            values: [\n                'L81.4 Melanin hyperpigmentation',\n                'R23.4 Changes in skin texture',\n                'R53.8 Other malaise and fatigue',\n                'R63.5 Abnormal weight gain',\n                'E88.819 Insulin resistance',\n                'R41.9 Unspecified symptoms and signs involving cognitive functions and awareness',\n                'E56 Other vitamin deficiencies',\n                'Other',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'Glutathione Injection: (Select one)',\n            values: ['Approved. Follow-up in 3 months', 'Denied'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            title: '',\n            values: [\n                'Patient was provided information regarding medication instructions, precautions, side effects and lifestyle recommendations.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/constants/templates/glutathione-injection-templates.ts",
      "bioverse-client/app/utils/constants/clinical-note-template-product-map.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/constants/templates/metformin-templates.ts",
    "exports": [
      {
        "name": "METFORMIN_TEMPLATE",
        "kind": "variable",
        "signature": "METFORMIN_TEMPLATE: ClinicalNoteTemplate = {\n    version: 1,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                'Patient agrees to asynchronous encounter via intake and consented to telehealth consent. Patients identification confirmed via photo ID. Patient is determined to be appropriate for asynchronous care and is 18 or older',\n                'Patient denies pregnancy/breastfeeding.',\n                'Denies severe renal/hepatic disease, congestive heart failure, acute/chronic metabolic acidosis. ',\n                'Patient denies pregnancy/breastfeeding.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx (Select all that apply): ',\n            setting: 'Dx',\n            values: [\n                'R63.8 Other symptoms and signs concerning food and fluid intake',\n                'R73.01 Impaired Fasting Glucose',\n                'R73.03 Pre-diabetes',\n                'E11.9 Type 2 diabetes mellitus without complications',\n                'R73.8 Hyperglycemia',\n                'E88.819 Insulin resistance',\n                'E66.01 Morbid Obesity due to excess calories',\n                'E66.3 Overweight',\n                'E66.9 Obesity',\n                'E28.2 Polycystic ovarian syndrome',\n                'Z72.3 Lack of physical exercise',\n                'Z72.4 Inappropriate diet and eating habits',\n                'Z83.3 Family history of diabetes mellitus',\n                'Z82.49 Family history of ischemic heart disease and other diseases of the circulatory system',\n                'I10 Essential hypertension',\n                'Other',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            default: false,\n            title: 'Metformin (select one)',\n            values: ['Approved', 'Denied. Refer to PCP'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            default: false,\n            title: 'Dose (select one)',\n            values: ['500 mg', '850 mg', '1000 mg (default)', '1500 mg'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      },
      {
        "name": "METFORMIN_TEMPLATE_V2",
        "kind": "variable",
        "signature": "METFORMIN_TEMPLATE_V2: ClinicalNoteTemplate = {\n    version: 2,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                'Patient agrees to asynchronous encounter via intake and consented to telehealth consent. Patients identification confirmed via photo ID. Patient is determined to be appropriate for asynchronous care and is 18 or older',\n                'Patient denies pregnancy/breastfeeding.',\n                'Denies severe renal/hepatic disease, congestive heart failure, acute/chronic metabolic acidosis. ',\n                'Patient denies pregnancy/breastfeeding.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx: Select all that applies:',\n            setting: 'Dx',\n            values: [\n                'R63.8 Other symptoms and signs concerning food and fluid intake',\n                'R73.01 Impaired Fasting Glucose',\n                'R73.03 Pre-diabetes',\n                'R73.8 Hyperglycemia',\n                'E11.9 Type 2 diabetes mellitus without complications',\n                'E88.819 Insulin resistance',\n                'E66.01 Morbid Obesity due to excess calories',\n                'E66.3 Overweight',\n                'E66.9 Obesity',\n                'E28.2 Polycystic ovarian syndrome',\n                'Z72.3 Lack of physical exercise',\n                'Z72.4 Inappropriate diet and eating habits',\n                'Z83.3 Family history of diabetes mellitus',\n                'Z82.49 Family history of ischemic heart disease and other diseases of the circulatory system',\n                'I10 Essential hypertension',\n                'Z00: Encounter for general examination without complaint, suspected or reported diagnosis',\n                'Other (add in note)',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            default: false,\n            title: 'Lab required? (select one)',\n            values: ['Before initiation AND annually', 'Annually'],\n        },\n\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            default: false,\n            title: 'Prescription is (select one): ',\n            values: ['Approved', 'Pending (add note)', 'Denied. Refer to PCP'],\n        },\n\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            default: false,\n            custom: {\n                defaultSelectValue: '1000 mg',\n            },\n            title: 'Dose (select one): ',\n            values: ['500 mg', '850 mg', '1000 mg', '1500 mg', 'N/A'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            title: '',\n            values: [\n                'I have provided information regarding medication instructions, precautions, side effects and lifestyle recommendations to the patient.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/constants/templates/metformin-templates.ts",
      "bioverse-client/app/utils/constants/clinical-note-template-product-map.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/constants/templates/minoxidil-finasteride-templates.ts",
    "exports": [
      {
        "name": "MINOXIDIL_FINASTERIDE_TEMPLATE",
        "kind": "variable",
        "signature": "MINOXIDIL_FINASTERIDE_TEMPLATE: ClinicalNoteTemplate = {\n    version: 1,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                \"Patient agrees to asynchronous encounter via intake and consented to telehealth consent. Pt's identification confirmed via photo ID. Pt is determined to be appropriate for asynchronous care and is 18 or older\",\n                'Medication, allergies, med/surgical hx reviewed.',\n                'Denies history of liver issues, high-grade prostate cancer, depression or sexual dysfunction.',\n                'Pt denies burning pain, patches of rough, scaly skin, or scarring, pustules or crusting on scalp.',\n                '(Female) Patient is postmenopausal',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx: Select all that applies:',\n            setting: 'Dx',\n            values: [\n                'L64.9 Androgenic alopecia',\n                'L65.9 Nonscarring hair loss, unspecified',\n                'Other',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'Topical Minoxidil Spray/Finasteride 6%/0.25% (select one):',\n            values: [\n                'Approved. Follow up in 6 months or prn.',\n                'Denied. Refer to PCP. ',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            title: '',\n            values: [\n                'Patient was provided information regarding medication instructions, precautions, side effects and lifestyle recommendations.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/constants/templates/minoxidil-finasteride-templates.ts",
      "bioverse-client/app/utils/constants/clinical-note-template-product-map.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/constants/templates/nad-product-templates.ts",
    "exports": [
      {
        "name": "NAD_INJECTION_TEMPLATE",
        "kind": "variable",
        "signature": "NAD_INJECTION_TEMPLATE: ClinicalNoteTemplate = {\n    version: 1,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                'Patient agrees to asynchronous encounter via intake and consented to telehealth consent. Patients identification confirmed via photo ID. Patient is determined to be appropriate for asynchronous care and is 18 or older',\n                'Denies pregnancy/breastfeeding',\n                'No liver or kidney disease',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx: Select all that applies:',\n            setting: 'Dx',\n            values: [\n                'R41.9 Unspecified symptoms and signs involving cognitive functions and awareness',\n                'R53.8 Other malaise and fatigue',\n                'F39 Unspecified mood disorder',\n                'Other',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'NAD Injection: (Select one)',\n            values: [\n                'Approved. Follow-up in 3 months',\n                'Denied. Refer to PCP. ',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      },
      {
        "name": "NAD_PATCHES_TEMPLATE",
        "kind": "variable",
        "signature": "NAD_PATCHES_TEMPLATE: ClinicalNoteTemplate = {\n    version: 1,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                'Patient agrees to asynchronous encounter via intake and consented to telehealth consent. Patients identification confirmed via photo ID. Patient is determined to be appropriate for asynchronous care and is 18 or older',\n                'Denies pregnancy/breastfeeding',\n                'No liver or kidney disease',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx: Select all that applies:',\n            setting: 'Dx',\n            values: [\n                'R41.9 Unspecified symptoms and signs involving cognitive functions and awareness',\n                'R53.8 Other malaise and fatigue',\n                'F39 Unspecified mood disorder',\n                'Other',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'NAD Patches: (Select one)',\n            values: [\n                'Approved. Follow-up in 3 months',\n                'Denied. Refer to PCP. ',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      },
      {
        "name": "NAD_NASAL_SPRAY_TEMPLATE",
        "kind": "variable",
        "signature": "NAD_NASAL_SPRAY_TEMPLATE: ClinicalNoteTemplate = {\n    version: 1,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                'Patient agrees to asynchronous encounter via intake and consented to telehealth consent. Patients identification confirmed via photo ID. Patient is determined to be appropriate for asynchronous care and is 18 or older',\n                'Denies pregnancy/breastfeeding',\n                'No liver or kidney disease',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx: Select all that applies:',\n            setting: 'Dx',\n            values: [\n                'R41.9 Unspecified symptoms and signs involving cognitive functions and awareness',\n                'R53.8 Other malaise and fatigue',\n                'F39 Unspecified mood disorder',\n                'Other',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'NAD Nasal Spray: (Select one)',\n            values: [\n                'Approved. Follow-up in 3 months',\n                'Denied. Refer to PCP. ',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      },
      {
        "name": "NAD_COMBINED_TEMPLATE_V2",
        "kind": "variable",
        "signature": "NAD_COMBINED_TEMPLATE_V2: ClinicalNoteTemplate = {\n    version: 2,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                \"Pt agrees to asynchronous encounter via intake and consented to telehealth consent. Pt's identification confirmed via photo ID. Pt is determined to be appropriate for asynchronous care and is 18 or older\",\n                'Pt denies pregnancy/breastfeeding.',\n                'No liver or kidney disease',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx: Select all that applies:',\n            setting: 'Dx',\n            values: [\n                'R41.9 Unspecified symptoms and signs involving cognitive functions and awareness',\n                'R53.8 Other malaise and fatigue',\n                'F39 Unspecified mood disorder',\n                'Other',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.DROPDOWN,\n            title: 'NAD+ (select-one):',\n            values: ['Injections', 'Patches', 'Nasal Spray'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: ' ',\n            values: ['Approved. Follow-up in 3 months', 'Denied'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            title: '',\n            values: [\n                'Patient was provided information regarding medication instructions, precautions, side effects and lifestyle recommendations.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/constants/templates/nad-product-templates.ts",
      "bioverse-client/app/utils/constants/clinical-note-template-product-map.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/constants/templates/skin-care-templates.ts",
    "exports": [
      {
        "name": "SKIN_CARE_TEMPLATE",
        "kind": "variable",
        "signature": "SKIN_CARE_TEMPLATE: ClinicalNoteTemplate = {\n    version: 1,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                \"Patient agrees to asynchronous encounter via intake and consented to telehealth consent. Pt's identification confirmed via photo ID. Pt is determined to be appropriate for asynchronous care and is 18 or older\",\n                'Patient denies pregnancy/breastfeeding.',\n                'Medication, allergies, med/surgical hx reviewed.',\n                'Patient denied facial eczema, psoriasis, open lesions or photosensitivity,',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx:',\n            setting: 'Dx',\n            values: [\n                'L90.0 Atrophic disorder of skin',\n                'L70.9 Acne',\n                'L81.4 Melanin hyperpigmentation',\n                'L90.5 Scar conditions and fibrosis of skin',\n                'R23.4 Changes in skin texture',\n                'L98.8 Other specified disorders of the skin and subcutaneous tissue',\n                'Other',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'Anti-aging cream:',\n            values: [\n                'Approved. Follow-up in 3 months or prn',\n                'Denied. Refer to PCP. ',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.DROPDOWN,\n            title: 'Topical approved (select one):',\n            values: [\n                'Tretinoin 0.015% / Azelaic Acid 4% / Niacinamide 4%',\n                'Tretinoin 0.03% / Azelaic Acid 4% / Niacinamide 4%',\n                'Tretinoin 0.067% / Azelaic Acid 4% / Niacinamide 4%',\n                'NAD+ 10%',\n                'None. Refer to PCP',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            title: '',\n            values: [\n                'Patient was provided information regarding medication instructions, precautions, side effects and lifestyle recommendations.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/constants/templates/skin-care-templates.ts",
      "bioverse-client/app/utils/constants/clinical-note-template-product-map.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/constants/templates/telmisartan-templates.ts",
    "exports": [
      {
        "name": "TELMISARTAN_TEMPLATE",
        "kind": "variable",
        "signature": "TELMISARTAN_TEMPLATE: ClinicalNoteTemplate = {\n    version: 1,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                \"Patient agrees to asynchronous encounter via intake and consented to telehealth consent. Pt's identification confirmed via photo ID. Pt is determined to be appropriate for asynchronous care and is 18 or older\",\n                'Patient denies pregnancy/breastfeeding.',\n                'Medication, allergies, med/surgical hx reviewed. Pt is not on aliskiren (Tekturna)',\n                'Patient denies severe liver, kidney, heart disease.',\n                'Patient reports blood pressure reading within 6 months between 130-160/80-110. (For patients 65+ bp range 140-160/80-110)',\n                'Denies CP, SOB, dizziness, severe headaches',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx: Select all that applies:',\n            setting: 'Dx',\n            values: [\n                'I10 Essential hypertension',\n                'R03.0 Elevated blood pressure reading',\n                'Z82.49 Family history of ischemic heart disease and other diseases of the circulatory system.',\n                'E88.81 Metabolic syndrome',\n                'E78.5 Hyperlipidemia',\n                'R73.01 Impaired Fasting Glucose',\n                'R73.03 Pre-diabetes',\n                'E11.9 Type 2 diabetes mellitus without complications',\n                'E78.00 Hypercholesterolemia',\n                'E78.1 Hypertriglyceridemia',\n                'E88.819 Insulin resistance',\n                'Other',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            title: 'Telmisartan 20mg (select one):',\n            values: [\n                'Approved. Follow-up in 3 months or prn.',\n                'Denied. Refer to PCP. ',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            title: '',\n            values: [\n                'Patient was provided information regarding medication instructions, precautions, side effects and lifestyle recommendations.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/constants/templates/telmisartan-templates.ts",
      "bioverse-client/app/utils/constants/clinical-note-template-product-map.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/constants/templates/wl-capsule-templates.ts",
    "exports": [
      {
        "name": "WL_CAPSULE_TEMPLATE",
        "kind": "variable",
        "signature": "WL_CAPSULE_TEMPLATE: ClinicalNoteTemplate = {\n    version: 1,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                'Patient agrees to asynchronous encounter via intake and consented to telehealth consent. Patients identification confirmed via photo ID. Patient is determined to be appropriate for asynchronous care and is 18 or older',\n                'Patient denies pregnancy/breastfeeding.',\n                'Medications and allergies reviewed. No concurrent use of opioids, MAOIs, bupropion, naltrexone, topiramate.',\n                'Denies epilepsy, glaucoma, current/past suicidal ideations, severe liver disease, current/past eating disorder, kidney issues, acute porphyria',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx: Select all that applies: ',\n            setting: 'Dx',\n            values: [\n                'E66.01 Morbid Obesity due to excess calories',\n                'E66.3 Overweight',\n                'E66.9 Obesity',\n                'Z72.4 Inappropriate Diet and Eating Habits',\n                'R63.5 Abnormal weight gain',\n                'Other',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            default: false,\n            title: 'Visit Type',\n            values: ['Initiation', 'Continuation'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            default: false,\n            title: 'Bupropion/Naltrexone/Topiramate approved (select one)',\n            values: ['Follow up in 1 month', 'Follow up in 3 months', 'Denied'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      },
      {
        "name": "WL_CAPSULE_TEMPLATE_V2",
        "kind": "variable",
        "signature": "WL_CAPSULE_TEMPLATE_V2: ClinicalNoteTemplate = {\n    version: 2,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            values: [\n                \"Pt agrees to asynchronous encounter via intake and consented to telehealth consent. Pt's identification confirmed via photo ID. Pt is determined to be appropriate for asynchronous care and is 18 or older\",\n                'Pt denies pregnancy/breastfeeding.',\n                'Medications and allergies reviewed. No concurrent use of opioids, MAOIs, bupropion, naltrexone, topiramate.',\n                'Denies epilepsy, glaucoma, current/past suicidal ideations, severe liver disease, current/past eating disorder, kidney issues, acute porphyria',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: false,\n            title: 'Dx: Select all that applies: ',\n            setting: 'Dx',\n            values: [\n                'E66.01 Morbid Obesity due to excess calories',\n                'E66.3 Overweight',\n                'E66.9 Obesity',\n                'Z72.4 Inappropriate Diet and Eating Habits',\n                'R63.5 Abnormal weight gain',\n                'Other',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            default: false,\n            title: 'Visit Type',\n            values: ['Initiation', 'Continuation'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            default: false,\n            title: 'Bupropion/Naltrexone/Topiramate approved (select one)',\n            values: ['Follow up in 1 month', 'Follow up in 3 months', 'Denied'],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            title: '',\n            values: [\n                'Patient was provided information regarding medication instructions, precautions, side effects and lifestyle recommendations.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/constants/templates/wl-capsule-templates.ts",
      "bioverse-client/app/utils/constants/clinical-note-template-product-map.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/constants/templates/zofran-templates.ts",
    "exports": [
      {
        "name": "ZOFRAN_TEMPLATE",
        "kind": "variable",
        "signature": "ZOFRAN_TEMPLATE: ClinicalNoteTemplate = {\n    version: 1,\n    render: [\n        {\n            type: ClinicalNoteTemplateOptionType.SELECT,\n            default: false,\n            title: 'Pt requesting ondansetron for nausea from GLP-1 therapy. Medical history, medications, and allergies reviewed. (Select one)',\n            values: [\n                'Rx approved. Dispense #10. Follow up prn.',\n                'Rx approved. Dispense #20. Follow up prn.',\n                'Rx denied. (Add note)',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.MULTISELECT,\n            default: true,\n            title: '',\n            values: [\n                'Patient was provided information regarding medication instructions, precautions, side effects and lifestyle recommendations.',\n            ],\n        },\n        {\n            type: ClinicalNoteTemplateOptionType.NOTE,\n            values: [],\n        },\n    ],\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/constants/templates/zofran-templates.ts",
      "bioverse-client/app/utils/constants/clinical-note-template-product-map.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/api-controller/discounts/database-discounts-api.ts",
    "exports": [
      {
        "name": "getNonGLPDiscountForProduct",
        "kind": "function",
        "signature": "export async function getNonGLPDiscountForProduct(product_href: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const tableName =\n        process.env.NEXT_PUBLIC_ENVIRONMENT === 'prod'\n            ? 'stripe_product_coupon_pairs_production'\n            : 'stripe_product_coupon_pairs';\n\n    const { data: monthlyDiscount, error: monthlyDiscountError } =\n        await supabase\n            .from(tableName)\n            .select('coupon_id')\n            .eq('product_href', product_href)\n            .eq('cadence', 'monthly')\n            .limit(1)\n            .single();\n\n    const { data: quarterlyDiscount, error: quarterlyDiscountError } =\n        await supabase\n            .from(tableName)\n            .select('coupon_id')\n            .eq('product_href', product_href)\n            .eq('cadence', 'quarterly')\n            .limit(1)\n            .single();\n\n    return {\n        monthlyDiscount: monthlyDiscount?.coupon_id,\n        quarterlyDiscount: quarterlyDiscount?.coupon_id,\n    };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/api-controller/discounts/database-discounts-api.ts",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/select-supply-ap/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/select-supply/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/select-supply-v3/page.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/api-controller/order_management/admin-order-management.ts",
    "exports": [
      {
        "name": "getAdminOrderManagementData",
        "kind": "function",
        "signature": "export async function getAdminOrderManagementData(\n    startDate?: Date,\n    endDate?: Date,\n) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select(\n            `\n      *,\n      product:products!product_href (\n        name\n      ),\n      patient:profiles!customer_uid (\n        first_name,\n        last_name,\n        date_of_birth,\n        address_line1,\n        address_line2,\n        city,\n        zip,\n        state,\n        phone_number,\n        email,\n        license_photo_url,\n        selfie_photo_url,\n        sex_at_birth,\n        stripe_customer_id\n      )\n      `,\n        )\n        .in('order_status', [\n            // 'Unapproved-NoCard', //this and the two below are disabled for early stages until more is added on payment failure paths.\n            'Unapproved-CardDown',\n            // 'Approved-NoCard',\n            'Approved-CardDown',\n            'Pending-Customer-Response',\n            'Denied-CardDown',\n            // 'Denied-NoCard',\n            'Approved-NoCard',\n            'Payment-Completed',\n            'Payment-Declined',\n            'Canceled',\n            'Incomplete',\n            'Approved-NoCard-Finalized',\n            'Approved-CardDown-Finalized',\n            'Order-Processing',\n            'Administrative-Cancel',\n        ])\n        .eq('environment', process.env.NEXT_PUBLIC_ENVIRONMENT)\n        // .or(`assigned_provider.eq.${providerId}, assigned_provider.is.${null}`) //temporarily disabled because maylin cannot see.\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.log(error);\n        return { error: error, data: null };\n    }\n\n    let filteredData = data;\n\n    if (startDate && endDate) {\n        filteredData = data.filter((order) => {\n            const orderDate = new Date(order.created_at);\n            const isWithinRange =\n                orderDate >= (startDate ?? new Date('01-01-2024')) &&\n                orderDate <= (endDate ?? new Date());\n            return isWithinRange;\n        });\n    }\n\n    return { data: filteredData, error: null };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(administration)/admin/order-administration/_components/administrator-order-table.tsx",
      "bioverse-client/app/utils/database/api-controller/order_management/admin-order-management.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/api-controller/product_prices/product-prices.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/api-controller/products/products.ts",
    "exports": [
      {
        "name": "getProductData",
        "kind": "function",
        "signature": "export async function getProductData(product_href: string, fields: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('products')\n        .select(fields)\n        .eq('href', product_href)\n        .single();\n\n    if (error || !data) {\n        console.error(\n            'Error fetching product data',\n            error,\n            product_href,\n            fields,\n        );\n        return null;\n    }\n\n    return data;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/api-controller/products/products.ts",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-supply/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-supply-v2/page.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/action-items/action-items-actions.ts",
    "exports": [
      {
        "name": "createActionItem",
        "kind": "function",
        "signature": "export async function createActionItem(\n    user_id: string,\n    action_item_type: string,\n    subscription_id: number\n): Promise<ActionItemType | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const actionItem = new ActionItemFactory(action_item_type);\n\n    const { data: preCheckData, error: preCheckError } = await supabase\n        .from('action_items')\n        .select('*')\n        .eq('type', action_item_type)\n        .eq('patient_id', user_id)\n        .maybeSingle();\n\n    if (preCheckData && !preCheckError) {\n        return preCheckData as ActionItemType;\n    }\n\n    // Get question set version\n    const { data: productData, error: productError } = await supabase\n        .from('products')\n        .select('checkup_questionnaire_set_version')\n        .eq('href', actionItem.product_href)\n        .single();\n\n    if (productError) {\n        console.error(\n            'ERROR: Unable to fetch question set version',\n            user_id,\n            subscription_id,\n            action_item_type\n        );\n        await triggerEvent(OLIVIER_ID, NEW_BUG);\n        return null;\n    }\n\n    if (isEmpty(productData) || !productData) {\n        console.error(\n            'Unable to fetch checkup question set version',\n            user_id,\n            subscription_id,\n            action_item_type\n        );\n        await triggerEvent(OLIVIER_ID, NEW_BUG);\n        return null;\n    }\n\n    const { data, error } = await supabase\n        .from('action_items')\n        .insert({\n            type: action_item_type,\n            patient_id: user_id,\n            subscription_id,\n            action_type: ActionType.CheckUp,\n            product_href: actionItem.getProductHref(),\n            iteration: actionItem.getIteration(),\n            question_set_version: productData.checkup_questionnaire_set_version,\n        })\n        .select();\n\n    if (error) {\n        console.error('Unable to create action item', error, user_id);\n        return null;\n    }\n\n    let action_item_data = data[0];\n\n    const questionnaire_session_id = await createQuestionnaireSessionForCheckup(\n        user_id,\n        data[0].id\n    );\n\n    if (questionnaire_session_id) {\n        action_item_data.questionnaire_session_id = questionnaire_session_id;\n    }\n\n    if (isEmpty(data)) {\n        return null;\n    }\n    return action_item_data as ActionItemType;\n}"
      },
      {
        "name": "createDosageSelectionActionItem",
        "kind": "function",
        "signature": "export async function createDosageSelectionActionItem(\n    user_id: string,\n    product_href: PRODUCT_HREF,\n    subscription_id: number\n) {\n    // type: dosage-selection\n    // product_href\n    // action_type: dosage-selection\n\n    const supabase = createSupabaseServiceClient();\n\n    const shouldCreateActionItem =\n        await doesUserHaveActiveActionItemForDosageSelectionProduct(\n            user_id,\n            product_href\n        );\n\n    if (shouldCreateActionItem) {\n        console.log('not creating');\n        return;\n    }\n    console.log('creating');\n\n    await supabase.from('action_items').insert({\n        patient_id: user_id,\n        active: true,\n        subscription_id,\n        product_href,\n        action_type: ActionType.DosageSelection,\n        iteration: 1,\n        question_set_version: 1,\n        type: `${product_href}-dosage_selection`, // I know, I know its terrible and redundant.\n    });\n}"
      },
      {
        "name": "doesUserHaveActiveActionItemForDosageSelectionProduct",
        "kind": "function",
        "signature": "export async function doesUserHaveActiveActionItemForDosageSelectionProduct(\n    user_id: string,\n    product_href: PRODUCT_HREF\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('action_items')\n        .select('*')\n        .eq('action_type', 'dosage_selection')\n        .eq('active', true)\n        .eq('product_href', product_href)\n        .eq('patient_id', user_id);\n\n    if (error) {\n        console.error(\n            'Error doesUserHaveActiveActionItemForDosageSelectionProduct',\n            error\n        );\n        return false;\n    }\n\n    if (!data) {\n        return false;\n    }\n\n    return data.length > 0;\n}"
      },
      {
        "name": "clearDosageSelectionActionItems",
        "kind": "function",
        "signature": "export async function clearDosageSelectionActionItems(\n    user_id: string,\n    product_href: PRODUCT_HREF\n) {\n    const supabase = createSupabaseServiceClient();\n\n    await supabase\n        .from('action_items')\n        .update({ active: false })\n        .eq('patient_id', user_id)\n        .eq('product_href', product_href)\n        .eq('action_type', ActionType.DosageSelection);\n}"
      },
      {
        "name": "getActionItems",
        "kind": "function",
        "signature": "export async function getActionItems(\n    user_id: string | undefined\n): Promise<ActionItemType[]> {\n    const supabase = createSupabaseServiceClient();\n\n    if (!user_id) {\n        return [];\n    }\n\n    const { data, error } = await supabase\n        .from('action_items')\n        .select('*')\n        .eq('patient_id', user_id)\n        .eq('active', true);\n\n    if (!data || error) {\n        console.error(\n            'Unable to retrieve action items for user',\n            error,\n            user_id\n        );\n        return [];\n    }\n    return data as ActionItemType[];\n}"
      },
      {
        "name": "getAllActionItems",
        "kind": "function",
        "signature": "export async function getAllActionItems(\n    user_id: string | undefined\n): Promise<ActionItemType[]> {\n    const supabase = createSupabaseServiceClient();\n\n    if (!user_id) {\n        return [];\n    }\n\n    const { data, error } = await supabase\n        .from('action_items')\n        .select('*')\n        .eq('patient_id', user_id)\n        .order('created_at');\n\n    if (!data || error) {\n        console.error(\n            'Unable to retrieve action items for user',\n            error,\n            user_id\n        );\n        return [];\n    }\n    return data as ActionItemType[];\n}"
      },
      {
        "name": "getAllActionsItemsForPatientWithSession",
        "kind": "function",
        "signature": "export async function getAllActionsItemsForPatientWithSession(\n    patient_id: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('action_items')\n        .select('*')\n        .eq('patient_id', patient_id)\n        .eq('active', false)\n        .not('questionnaire_session_id', 'is', null);\n\n    if (error) {\n        console.error(\n            'Unable to retrieve action items for patient',\n            error,\n            patient_id\n        );\n    }\n\n    return data as ActionItemType[];\n}"
      },
      {
        "name": "getActionItem",
        "kind": "function",
        "signature": "export async function getActionItem(\n    action_item_id: number | undefined\n): Promise<ActionItemType | null> {\n    const supabase = createSupabaseServiceClient();\n\n    if (isUndefined(action_item_id)) {\n        return null;\n    }\n\n    const { data, error } = await supabase\n        .from('action_items')\n        .select('*')\n        .eq('id', action_item_id)\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            'Unable to get action item for id',\n            action_item_id,\n            error\n        );\n        return null;\n    }\n    return data as ActionItemType;\n}"
      },
      {
        "name": "isUserEligible",
        "kind": "function",
        "signature": "export async function isUserEligible(\n    user_id: string,\n    questionnaire_name: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('action_items')\n        .select('*')\n        .eq('patient_id', user_id)\n        .eq('type', questionnaire_name)\n        .is('active', true)\n        .maybeSingle();\n\n    if (error) {\n        console.error('Error checking if user is eligible', error);\n    }\n\n    if (isEmpty(data)) {\n        return false;\n    }\n    return true;\n}"
      },
      {
        "name": "doesUserHaveSubscription",
        "kind": "function",
        "signature": "export async function doesUserHaveSubscription(\n    product_href: string,\n    user_id: string\n): Promise<boolean> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('prescription_subscriptions')\n        .select('id')\n        .eq('product_href', product_href)\n        .eq('patient_id', user_id)\n        .eq('status', 'active');\n\n    if (!error && data.length > 0) {\n        return true;\n    } else return false;\n}"
      },
      {
        "name": "updateActionItem",
        "kind": "function",
        "signature": "export async function updateActionItem(\n    action_item_id: number | undefined,\n    updatedPayload: Partial<ActionItemType>\n) {\n    const supabase = createSupabaseServiceClient();\n\n    if (!action_item_id) {\n        console.error('Unable to get action_item_id', updatedPayload);\n        return;\n    }\n\n    const { data, error } = await supabase\n        .from('action_items')\n        .update(updatedPayload)\n        .eq('id', action_item_id)\n        .select();\n\n    if (error) {\n        console.error(\n            'Error updating action item for payload',\n            updatedPayload,\n            action_item_id\n        );\n    }\n\n    if (!data || isEmpty(data)) {\n        return {};\n    }\n    return data[0];\n}"
      },
      {
        "name": "getActionItemByName",
        "kind": "function",
        "signature": "export async function getActionItemByName(\n    questionnaire_name: string,\n    patient_id: string\n): Promise<ActionItemType | null> {\n    const supabase = createSupabaseServiceClient();\n\n    if (isUndefined(questionnaire_name) || !questionnaire_name) {\n        return null;\n    }\n\n    const { data, error } = await supabase\n        .from('action_items')\n        .select('*')\n        .eq('type', questionnaire_name)\n        .eq('patient_id', patient_id)\n        .maybeSingle();\n\n    if (error || !data) {\n        console.error(\n            'Unable to get action item for patient and questionnaire name',\n            questionnaire_name,\n            patient_id,\n            error\n        );\n        return null;\n    }\n    return data as ActionItemType;\n}"
      },
      {
        "name": "getLastestActionItemForProduct",
        "kind": "function",
        "signature": "export async function getLastestActionItemForProduct(\n    user_id: string,\n    product_href: string\n): Promise<ActionItemType | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('action_items')\n        .select('*')\n        .eq('patient_id', user_id)\n        .eq('action_type', 'check_up')\n        .eq('product_href', product_href)\n        .order('iteration', { ascending: false })\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            'Unable to get latest action item for user_id',\n            user_id,\n            error\n        );\n        return null;\n    }\n    return data as ActionItemType;\n}"
      },
      {
        "name": "doesUserHaveActiveActionItemForProduct",
        "kind": "function",
        "signature": "export async function doesUserHaveActiveActionItemForProduct(\n    user_id: string,\n    product_href: string\n): Promise<boolean> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('action_items')\n        .select('*')\n        .eq('patient_id', user_id)\n        .eq('product_href', product_href)\n        .eq('active', true)\n        .eq('action_type', 'check_up')\n        .order('created_at', { ascending: true });\n\n    if (error) {\n        console.error('Error checking action item for user', error, user_id);\n        return false;\n    }\n\n    if (!data || data.length === 0) {\n        return false;\n    }\n\n    if (data.length > 1) {\n        const latestActionItem = data[data.length - 1];\n\n        // Deactivate all but the latest action item\n        const updatePromises = data\n            .slice(0, -1)\n            .map((item) =>\n                supabase\n                    .from('action_items')\n                    .update({ active: false })\n                    .eq('id', item.id)\n            );\n\n        const updateResults = await Promise.all(updatePromises);\n\n        // Check if any updates failed\n        const anyUpdateErrors = updateResults.some((result) => result.error);\n        if (anyUpdateErrors) {\n            console.error('Error updating action items for user', user_id);\n            return false;\n        }\n    }\n\n    return true;\n}"
      },
      {
        "name": "createActionItemForProduct",
        "kind": "function",
        "signature": "export async function createActionItemForProduct(\n    user_id: string,\n    product_href: string,\n    subscription_id: number\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const lastActionItem = await getLastestActionItemForProduct(\n        user_id,\n        product_href\n    );\n\n    if (!lastActionItem) {\n        const base_action_type = `${product_href}-checkup-1`;\n        await createActionItem(user_id, base_action_type, subscription_id);\n        return;\n    }\n\n    const ActionItemInstance = new ActionItemFactory(lastActionItem?.type);\n    let nextIteration = ActionItemInstance.getIteration() + 1;\n\n    const nextActionItemType = `${product_href}-checkup-${nextIteration}`;\n\n    await createActionItem(user_id, nextActionItemType, subscription_id);\n}"
      },
      {
        "name": "deactivateAllActionItemsForProduct",
        "kind": "function",
        "signature": "export async function deactivateAllActionItemsForProduct(\n    user_id: string,\n    product_href: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('action_items')\n        .select('*')\n        .eq('patient_id', user_id)\n        .eq('product_href', product_href)\n        .eq('action_type', ActionType.CheckUp)\n        .eq('active', true);\n\n    if (error) {\n        console.error(\n            'Error deactivating action items for user',\n            error,\n            user_id\n        );\n        return false;\n    }\n\n    if (!data || data.length === 0) {\n        return false;\n    }\n\n    const updatePromises = data.map((item) =>\n        supabase\n            .from('action_items')\n            .update({ active: false })\n            .eq('id', item.id)\n    );\n\n    const updateResults = await Promise.all(updatePromises);\n\n    const anyUpdateErrors = updateResults.some((result) => result.error);\n\n    if (anyUpdateErrors) {\n        console.error('Error updating action items for user', user_id);\n        return;\n    }\n\n    console.log('Successfully deactivated all action items for user', user_id);\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/action-items/action-items-actions.ts",
      "bioverse-client/app/api/customerio/webhook/route.ts",
      "bioverse-client/app/(patient-portal)/check-up/[product_href]/page.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/quarterly-final-review-dialog.tsx",
      "bioverse-client/app/services/pharmacy-integration/util/utils.ts",
      "bioverse-client/app/(patient-portal)/portal/layout.tsx",
      "bioverse-client/app/(patient-portal)/layout.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/intakes/intake-tab-function.ts",
      "bioverse-client/app/utils/database/controller/questionnaires/questionnaire.ts",
      "bioverse-client/app/(patient-portal)/check-up/[product_href]/utils.ts",
      "bioverse-client/app/utils/database/controller/orders/create-manual-order.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/ManualOrderCreationDialog.tsx",
      "bioverse-client/app/components/intake-v2/ed/confirmation/ed-confirmation.tsx",
      "bioverse-client/app/components/intake-v2/ed/components/additional-options.tsx",
      "bioverse-client/app/(patient-portal)/check-up/[product_href]/question/[question_id]/page.tsx",
      "bioverse-client/app/utils/database/controller/questionnaires/questionnaire_sessions.ts",
      "bioverse-client/app/utils/actions/check-up/check-up-actions.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/StripeInvoicePaidJobHandler.ts",
      "bioverse-client/app/api/easypost/route.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/admin_controlled_items/admin-controlled-items.ts",
    "exports": [
      {
        "name": "getAllControlledStates",
        "kind": "function",
        "signature": "export async function getAllControlledStates() {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('admin_controlled_items')\n        .select('control');\n\n    return data;\n}"
      },
      {
        "name": "getAdminControlState",
        "kind": "function",
        "signature": "export async function getAdminControlState(\n    controlVariable: string\n): Promise<{ id: number; control: string; active: boolean } | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('admin_controlled_items')\n        .select('id, control, active')\n        .eq('control', controlVariable)\n        .limit(1)\n        .single();\n\n    if (error) {\n        return null;\n    }\n\n    return data;\n}"
      },
      {
        "name": "changeAdminControlState",
        "kind": "function",
        "signature": "export async function changeAdminControlState(\n    controlVariable: string,\n    active: boolean\n): Promise<Status> {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('admin_controlled_items')\n        .update({\n            active: active,\n        })\n        .eq('control', controlVariable);\n\n    if (error) {\n        console.error('changeAdminControlState error: ', error);\n        return Status.Error;\n    }\n\n    return Status.Success;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/admin_controlled_items/admin-controlled-items.ts",
      "bioverse-client/app/components/admin/application-control/dashboard-controls.tsx",
      "bioverse-client/app/components/admin/application-control/application-control.tsx",
      "bioverse-client/app/components/provider-portal/nav-bar/tabs/provider-tabs.tsx",
      "bioverse-client/app/components/provider-portal/welcome/ProviderWelcome.tsx",
      "bioverse-client/app/components/registered-nurse-portal/nav-bar/registered-nurse-tabs.tsx/registered-nurse-tabs.tsx",
      "bioverse-client/app/components/registered-nurse-portal/welcome/RegisteredNurseWelcome.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/admin_order_cancel_audit/admin-order-cancel-audit.ts",
    "exports": [
      {
        "name": "insertAuditIntoAdministrativeCancelTable",
        "kind": "function",
        "signature": "export async function insertAuditIntoAdministrativeCancelTable(\n    orderId: string,\n    reason: string\n) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const uuid = (await supabase.auth.getSession()).data.session?.user.id;\n\n    const { error } = await supabase\n        .from('admin_order_cancel_audit')\n        .insert({ order_id: orderId, reason: reason, admin_uuid: uuid });\n\n    if (error) {\n        return { error: error };\n    }\n\n    return { error: null };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(administration)/admin/order-administration/_components/administrator-order-table.tsx",
      "bioverse-client/app/utils/database/controller/admin_order_cancel_audit/admin-order-cancel-audit.ts",
      "bioverse-client/app/utils/database/controller/renewal_orders/renewal_orders.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/subscriptions/components/subscription-accordion.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/order-tab-row.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/ai_generation_audit/ai_generation_audit_api.ts",
    "exports": [
      {
        "name": "createAIGenerationAudit",
        "kind": "function",
        "signature": "export async function createAIGenerationAudit(\n    providerId: string,\n    initialThreadData: any,\n    type: string,\n    ai_response: any,\n    metadata?: any\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const audit_obj = {\n        provider_id: providerId,\n        response_type: type,\n        initial_message_array: initialThreadData,\n        ai_response: ai_response,\n        metadata: metadata ?? null,\n    };\n\n    const { error } = await supabase\n        .from('ai_generation_audit')\n        .insert(audit_obj);\n\n    if (error) {\n        console.log(error);\n    }\n\n    return;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/ai_generation_audit/ai_generation_audit_api.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/message/ai-response-helper/utils/ai-response-controller.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/clinical_notes/clinical-notes.ts",
    "exports": [
      {
        "name": "updateClinicalNotes",
        "kind": "function",
        "signature": "export async function updateClinicalNotes(\n    fieldsToUpdate: ClinicalNoteUpdateObject,\n    patient_id: string,\n    product_href: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: updatedClinicalNoteData, error: updateError } = await supabase\n        .from('clinical_notes')\n        .update({ ...fieldsToUpdate })\n        .eq('patient_id', patient_id)\n        .eq('product_href', product_href)\n        .select();\n\n    if (updateError) {\n        console.log(\n            'Controller Error, tablename: clinical-notes, method-name: updateClinicalNotes, error: ',\n            updateError\n        );\n        return { data: null, error: updateError };\n    }\n\n    return { data: updatedClinicalNoteData, error: null };\n}"
      },
      {
        "name": "fetchClinicalNotesWithPatientId",
        "kind": "function",
        "signature": "export async function fetchClinicalNotesWithPatientId(\n    patientId: string,\n    product_href: string\n): Promise<any> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: clinicalNoteData, error: fetchError } = await supabase\n        .from('clinical_notes')\n        .select(\n            `\n        note,\n        allergies,\n        medications,\n        last_modified_at,\n        last_modified_by_provider_id,\n        provider:profiles!last_modified_by_provider_id (\n            first_name,\n            last_name\n        )\n        `\n        )\n        .eq('patient_id', patientId)\n        .eq('product_href', product_href)\n        .maybeSingle();\n\n    if (fetchError) {\n        console.log(\n            'Controller Error, tablename: clinical-notes method-name: fetchClinicalNotesWithPatientId, error: ',\n            fetchError\n        );\n        return { data: null, error: fetchError.message };\n    }\n\n    if (!clinicalNoteData) {\n        //If the clinical note does not exist, then try to create a new row\n        const { data, error } = await createNewClinicalNoteEntry(\n            patientId,\n            product_href\n        );\n\n        if (error) {\n            return { data: null, error: error };\n        }\n\n        return { data: data![0], error: null };\n    } else {\n        return { data: clinicalNoteData, error: null };\n    }\n}"
      },
      {
        "name": "getPatientAllergyData",
        "kind": "function",
        "signature": "export async function getPatientAllergyData(\n    patient_id: string,\n    product_href: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: clinicalNoteData, error: fetchError } = await supabase\n        .from('clinical_notes')\n        .select('allergies')\n        .eq('patient_id', patient_id);\n\n    if (fetchError) {\n        console.log(\n            'Controller Error, tablename: clinical-notes method-name: getPatientAllergyData, error: ',\n            fetchError\n        );\n        return { data: null, error: fetchError.message };\n    }\n\n    return { data: clinicalNoteData, error: null };\n}"
      },
      {
        "name": "getPatientMedicationData",
        "kind": "function",
        "signature": "export async function getPatientMedicationData(\n    patient_id: string,\n    product_href: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: clinicalNoteData, error: fetchError } = await supabase\n        .from('clinical_notes')\n        .select('medications')\n        .eq('patient_id', patient_id)\n        .maybeSingle();\n\n    if (fetchError) {\n        console.log(\n            'Controller Error, tablename: clinical-notes method-name: getPatientMedicationData, error: ',\n            fetchError\n        );\n        return { data: null, error: fetchError.message };\n    }\n\n    return { data: clinicalNoteData, error: null };\n}"
      },
      {
        "name": "getPatientAllergyAndMedicationData",
        "kind": "function",
        "signature": "export async function getPatientAllergyAndMedicationData(patient_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: clinicalNoteData, error: fetchError } = await supabase\n        .from('clinical_notes')\n        .select('allergies, medications')\n        .eq('patient_id', patient_id)\n        .limit(1)\n        .maybeSingle();\n\n    if (fetchError) {\n        console.log(\n            'Controller Error, tablename: clinical-notes method-name: getPatientAllergyAndMedicationData, error: ',\n            fetchError\n        );\n        return { data: null, error: fetchError.message };\n    }\n\n    return { data: clinicalNoteData, error: null };\n}"
      },
      {
        "name": "getAllPatientClinicalNoteData",
        "kind": "function",
        "signature": "export async function getAllPatientClinicalNoteData(patient_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: clinicalNotes, error } = await supabase\n        .from('clinical_notes')\n        .select(\n            `*, \n            product:products!product_href(name),\n            provider:profiles!last_modified_by_provider_id(first_name, last_name)`\n        )\n        .eq('patient_id', patient_id);\n\n    if (error) {\n        console.log(\n            'Controller Error, tablename: clinical-notes method-name: getAllPatientClinicalNoteData, error: ',\n            error\n        );\n        return { data: null, error: error.message };\n    }\n\n    return { data: clinicalNotes, error: null };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/clinical_notes/clinical-notes.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/patient-information-column/clinical-notes-v2-content.tsx",
      "bioverse-client/_deprecated/clinical_notes_v1/clinical-notes-v2-content.tsx",
      "bioverse-client/_deprecated/patient-overview/clinical-notes/clinical-notes.tsx",
      "bioverse-client/app/(testing_and_development)/olivier-dev/utils.ts",
      "bioverse-client/app/utils/classes/Scripts/BaseScriptHandler.ts",
      "bioverse-client/app/utils/functions/pharmacy-helpers/bundle-to-single-vial-converter.ts",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/confirm-prescription-dialog.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-display-options.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approve-script-dialog.tsx",
      "bioverse-client/app/services/pharmacy-integration/hallandale/hallandale-script-api.ts",
      "bioverse-client/_deprecated/patient-intakes/[orderId]/page.tsx",
      "bioverse-client/app/services/pharmacy-integration/curexa/curexa-actions.ts",
      "bioverse-client/app/services/pharmacy-integration/gogomeds/ggm-actions.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/clinical_notes/clinical_notes_enums.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/controller/clinical_notes/clinical_notes_v2.ts",
    "exports": [
      {
        "name": "getAllClinicalNotesForPatient",
        "kind": "function",
        "signature": "export async function getAllClinicalNotesForPatient(\n    patient_id: string\n): Promise<{ data: ClinicalNotesV2Supabase[] | null; error: any }> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('clinical_notes_v2')\n        .select(\n            `\n            *,\n            creating_provider:profiles!created_by (first_name, last_name),\n            editing_provider:profiles!last_modified_by (first_name, last_name)\n        `\n        )\n        .eq('patient_id', patient_id)\n        .eq('type', 'note')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        return { data: null, error: error };\n    }\n\n    return { data: data, error: error };\n}"
      },
      {
        "name": "getClinicalNoteById",
        "kind": "function",
        "signature": "export async function getClinicalNoteById(\n    note_id: string\n): Promise<{ data: ClinicalNotesV2Supabase[] | null; error: any }> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('clinical_notes_v2')\n        .select('*')\n        .eq('id', note_id);\n\n    if (error) {\n        return { data: null, error: error };\n    }\n\n    return { data: data, error: error };\n}"
      },
      {
        "name": "postNewClinicalNote",
        "kind": "function",
        "signature": "export async function postNewClinicalNote(\n    patient_id: string,\n    author_user_id: string,\n    type: ClinicalNoteType,\n    note: string,\n    product_href?: string\n): Promise<{ data: ClinicalNotesV2Supabase[] | null; error: any }> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('clinical_notes_v2')\n        .insert({\n            patient_id: patient_id,\n            created_by: author_user_id,\n            type: type,\n            note: note,\n            ...(product_href ? { product_href: product_href } : {}),\n        })\n        .select();\n\n    if (error) {\n        return { data: null, error: error };\n    }\n    console.log('clinical note v2 data: ', data);\n    return { data: data, error: error };\n}"
      },
      {
        "name": "updateClinicalNote",
        "kind": "function",
        "signature": "export async function updateClinicalNote(\n    clinical_note_id: number,\n    new_note: string,\n    editor_user_id: string,\n    previous_note?: string,\n    last_modified_at?: string,\n    created_at?: string\n): Promise<{ data: ClinicalNotesV2Supabase[] | null; error: any }> {\n    const supabase = createSupabaseServiceClient();\n\n    let note_history_array;\n\n    if (previous_note) {\n        const { data: previous_history } = await supabase\n            .from('clinical_notes_v2')\n            .select('note_history')\n            .eq('id', clinical_note_id)\n            .limit(1)\n            .maybeSingle();\n\n        if (previous_history?.note_history) {\n            note_history_array = [\n                ...previous_history.note_history,\n                {\n                    editor: editor_user_id,\n                    date: last_modified_at ?? new Date(),\n                    note: previous_note,\n                },\n            ];\n        } else {\n            note_history_array = [\n                {\n                    editor: editor_user_id,\n                    date: created_at,\n                    note: previous_note,\n                },\n            ];\n        }\n    }\n\n    const { data, error } = await supabase\n        .from('clinical_notes_v2')\n        .update({\n            note: new_note,\n            last_modified_by: editor_user_id,\n            last_modified_at: new Date(),\n            ...(previous_note ? { note_history: note_history_array } : {}),\n        })\n        .eq('id', clinical_note_id)\n        .select();\n\n    if (error) {\n        return { data: null, error: error };\n    }\n\n    return { data: data, error: error };\n}"
      },
      {
        "name": "updateClinicalNoteTemplateData",
        "kind": "function",
        "signature": "export async function updateClinicalNoteTemplateData(\n    clinical_note_id: number,\n    new_metadata: any,\n    editor_user_id: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: old_metadata, error: old_metadata_error } = await supabase\n        .from('clinical_notes_v2')\n        .select('metadata')\n        .eq('id', clinical_note_id)\n        .limit(1)\n        .single();\n\n    const { data, error } = await supabase\n        .from('clinical_notes_v2')\n        .update({\n            metadata: new_metadata,\n            last_modified_by: editor_user_id,\n            last_modified_at: new Date(),\n            note_history: old_metadata?.metadata,\n        })\n        .eq('id', clinical_note_id)\n        .select();\n\n    if (error) {\n        return { data: null, error: error };\n    }\n\n    return { data: data, error: error };\n}"
      },
      {
        "name": "retrieveAllergyAndMedicationData",
        "kind": "function",
        "signature": "export async function retrieveAllergyAndMedicationData(patient_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    let allergy_string;\n    let medication_string;\n\n    const { data: allergy_data, error: allery_error } = await supabase\n        .from('clinical_notes_v2')\n        .select(`note`)\n        .eq('patient_id', patient_id)\n        .eq('data_type', 'allergy')\n        .eq('type', 'patient_data')\n        .limit(1)\n        .maybeSingle();\n\n    const { data: medication_data, error: medication_error } = await supabase\n        .from('clinical_notes_v2')\n        .select(`note`)\n        .eq('patient_id', patient_id)\n        .eq('data_type', 'medication')\n        .eq('type', 'patient_data')\n        .limit(1)\n        .maybeSingle();\n\n    allergy_string = allergy_data?.note ?? undefined;\n    medication_string = medication_data?.note ?? undefined;\n\n    return { allergy: allergy_string, medication: medication_string };\n}"
      },
      {
        "name": "addOrRetreivePatientAllergyAndMedicationData",
        "kind": "function",
        "signature": "export async function addOrRetreivePatientAllergyAndMedicationData(\n    patient_id: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('clinical_notes_v2')\n        .select(\n            `\n            id,\n            created_at,\n            patient_id,\n            created_by,\n            admin_edit_access,\n            type,\n            note,\n            product_href,\n            last_modified_at,\n            last_modified_by,\n            data_type,\n            note_history,\n            creating_provider:profiles!created_by (first_name, last_name),\n            editing_provider:profiles!last_modified_by (first_name, last_name)\n        `\n        )\n        .eq('patient_id', patient_id)\n        .neq('data_type', 'bmi')\n        .neq('data_type', 'template')\n        .eq('type', 'patient_data')\n        .order('data_type', { ascending: true });\n\n    if (error) {\n        console.log(error);\n        return [];\n    }\n\n    const current_user_id = (await readUserSession()).data.session?.user.id;\n\n    if (data.length > 0) {\n        return data;\n    } else {\n        //check question answer data for pt for allergy / medications : allergyQID-168 , medicationQID-8\n\n        const { allergy_string, medication_string } =\n            await getQuestionAnswersForAllergyMedication(patient_id);\n\n        const { data, error } = await supabase\n            .from('clinical_notes_v2')\n            .insert([\n                {\n                    patient_id: patient_id,\n                    created_by:\n                        current_user_id ??\n                        '24138d35-e26f-4113-bcd9-7f275c4f9a47', //TODO remove maylin as the default here\n                    type: 'patient_data',\n                    note: allergy_string,\n                    data_type: 'allergy',\n                },\n                {\n                    patient_id: patient_id,\n                    created_by:\n                        current_user_id ??\n                        '24138d35-e26f-4113-bcd9-7f275c4f9a47', //TODO remove maylin as the default here\n                    type: 'patient_data',\n                    note: medication_string,\n                    data_type: 'medication',\n                },\n            ]).select(`\n                *,\n                creating_provider:profiles!created_by (first_name, last_name),\n                editing_provider:profiles!last_modified_by (first_name, last_name)\n            `);\n\n        if (error) {\n            console.log('clinical note allergy medication push', error);\n        }\n\n        return data;\n    }\n}"
      },
      {
        "name": "addOrRetrievePatientBMIData",
        "kind": "function",
        "signature": "export async function addOrRetrievePatientBMIData(\n    patient_id: string,\n    product_href: string\n) {\n    if (\n        !WEIGHT_LOSS_PRODUCT_HREF.includes(product_href) &&\n        product_href != PRODUCT_HREF.NAD_INJECTION\n    ) {\n        return null;\n    }\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('clinical_notes_v2')\n        .select(\n            `\n            id,\n            created_at,\n            patient_id,\n            created_by,\n            admin_edit_access,\n            type,\n            note,\n            product_href,\n            last_modified_at,\n            last_modified_by,\n            data_type,\n            metadata,\n            creating_provider:profiles!created_by (first_name, last_name),\n            editing_provider:profiles!last_modified_by (first_name, last_name)\n        `\n        )\n        .eq('patient_id', patient_id)\n        .eq('type', 'patient_data')\n        .eq('data_type', 'bmi')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error(\n            'Patient BMI Clinical Note Data Retreival Error: ',\n            error,\n            'patient_id: ',\n            patient_id\n        );\n        return null;\n    }\n\n    const current_user_id = (await readUserSession()).data.session?.user.id;\n\n    if (data.length > 0) {\n        if (data && data.length > 0) {\n            // Parse the created_at timestamps and group entries by day\n            // Assuming `data` is an array of objects that match the ClinicalNoteEntry interface\n            const groupedByDay: Record<string, any[]> = data.reduce(\n                (acc, entry) => {\n                    const date = parseISO(entry.created_at);\n                    const dayKey = `${date.getFullYear()}-${\n                        date.getMonth() + 1\n                    }-${date.getDate()}`;\n\n                    if (!acc[dayKey]) {\n                        acc[dayKey] = [];\n                    }\n                    acc[dayKey].push(entry);\n\n                    return acc;\n                },\n                {} as Record<string, any[]>\n            ); // Type assertion here\n\n            // For each day, find the latest entry\n            const latestEntries = Object.values(groupedByDay).map(\n                (entries: any) => {\n                    return entries.sort(\n                        (a: any, b: any) =>\n                            new Date(b.created_at).getTime() -\n                            new Date(a.created_at).getTime()\n                    )[0];\n                }\n            );\n\n            return latestEntries;\n        } else {\n            // Handle the case where there is no data\n            return [];\n        }\n    } else {\n        //check question answer data for pt for allergy / medications : allergyQID-168 , medicationQID-8\n\n        const bmi_answer = await getQuestionAnswersForBMI(patient_id);\n\n        const { data, error } = await supabase\n            .from('clinical_notes_v2')\n            .insert([\n                {\n                    patient_id: patient_id,\n                    created_by:\n                        current_user_id ??\n                        '24138d35-e26f-4113-bcd9-7f275c4f9a47', //TODO remove maylin as the default here\n                    type: 'patient_data',\n                    note: `Height: ${bmi_answer?.height_feet} ft ${\n                        bmi_answer?.height_inches\n                    }, Weight: ${\n                        bmi_answer.weight_lbs\n                    }, BMI: ${bmi_answer.bmi.toFixed(2)}`,\n                    data_type: 'bmi',\n                    metadata: {\n                        height_feet: bmi_answer.height_feet,\n                        height_inches: bmi_answer.height_inches,\n                        weight_lbs: bmi_answer.weight_lbs,\n                        bmi: bmi_answer.bmi,\n                    },\n                },\n            ]).select(`\n                *,\n                creating_provider:profiles!created_by (first_name, last_name),\n                editing_provider:profiles!last_modified_by (first_name, last_name)\n            `);\n\n        if (error) {\n            console.log(\n                'clinical note BMI issue: ',\n                error,\n                'patient ID: ',\n                patient_id\n            );\n            return null;\n        }\n\n        if (data && data.length > 0) {\n            // Parse the created_at timestamps and group entries by day\n            // Assuming `data` is an array of objects that match the ClinicalNoteEntry interface\n            const groupedByDay: Record<string, any[]> = data.reduce(\n                (acc, entry) => {\n                    const date = parseISO(entry.created_at);\n                    const dayKey = `${date.getFullYear()}-${\n                        date.getMonth() + 1\n                    }-${date.getDate()}`;\n\n                    if (!acc[dayKey]) {\n                        acc[dayKey] = [];\n                    }\n                    acc[dayKey].push(entry);\n\n                    return acc;\n                },\n                {} as Record<string, any[]>\n            ); // Type assertion here\n\n            // For each day, find the latest entry\n            const latestEntries = Object.values(groupedByDay).map(\n                (entries: any) => {\n                    return entries.sort(\n                        (a: any, b: any) =>\n                            new Date(b.created_at).getTime() -\n                            new Date(a.created_at).getTime()\n                    )[0];\n                }\n            );\n\n            return latestEntries;\n        } else {\n            // Handle the case where there is no data\n            return [];\n        }\n    }\n}"
      },
      {
        "name": "getHeightForPatient",
        "kind": "function",
        "signature": "export async function getHeightForPatient(patient_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: height_data } = await supabase\n        .from('clinical_notes_v2')\n        .select('answer')\n        .eq('user_id', patient_id)\n        .eq('question_id', 166)\n        .order('created_at', { ascending: false });\n}"
      },
      {
        "name": "getQuestionAnswersForBMI",
        "kind": "function",
        "signature": "export async function getQuestionAnswersForBMI(patient_id: string): Promise<{\n    height_feet: number;\n    height_inches: number;\n    weight_lbs: number;\n    bmi: number;\n}> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: bmi_question_answer_arr } = await supabase\n        .from('questionnaire_answers')\n        .select('answer')\n        .eq('user_id', patient_id)\n        .eq('question_id', 166)\n        .order('created_at', { ascending: false });\n\n    if (!bmi_question_answer_arr) {\n        return {\n            height_feet: 0,\n            height_inches: 0,\n            weight_lbs: 0,\n            bmi: 999,\n        };\n    }\n\n    const bmi_question_answer = bmi_question_answer_arr[0];\n\n    let bmi_question_answer_converted = {\n        height_feet: 0,\n        height_inches: 0,\n        weight_lbs: 0,\n        bmi: 999,\n    };\n\n    if (bmi_question_answer) {\n        bmi_question_answer_converted = {\n            height_feet: bmi_question_answer.answer.formData[0],\n            height_inches: bmi_question_answer.answer.formData[1],\n            weight_lbs: bmi_question_answer.answer.formData[2],\n            bmi: calculateBMI(\n                bmi_question_answer.answer.formData[2],\n                bmi_question_answer.answer.formData[0],\n                bmi_question_answer.answer.formData[1]\n            ),\n        };\n    }\n\n    return bmi_question_answer_converted;\n}"
      },
      {
        "name": "getQuestionAnswersForGoalBMI",
        "kind": "function",
        "signature": "export async function getQuestionAnswersForGoalBMI(\n    patient_id: string\n): Promise<{\n    height_feet: number;\n    height_inches: number;\n    weight_lbs: number;\n    bmi: number;\n}> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: goal_weight } = await supabase\n        .from('questionnaire_answers')\n        .select('answer')\n        .eq('user_id', patient_id)\n        .eq('question_id', 2303)\n        .order('created_at', { ascending: false });\n\n    if (!goal_weight) {\n        return {\n            height_feet: 0,\n            height_inches: 0,\n            weight_lbs: 0,\n            bmi: 999,\n        };\n    }\n\n    const { data } = await supabase\n        .from('questionnaire_answers')\n        .select('answer')\n        .eq('user_id', patient_id)\n        .eq('question_id', 166)\n        .order('created_at', { ascending: false });\n\n    if (!data) {\n        return {\n            height_feet: 0,\n            height_inches: 0,\n            weight_lbs: 0,\n            bmi: 999,\n        };\n    }\n\n    const bmi_question_answer = goal_weight[0].answer.formData[0];\n\n    const height = data[0].answer.formData[0];\n    const inches = data[0].answer.formData[1];\n\n    let bmi_question_answer_converted = {\n        height_feet: 0,\n        height_inches: 0,\n        weight_lbs: 0,\n        bmi: 999,\n    };\n\n    if (bmi_question_answer) {\n        bmi_question_answer_converted = {\n            height_feet: height,\n            height_inches: inches,\n            weight_lbs: bmi_question_answer,\n            bmi: calculateBMI(bmi_question_answer, height, inches),\n        };\n    }\n\n    return bmi_question_answer_converted;\n}"
      },
      {
        "name": "getClinicalNoteTemplateDataForOrderId",
        "kind": "function",
        "signature": "export async function getClinicalNoteTemplateDataForOrderId(\n    order_id: string | number\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: templatized_note, error } = await supabase\n        .from('clinical_notes_v2')\n        .select('*')\n        .eq('data_type', 'template')\n        .eq('order_id', order_id)\n        .is('renewal_order_id', null)\n        .limit(1)\n        .maybeSingle();\n\n    return templatized_note;\n}"
      },
      {
        "name": "findClinicalNoteTemplateRecordByOrderId",
        "kind": "function",
        "signature": "export async function findClinicalNoteTemplateRecordByOrderId(\n    orderId: string | number,\n    renewal_order_id?: string\n): Promise<Partial<ClinicalNoteRecordWithPatientProviderData> | null> {\n    const supabase = createSupabaseServiceClient();\n\n    let result;\n\n    if (renewal_order_id) {\n        const { data, error } = await supabase\n            .from('clinical_notes_v2')\n            .select(\n                `*, \n            creating_provider:profiles!created_by (first_name, last_name), \n            editing_provider:profiles!last_modified_by (first_name, last_name)`\n            )\n            .eq('renewal_order_id', renewal_order_id)\n            .limit(1)\n            .maybeSingle();\n\n        if (error) {\n            console.log(\n                'findClinicalNoteTemplateRecordByOrderId error - renewal order ID: ',\n                renewal_order_id,\n                'error message: ',\n                error.message\n            );\n        }\n\n        result = data;\n    } else {\n        const { data, error } = await supabase\n            .from('clinical_notes_v2')\n            .select(\n                `*, \n            creating_provider:profiles!created_by (first_name, last_name), \n            editing_provider:profiles!last_modified_by (first_name, last_name)`\n            )\n            .eq('order_id', orderId)\n            .is('renewal_order_id', null)\n            .limit(1)\n            .maybeSingle();\n\n        if (error) {\n            console.log(\n                'findClinicalNoteTemplateRecordByOrderId error - order ID: ',\n                orderId,\n                'error message: ',\n                error.message\n            );\n        }\n\n        result = data;\n    }\n\n    if (!result) {\n        return null;\n    }\n\n    return result as ClinicalNoteRecordWithPatientProviderData;\n}"
      },
      {
        "name": "findAllClinicalNoteTemplatesForOrderId",
        "kind": "function",
        "signature": "export async function findAllClinicalNoteTemplatesForOrderId(\n    orderId: string | number,\n    product_href: PRODUCT_HREF\n) {\n    if (!TEMPLATIZED_PRODUCT_LIST.includes(product_href)) {\n        return null;\n    }\n\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('clinical_notes_v2')\n        .select(\n            `*, \n            creating_provider:profiles!created_by (first_name, last_name),\n            editing_provider:profiles!last_modified_by (first_name, last_name)`\n        )\n        .eq('order_id', orderId)\n        .eq('data_type', 'template')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.log(\n            'findAllClinicalNoteTemplatesForOrderId error - order ID: ',\n            orderId,\n            'error message: ',\n            error.message\n        );\n    }\n\n    return data as ClinicalNoteRecordWithPatientProviderData[];\n}"
      },
      {
        "name": "findAllOtherClinicalNoteTemplatesForPatient",
        "kind": "function",
        "signature": "export async function findAllOtherClinicalNoteTemplatesForPatient(\n    product_href: PRODUCT_HREF,\n    patient_id: string\n) {\n    if (!TEMPLATIZED_PRODUCT_LIST.includes(product_href)) {\n        return null;\n    }\n\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('clinical_notes_v2')\n        .select(\n            `*, \n            creating_provider:profiles!created_by (first_name, last_name),\n            editing_provider:profiles!last_modified_by (first_name, last_name)`\n        )\n        .eq('patient_id', patient_id)\n        .eq('data_type', 'template')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.log(\n            'findAllOtherClinicalNoteTemplatesForPatient ',\n            'error message: ',\n            error.message\n        );\n    }\n\n    return data as ClinicalNoteRecordWithPatientProviderData[];\n}"
      },
      {
        "name": "createTemplatizedClinicalNote",
        "kind": "function",
        "signature": "export async function createTemplatizedClinicalNote(\n    order_id: string | number,\n    product_href: string,\n    patient_id: string,\n    values: any[],\n    created_by_id: string,\n    renewal_order_id?: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const orderType = !renewal_order_id ? 'intake' : 'renewal';\n    const latestVersion =\n        PRODUCT_TEMPLATE_LATEST_VERSION_MAP[product_href][orderType];\n\n    const { data, error } = await supabase\n        .from('clinical_notes_v2')\n        .insert({\n            patient_id: patient_id,\n            created_by: created_by_id,\n            type: 'patient_data',\n            product_href: product_href,\n            data_type: 'template',\n            metadata: values,\n            order_id: order_id,\n            template_version: latestVersion,\n            ...(renewal_order_id ? { renewal_order_id: renewal_order_id } : {}),\n        })\n        .select(\n            `*, \n            creating_provider:\n                profiles!created_by \n                    (first_name, last_name), \n            editing_provider:\n                profiles!last_modified_by \n                    (first_name, last_name)`\n        )\n        .single();\n\n    if (error) {\n        console.error('createTemplatizedClinicalNote error: ', error.message);\n        return null;\n    }\n\n    return data as ClinicalNoteRecordWithPatientProviderData;\n}"
      },
      {
        "name": "createManualBMINote",
        "kind": "function",
        "signature": "export async function createManualBMINote(\n    patient_id: string,\n    authoring_provider_id: string,\n    height_feet: number,\n    height_inches: number,\n    bmi: number,\n    weight: number\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const bmiRecordObject = {\n        patient_id: patient_id,\n        created_by: authoring_provider_id,\n        admin_edit_access: false,\n        type: 'patient_data',\n        data_type: 'bmi',\n        note: `Height: ${height_feet} ft ${height_inches}, Weight: ${weight.toFixed(\n            2\n        )}, BMI: ${bmi}`,\n        metadata: {\n            bmi: bmi,\n            weight_lbs: weight,\n            height_feet: height_feet,\n            height_inches: height_inches,\n        },\n    };\n\n    const { error } = await supabase\n        .from('clinical_notes_v2')\n        .insert(bmiRecordObject);\n\n    if (error) {\n        console.error('bmi creation issue', error);\n        return Status.Error;\n    }\n\n    return Status.Success;\n}"
      },
      {
        "name": "createNewCheckUpClinicalBmiNote",
        "kind": "function",
        "signature": "export async function createNewCheckUpClinicalBmiNote(\n    patient_id: string,\n    question_answer: Answer\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const reported_weight = parseFloat(\n        question_answer.answer ?? question_answer.formData[0]\n    );\n\n    const { data: latestBmiRecord, error } = await supabase\n        .from('clinical_notes_v2')\n        .select('id, created_at, note, metadata')\n        .eq('patient_id', patient_id)\n        .eq('data_type', 'bmi')\n        .order('created_at', { ascending: true })\n        .limit(1)\n        .maybeSingle();\n\n    if (!latestBmiRecord || error) {\n        console.error('No BMI record found for patient: ', patient_id);\n        return;\n    }\n\n    await updateCurrentProfileHeight(\n        latestBmiRecord.metadata.height_inches +\n            latestBmiRecord.metadata.height_feet * 12,\n        patient_id\n    );\n\n    const bmi = calculateBMI(\n        reported_weight,\n        latestBmiRecord.metadata.height_feet,\n        latestBmiRecord.metadata.height_inches\n    );\n\n    //Checking if the latest Bmi record was made within 24 hours.\n    //If so we will update the bmi record and if not we will create a new record.\n    if (\n        latestBmiRecord &&\n        new Date(latestBmiRecord.created_at).getTime() >\n            new Date().getTime() - 24 * 60 * 60 * 1000\n    ) {\n        //Update the bmi record\n\n        const { error: updateError } = await supabase\n            .from('clinical_notes_v2')\n            .update({\n                note: `Height: ${latestBmiRecord.metadata.height_feet} ft ${\n                    latestBmiRecord.metadata.height_inches\n                }, Weight: ${reported_weight.toFixed(2)}, BMI: ${bmi.toFixed(\n                    2\n                )}`,\n                metadata: {\n                    bmi: bmi,\n                    weight_lbs: reported_weight,\n                    height_feet: latestBmiRecord.metadata.height_feet,\n                    height_inches: latestBmiRecord.metadata.height_inches,\n                },\n            })\n            .eq('id', latestBmiRecord.id);\n\n        if (updateError) {\n            console.error('updateError', updateError);\n        }\n    } else {\n        //Create a new bmi record\n\n        const { error: createError } = await supabase\n            .from('clinical_notes_v2')\n            .insert({\n                patient_id: patient_id,\n                created_by: null,\n                admin_edit_access: false,\n                type: 'patient_data',\n                data_type: 'bmi',\n                note: `Height: ${latestBmiRecord.metadata.height_feet} ft ${\n                    latestBmiRecord.metadata.height_inches\n                }, Weight: ${reported_weight.toFixed(2)}, BMI: ${bmi.toFixed(\n                    2\n                )}`,\n                metadata: {\n                    bmi: bmi,\n                    weight_lbs: reported_weight,\n                    height_feet: latestBmiRecord.metadata.height_feet,\n                    height_inches: latestBmiRecord.metadata.height_inches,\n                },\n            });\n\n        if (createError) {\n            console.error('createError', createError);\n        }\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/clinical_notes/clinical_notes_v2.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/containers/clinical-notes-content.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/clinical-notes/clinical-notes-tab.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-notes-content.tsx",
      "bioverse-client/_deprecated/clinical_notes_v1/clinical-notes-content.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-creation-menu/creation-tab-content/note-creation/note-creation.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/text-editor/clinical-note-text-editor.tsx",
      "bioverse-client/app/utils/database/controller/clinical_notes/clinical-notes.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/patient-information-column/clinical-note-components/note-display-v2.tsx",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/patient-information-column/clinical-notes-v2-content.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/clinical-notes/components/allergy-med-display.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/clinical-notes/components/clinical-note-tiptap.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-components/allergy-med-display.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-components/note-display-v2.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-components/allergy-med-accordion.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-components/note-and-template-accordion.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-components/bmi-accordion-record.tsx",
      "bioverse-client/_deprecated/clinical_notes_v1/collapsible-note-template.tsx",
      "bioverse-client/_deprecated/clinical_notes_v1/clinical-note-template-deprecated.tsx",
      "bioverse-client/_deprecated/clinical_notes_v1/clinical-notes-v2-content.tsx",
      "bioverse-client/_deprecated/patient-overview/clinical-notes/clinical-notes.tsx",
      "bioverse-client/app/services/pharmacy-integration/curexa/curexa-actions.ts",
      "bioverse-client/app/utils/classes/Scripts/EmpowerScriptHandler.ts",
      "bioverse-client/app/utils/actions/intake/order-util.ts",
      "bioverse-client/app/utils/functions/pharmacy-helpers/bundle-to-single-vial-converter.ts",
      "bioverse-client/app/utils/functions/prescription-scripts/empower-approval-script-generator.ts",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/confirm-prescription-dialog.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/custom-prescription-script/custom-prescription-script-utils.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/empower/empower-window.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/empower/empower-window-v2.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approve-script-dialog.tsx",
      "bioverse-client/app/components/intake-v2/questions/functions/questions-functions.ts",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/order-summary-v4/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-calculating-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-calculating/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3-abtest/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/bmi-summary/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/whats-next/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-data-processing/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-data-processing-2/page.tsx",
      "bioverse-client/app/services/pharmacy-integration/util/utils.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-templates/clinical-template-functions.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-creation-menu/creation-tab-content/bmi-creation.tsx",
      "bioverse-client/app/components/patient-portal/check-up/question/checkup-question-logic.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/coordinator_activity_audit/coordinator_activity_audit-api.ts",
    "exports": [
      {
        "name": "createNewCoordinatorActivityAudit",
        "kind": "function",
        "signature": "export async function createNewCoordinatorActivityAudit(\n    new_audit_data: CoordinatorActivityAuditCreateObject\n): Promise<Status> {\n    const supabase = createSupabaseServiceClient();\n\n    console.log(\n        'new_audit_data in createNewCoordinatorActivityAudit',\n        new_audit_data\n    );\n\n    const { error } = await supabase\n        .from('coordinator_activity_audit')\n        .insert(new_audit_data);\n\n    if (error) {\n        console.error(\n            'createNewCoordinatorActivityAudit',\n            error,\n            `new audit data: ${new_audit_data}`\n        );\n\n        return Status.Error;\n    }\n\n    return Status.Success;\n}"
      },
      {
        "name": "getCoordinatorSessionRecord",
        "kind": "function",
        "signature": "export async function getCoordinatorSessionRecord(\n    coordinator_id: string\n): Promise<Partial<CoordinatorActivityAuditRecord[]>> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'check_coordinator_session_log',\n        {\n            coordinator_id_: coordinator_id,\n        }\n    );\n\n    return data;\n}"
      },
      {
        "name": "getPendingCoordinatorTasksCount",
        "kind": "function",
        "signature": "export async function getPendingCoordinatorTasksCount(): Promise<\n    Partial<number | null>\n> {\n    const supabase = createSupabaseServiceClient();\n\n    const { count: pendingCount } = await supabase\n        .from('coordinator_tasks')\n        .select('*', { count: 'exact', head: true })\n        .eq('completion_status', 'pending');\n\n    return pendingCount;\n}"
      },
      {
        "name": "getCompletedCoordinatorTasksCount",
        "kind": "function",
        "signature": "export async function getCompletedCoordinatorTasksCount(\n    coordinator_id: string,\n    start_date: Date,\n    end_date: Date\n): Promise<Partial<number | null>> {\n    const supabase = createSupabaseServiceClient();\n\n    const { count: completedCount } = await supabase\n        .from('coordinator_tasks')\n        .select('*', { count: 'exact', head: true })\n        .eq('completion_status', 'completed')\n        .eq('assigned_coordinator', coordinator_id)\n        .gte('created_at', start_date)\n        .lte('created_at', end_date);\n\n    return completedCount ?? 0;\n}"
      },
      {
        "name": "getCompletedForwardedTasksCount",
        "kind": "function",
        "signature": "export async function getCompletedForwardedTasksCount(\n    coordinator_id: string,\n    start_date: Date,\n    end_date: Date\n): Promise<Partial<number | null>> {\n    const supabase = createSupabaseServiceClient();\n\n    const { count: forwardedCount } = await supabase\n        .from('coordinator_tasks')\n        .select('*', { count: 'exact', head: true })\n        .eq('completion_status', 'forwarded')\n        .eq('assigned_coordinator', coordinator_id)\n        .gte('created_at', start_date)\n        .lte('created_at', end_date);\n\n    return forwardedCount ?? 0;\n}"
      },
      {
        "name": "getMessagesOverdueCount",
        "kind": "function",
        "signature": "export async function getMessagesOverdueCount(): Promise<\n    Partial<number | null>\n> {\n    const supabase = createSupabaseServiceClient();\n\n    const { count: messagesOverdueCount } = await supabase\n        .from('patient_status_tags')\n        .select('*', { count: 'exact', head: true })\n        .eq('status_tag', 'Overdue');\n\n    return messagesOverdueCount;\n}"
      },
      {
        "name": "getCoordinatorAutomaticSessionTimes",
        "kind": "function",
        "signature": "export async function getCoordinatorAutomaticSessionTimes(\n    coordinator_id: string,\n    start_date: Date,\n    end_date: Date\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const start_date_epoch = start_date.getTime();\n    const end_date_epoch = end_date.getTime();\n\n    const { data, error } = await supabase.rpc(\n        'get_coordinator_automatic_session_times',\n        {\n            coordinator_id_: coordinator_id,\n            start_date: start_date_epoch,\n            end_date: end_date_epoch,\n        }\n    );\n\n    const filteredData = data.filter((item: any) => item.session_time > 0.01);\n\n    if (error) {\n        console.error('getHoursLoggedByCoordinator', error);\n    }\n\n    return filteredData;\n}"
      },
      {
        "name": "startNewSession",
        "kind": "function",
        "signature": "export async function startNewSession(coordinator_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const startSessionAuditRecord = {\n        coordinator_id: coordinator_id,\n        action: 'start_session',\n        timestamp: new Date().getTime(),\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n    };\n\n    const { data, error } = await supabase\n        .from('coordinator_activity_audit')\n        .insert(startSessionAuditRecord);\n\n    console.log('data: =>', data);\n\n    if (error) {\n        console.error('End session error: ', error);\n    }\n}"
      },
      {
        "name": "endSession",
        "kind": "function",
        "signature": "export async function endSession(coordinator_id: string, endTime?: number) {\n    const supabase = createSupabaseServiceClient();\n\n    const endSessionAuditRecord = {\n        coordinator_id,\n        action: 'end_session',\n        timestamp: endTime ? endTime : new Date().getTime(),\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n        ...(endTime\n            ? { metadata: { source: 'automatic' } }\n            : { metadata: { source: 'manual' } }),\n    };\n\n    const stream = await getCoordinatorSessionRecord(coordinator_id);\n\n    if (!stream) {\n        return;\n    }\n\n    if (stream[0]?.action === 'end_session') {\n        return;\n    }\n\n    const { error } = await supabase\n        .from('coordinator_activity_audit')\n        .insert(endSessionAuditRecord);\n\n    if (error) {\n        console.error('End session error: ', error);\n    }\n}"
      },
      {
        "name": "getAllAuditedCoordinators",
        "kind": "function",
        "signature": "export async function getAllAuditedCoordinators(): Promise<\n    AuditedCoordinator[]\n> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: coordinators, error: coordinatorError } = await supabase\n        .from('employees')\n        .select('authorization, display_name, id')\n        .in('authorization', ['coordinator', 'lead-coordinator', 'admin']);\n\n    if (coordinatorError) {\n        console.error(\n            'getAllAuditedCoordinators - coordinators',\n            coordinatorError\n        );\n        return [];\n    }\n\n    if (!coordinators) {\n        return [];\n    }\n\n    const auditedCoordinators = await Promise.all(\n        coordinators.map(async (coordinator) => {\n            const { id } = coordinator;\n\n            const { count: messageSentCount, error: messageError } =\n                await supabase\n                    .from('coordinator_activity_audit')\n                    .select('id', { count: 'exact', head: true })\n                    .eq('coordinator_id', id)\n                    .eq('action', 'message_thread');\n\n            const { count: threadViewedCount, error: threadError } =\n                await supabase\n                    .from('coordinator_activity_audit')\n                    .select('id', { count: 'exact', head: true })\n                    .eq('coordinator_id', id)\n                    .eq('action', 'view_thread');\n\n            const { data: statusTagUpdates, error: statusUpdatesError } =\n                await supabase\n                    .from('coordinator_activity_audit')\n                    .select('id, metadata')\n                    .eq('coordinator_id', id)\n                    .eq('action', 'tag_order');\n\n            const statusTagUpdateCount = statusTagUpdates\n                ? statusTagUpdates.length\n                : 0;\n\n            //count the number of messages 'answered' by the coordinator\n            let messagesAnsweredCount = 0;\n            if (statusTagUpdates) {\n                messagesAnsweredCount = statusTagUpdates.reduce(\n                    (acc, update) => {\n                        if (\n                            update.metadata.previous_status_tag ===\n                                'Coordinator' ||\n                            update.metadata.previous_status_tag === 'ID/Docs' ||\n                            update.metadata.previous_status_tag === 'Follow Up'\n                        ) {\n                            acc++;\n                        }\n                        return acc;\n                    },\n                    0\n                );\n            }\n\n            if (messageError || threadError || statusUpdatesError) {\n                console.error('getAllAuditedCoordinators - activity counts', {\n                    messageError,\n                    threadError,\n                    statusUpdatesError,\n                });\n            }\n\n            return {\n                authorization: coordinator.authorization,\n                display_name: coordinator.display_name,\n                id: coordinator.id,\n                messages_sent: messageSentCount || 0,\n                thread_views: threadViewedCount || 0,\n                status_tag_updates: statusTagUpdateCount || 0,\n                messages_answered: messagesAnsweredCount || 0,\n            };\n        })\n    );\n\n    return auditedCoordinators;\n}"
      },
      {
        "name": "getCoordinatorProcessedTagCountFromDateRange",
        "kind": "function",
        "signature": "export async function getCoordinatorProcessedTagCountFromDateRange(\n    start_date: Date,\n    end_date: Date\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_coordinator_processed_tag_count',\n        {\n            start_date: start_date,\n            end_date: end_date,\n        }\n    );\n\n    if (error) {\n        console.error('getCoordinatorProcessedTagCountFromDateRange', error);\n    }\n\n    return data;\n}"
      },
      {
        "name": "getCoordinatorDashboardCount",
        "kind": "function",
        "signature": "export async function getCoordinatorDashboardCount() {\n    const { data: completeOrderData, error: orderError } =\n        await getAllOrdersForCoordinatorOrderTable();\n\n    const renewalOrderData =\n        await getAllRenewalOrdersForCoordinatorOrderTable();\n\n    const count = completeOrderData.length + renewalOrderData.length;\n\n    return count;\n}"
      },
      {
        "name": "getCoordinatorActivityAuditCountsBetweenDates",
        "kind": "function",
        "signature": "export async function getCoordinatorActivityAuditCountsBetweenDates(\n    coordinatorId: string,\n    start_date: number,\n    end_date: number\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { count: coordinatorMessagesAnswered, error: messagesAnsweredError } =\n        await supabase\n            .from('coordinator_activity_audit')\n            .select('*', { count: 'exact', head: true })\n            .eq('coordinator_id', coordinatorId)\n            .in('action', ['message_thread'])\n            // .eq('metadata->>current_status_tag', 'ProviderMessage')\n            .neq('metadata->>last_message_sender', coordinatorId)\n            .gt('timestamp', start_date)\n            .lt('timestamp', end_date);\n\n    const { count: completedTasks, error: completedError } = await supabase\n        .from('coordinator_tasks')\n        .select('*', { count: 'exact', head: true })\n        .eq('assigned_coordinator', coordinatorId)\n        .eq('completion_status', 'completed')\n        .gt('created_at', start_date)\n        .lt('created_at', end_date);\n\n    const { count: forwardedTasks, error: forwardedError } = await supabase\n        .from('coordinator_tasks')\n        .select('*', { count: 'exact', head: true })\n        .eq('assigned_coordinator', coordinatorId)\n        .eq('completion_status', 'forwarded')\n        .gt('created_at', start_date)\n        .lt('created_at', end_date);\n\n    const totalTasks = (completedTasks || 0) + (forwardedTasks || 0);\n    const forwardPercentage =\n        totalTasks > 0\n            ? (((forwardedTasks || 0) / totalTasks) * 100).toFixed(1)\n            : undefined;\n\n    return {\n        coordinatorMessagesAnswered,\n        forwardPercentage,\n    };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/coordinator_activity_audit/coordinator_activity_audit-api.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/tab-column/message/message-display.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/order-charts/components/StatusDropdown.tsx",
      "bioverse-client/app/utils/functions/coordinator-portal/time-tracker/coordinator-time-tracker-functions.ts",
      "bioverse-client/app/components/coordinator-portal/tasks/task-action-page/utils/task-action-data-fetch.ts",
      "bioverse-client/app/components/coordinator-portal/navbar/start-session-button/start-session-button.tsx",
      "bioverse-client/app/utils/database/controller/provider_activity_audit/provider_activity_audit-api.ts",
      "bioverse-client/app/utils/functions/provider-portal/time-tracker/provider-time-tracker-functions.ts",
      "bioverse-client/app/components/registered-nurse-portal/nav-bar/registered-nurse-nav-bar.tsx",
      "bioverse-client/app/hooks/useSessionTimeout.ts",
      "bioverse-client/app/layout.tsx",
      "bioverse-client/_deprecated/track-hours/coordinator-time-tracker-content.tsx",
      "bioverse-client/app/components/admin/task-overview/task-overview-container.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/coordinator_activity_audit/coordinator_activity_audit.d.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/controller/coordinator_tasks/coordinator-task-api.ts",
    "exports": [
      {
        "name": "getLastCoordinatorTask",
        "kind": "function",
        "signature": "export async function getLastCoordinatorTask(userId: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: taskListData, error: taskListError } = await supabase\n        .from('coordinator_tasks')\n        .select('*')\n        .eq('assigned_coordinator', userId)\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .maybeSingle();\n\n    if (taskListError) {\n        console.error(\n            'getTaskList error - ',\n            ' Error details: ',\n            taskListError.message\n        );\n        return { data: null, status: Status.Error };\n    }\n\n    if (isEmpty(taskListData)) {\n        return { data: null, status: Status.Success };\n    }\n\n    return {\n        data: taskListData as CoordinatorTaskSupabaseRecord,\n        status: Status.Success,\n    };\n}"
      },
      {
        "name": "createCoordinatorTaskFromStatusTagData",
        "kind": "function",
        "signature": "export async function createCoordinatorTaskFromStatusTagData(\n    status_tag_object: StatusTagObject,\n    type: string,\n    coordinator_id: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    let isRenewalOrder: boolean;\n    let status_order_id: number;\n\n    console.log('status_tag_object: ', status_tag_object);\n\n    if (\n        typeof status_tag_object.order_id === 'string' &&\n        status_tag_object.order_id.includes('-')\n    ) {\n        status_order_id = parseInt(status_tag_object.order_id.split('-')[0]);\n        isRenewalOrder = true;\n    } else {\n        status_order_id = parseInt(status_tag_object.order_id);\n        isRenewalOrder = false;\n    }\n\n    const task_object: Partial<CoordinatorTaskSupabaseRecord> = {\n        original_created_at: status_tag_object.created_at,\n        order_id: status_order_id,\n        ...(isRenewalOrder\n            ? { renewal_order_id: status_tag_object.order_id }\n            : {}),\n        completion_status: 'pending',\n        assigned_coordinator: coordinator_id,\n        type: type,\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT!,\n    };\n\n    const { data, error } = await supabase\n        .from('coordinator_tasks')\n        .insert(task_object)\n        .select('*')\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        console.error('createCoordinatorTaskFromStatusTagData error: ', error);\n        return { status: Status.Error };\n    }\n\n    return { id: data.id, status: Status.Success };\n}"
      },
      {
        "name": "createTaskFromOrderOrRenewalData",
        "kind": "function",
        "signature": "export async function createTaskFromOrderOrRenewalData(\n    orderType: OrderType,\n    type: string,\n    coordinator_id: string,\n    order_data?: TaskOrderObject,\n    renewal_data?: TaskRenewalObject\n) {\n    const supabase = createSupabaseServiceClient();\n\n    if (orderType === OrderType.RenewalOrder && renewal_data) {\n        const renewals_original_order_id = parseInt(\n            renewal_data.renewal_order_id.split('-')[0]\n        );\n\n        const task_object: Partial<CoordinatorTaskSupabaseRecord> = {\n            original_created_at:\n                renewal_data.submission_time ?? new Date().toISOString(),\n            order_id: renewals_original_order_id,\n            renewal_order_id: renewal_data.renewal_order_id,\n            completion_status: 'pending',\n            assigned_coordinator: coordinator_id,\n            type: type,\n            environment: process.env.NEXT_PUBLIC_ENVIRONMENT!,\n        };\n\n        const { data, error } = await supabase\n            .from('coordinator_tasks')\n            .insert(task_object)\n            .select('*')\n            .limit(1)\n            .maybeSingle();\n\n        if (error) {\n            console.error(\n                'createTaskFromOrderOrRenewalData error: ',\n                error.message\n            );\n        }\n\n        return { id: data.id, status: Status.Success };\n    } else if (orderType === OrderType.Order && order_data) {\n        const task_object: Partial<CoordinatorTaskSupabaseRecord> = {\n            original_created_at: order_data.created_at,\n            order_id: order_data.order_id,\n            renewal_order_id: undefined,\n            completion_status: 'pending',\n            assigned_coordinator: coordinator_id,\n            type: type,\n            environment: process.env.NEXT_PUBLIC_ENVIRONMENT!,\n        };\n\n        const { data, error } = await supabase\n            .from('coordinator_tasks')\n            .insert(task_object)\n            .select('*')\n            .limit(1)\n            .maybeSingle();\n\n        if (error) {\n            console.error(\n                'createTaskFromOrderOrRenewalData error: ',\n                error.message\n            );\n        }\n\n        return { id: data.id, status: Status.Success };\n    }\n\n    return { id: null, status: Status.Error };\n}"
      },
      {
        "name": "updateTaskCompletionStatus",
        "kind": "function",
        "signature": "export async function updateTaskCompletionStatus(\n    task_id: string,\n    new_status: CoordinatorTaskStatus\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('coordinator_tasks')\n        .update({ completion_status: new_status })\n        .eq('id', task_id);\n\n    if (error) {\n        console.error(\n            'updateTaskCompletionStatus: ',\n            task_id,\n            ' error msg: ',\n            error.message\n        );\n        return { status: Status.Error };\n    }\n}"
      },
      {
        "name": "getTaskOrderIdFromTaskId",
        "kind": "function",
        "signature": "export async function getTaskOrderIdFromTaskId(taskId: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('coordinator_tasks')\n        .select('order_id, renewal_order_id')\n        .eq('id', taskId)\n        .limit(1)\n        .maybeSingle();\n\n    if (data?.renewal_order_id) {\n        return data.renewal_order_id as string;\n    }\n\n    return data?.order_id as string;\n}"
      },
      {
        "name": "getTaskCompletionCount",
        "kind": "function",
        "signature": "export async function getTaskCompletionCount() {\n    const supabase = createSupabaseServiceClient();\n\n    const userId = (await readUserSession()).data.session?.user.id!;\n\n    function getBeginningOfMonth(): string {\n        const now = new Date();\n        const beginningOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);\n        return beginningOfMonth.toISOString();\n    }\n    const beginningOfMonth = getBeginningOfMonth();\n\n    const { count, error } = await supabase\n        .from('coordinator_tasks')\n        .select('*', { count: 'exact', head: true })\n        .eq('assigned_coordinator', userId)\n        .eq('completion_status', 'completed')\n        .eq('type', 'intake')\n        .gt('created_at', beginningOfMonth);\n\n    if (error) {\n        console.error(error);\n    }\n\n    return count;\n}"
      },
      {
        "name": "getMessagingTaskCompletionCount",
        "kind": "function",
        "signature": "export async function getMessagingTaskCompletionCount() {\n    const supabase = createSupabaseServiceClient();\n\n    const userId = (await readUserSession()).data.session?.user.id!;\n\n    function getBeginningOfMonth(): string {\n        const now = new Date();\n        const beginningOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);\n        return beginningOfMonth.toISOString();\n    }\n    const beginningOfMonth = getBeginningOfMonth();\n\n    const { count, error } = await supabase\n        .from('coordinator_tasks')\n        .select('*', { count: 'exact', head: true })\n        .eq('assigned_coordinator', userId)\n        .eq('completion_status', 'completed')\n        .eq('type', 'message')\n        .gt('created_at', beginningOfMonth);\n\n    if (error) {\n        console.error(error);\n        return 0;\n    }\n\n    return count ?? 0;\n}"
      },
      {
        "name": "getTodaysTaskCompletionCount",
        "kind": "function",
        "signature": "export async function getTodaysTaskCompletionCount() {\n    const supabase = createSupabaseServiceClient();\n\n    function getMidnightOfPreviousDay(): string {\n        const now = new Date();\n        const previousDay = new Date(now);\n        previousDay.setDate(now.getDate() - 1);\n        previousDay.setHours(0, 0, 0, 0);\n        return previousDay.toISOString();\n    }\n\n    const { count, error } = await supabase\n        .from('coordinator_tasks')\n        .select('*', { count: 'exact', head: true })\n        .eq('completion_status', 'completed')\n        .eq('environment', process.env.NEXT_PUBLIC_ENVIRONMENT!)\n        .gte('created_at', getMidnightOfPreviousDay());\n\n    return { data: count, status: Status.Success };\n}"
      },
      {
        "name": "reportTaskFailure",
        "kind": "function",
        "signature": "export async function reportTaskFailure(taskId: number) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('coordinator_tasks')\n        .update({ reported_failure: true })\n        .eq('id', taskId);\n\n    if (error) {\n        console.error('reportTaskFailure: task ID: ', taskId);\n    }\n\n    return;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/coordinator_tasks/coordinator-task-api.ts",
      "bioverse-client/app/api/coordinator-portal/tasks/route.ts",
      "bioverse-client/app/utils/database/controller/tasks/task-api.ts",
      "bioverse-client/app/api/provider-portal/tasks/route.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/containers/components/coordinator-task-action-info-bar.tsx",
      "bioverse-client/app/components/provider-portal/tasks/task-action-page/components/task-action-info-bar.tsx",
      "bioverse-client/app/(employee)/(registered-nurse-portal)/registered-nurse/tasks/[taskId]/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/tasks/[taskId]/page.tsx",
      "bioverse-client/app/components/provider-portal/tasks/task-action-page/components/task-action-container.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/review-container/provider-review-container.tsx",
      "bioverse-client/app/components/provider-portal/tasks/task-action-page/utils/task-action-data-fetch.ts",
      "bioverse-client/app/components/provider-portal/tasks/task-counter-view/functions/getAllTaskCount.ts",
      "bioverse-client/app/components/provider-portal/tasks/task-action-page/components/intake-view-task-container.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/provider-review-ui.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/custom_orders/custom_orders_api.ts",
    "exports": [
      {
        "name": "insertNewCustomOrder",
        "kind": "function",
        "signature": "export async function insertNewCustomOrder(\n    custom_order_id: string,\n    reference_order_id: string,\n    prescription_json: any,\n    sender_id: string,\n    product_href: string,\n    patient_id: string,\n) {\n    const supabase = createSupabaseServiceClient();\n\n    await supabase.from('custom_orders').insert({\n        custom_order_id,\n        reference_order_id,\n        prescription_json,\n        order_status: CustomOrderStatus.PharmacyProcessing,\n        sender_id,\n        product_href,\n        patient_id,\n    });\n}"
      },
      {
        "name": "generateCustomOrderIdForReferenceOrder",
        "kind": "function",
        "signature": "export async function generateCustomOrderIdForReferenceOrder(\n    reference_order_id: string,\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('custom_orders')\n        .select('*')\n        .eq('reference_order_id', reference_order_id)\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error(`generateCustomOrderId Error ${error}`);\n        throw new Error(error.message);\n    }\n\n    if (!data) {\n        return generateCustomOrderId(reference_order_id, 0);\n    }\n\n    return generateCustomOrderId(reference_order_id, data.length);\n}"
      },
      {
        "name": "isCustomOrder",
        "kind": "function",
        "signature": "export async function isCustomOrder(order_id: string) {\n    return order_id.includes('custom');\n}"
      },
      {
        "name": "getOrderType",
        "kind": "function",
        "signature": "export async function getOrderType(order_id: string, pharmacy: string) {\n    if (await isRenewalOrder(order_id, pharmacy)) {\n        return OrderType.RenewalOrder;\n    } else if (await isCustomOrder(order_id)) {\n        return OrderType.CustomOrder;\n    } else {\n        return OrderType.Order;\n    }\n}"
      },
      {
        "name": "shouldCreateEasypostTrackerForCustomOrder",
        "kind": "function",
        "signature": "export async function shouldCreateEasypostTrackerForCustomOrder(\n    custom_order_id: string,\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('custom_orders')\n        .select('*')\n        .eq('custom_order_id', custom_order_id)\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .single();\n\n    if (error) {\n        console.error('error shouldCreateEasypostTrackerForCustomOrder', error);\n        return true;\n    }\n\n    if (!data || !data.easypost_tracking_id) {\n        return true;\n    }\n    return false;\n}"
      },
      {
        "name": "updateCustomOrder",
        "kind": "function",
        "signature": "export async function updateCustomOrder(custom_order_id: string, payload: any) {\n    const supabase = createSupabaseServiceClient();\n\n    await supabase\n        .from('custom_orders')\n        .update(payload)\n        .eq('custom_order_id', custom_order_id);\n}"
      },
      {
        "name": "getCustomOrder",
        "kind": "function",
        "signature": "export async function getCustomOrder(\n    custom_order_id: string,\n): Promise<CustomOrder> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('custom_orders')\n        .select('*')\n        .eq('custom_order_id', custom_order_id)\n        .limit(1)\n        .single();\n\n    if (error) {\n        console.error('getCustomOrderError', custom_order_id);\n        throw new Error(error.message);\n    }\n\n    return data as CustomOrder;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/custom_orders/custom_orders_api.ts",
      "bioverse-client/app/api/empower/send-script/route.ts",
      "bioverse-client/app/services/pharmacy-integration/empower/provider-script-feedback.ts",
      "bioverse-client/app/utils/database/controller/orders/orders-api.ts",
      "bioverse-client/app/utils/actions/intake/order-util.ts",
      "bioverse-client/app/utils/functions/client-utils.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/IDAndSelfieCheckJobHandler.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/SendPrescriptionJobHandler.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/containers/components/ReviewModal.tsx",
      "bioverse-client/app/services/pharmacy-integration/empower/update-order.ts",
      "bioverse-client/app/api/easypost/route.tsx",
      "bioverse-client/app/services/easypost/easypost-tracker.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/customerio_audit/audit_customerio.ts",
    "exports": [
      {
        "name": "auditCustomerioFailure",
        "kind": "function",
        "signature": "export async function auditCustomerioFailure(\n    user_id: string,\n    event_name: string,\n    payload: any,\n    error: any,\n) {\n    const supabase = createSupabaseServiceClient();\n\n    await supabase\n        .from('audit_customerio')\n        .insert({ user_id, event: event_name, payload, error });\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/customerio_audit/audit_customerio.ts",
      "bioverse-client/app/services/customerio/customerioApiFactory.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/dose_spot_webhook_audit/dose-spot-webhook-audit.ts",
    "exports": [
      {
        "name": "insertDoseSpotWebhookAudit",
        "kind": "function",
        "signature": "export async function insertDoseSpotWebhookAudit(\n    json_payload: any,\n    status_update_data: any,\n    prescription_data: any\n) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { error } = await supabase.from('dose_spot_webhook_audit').insert({\n        json_payload: json_payload,\n        status_update_data: status_update_data,\n        prescription_data: prescription_data,\n    });\n\n    if (error) {\n        return { error: error };\n    }\n\n    return { error: null };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/dose_spot_webhook_audit/dose-spot-webhook-audit.ts",
      "bioverse-client/app/api/dosespot/_event-type-cases/handlePrescriptionResult.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/ds_match_failures/ds-match-failures.ts",
    "exports": [
      {
        "name": "insertNewOrderMatchFailure",
        "kind": "function",
        "signature": "export async function insertNewOrderMatchFailure(\n    prescriptionData: any,\n    statusUpdateJson: any,\n    testedOrderData: any,\n    issueCause: string,\n    errorData: any,\n) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { error: dataInsertError } = await supabase\n        .from('ds_match_failures')\n        .insert({\n            created_at: new Date(),\n            prescription_data: prescriptionData,\n            status_update_json: statusUpdateJson,\n            tested_order_data: testedOrderData,\n            issue_cause: issueCause,\n            error_data: errorData,\n        });\n\n    if (dataInsertError) {\n        console.log(\n            'Controller tablename: ds_match_failures, method: insertNewOrderMatchFailure, Error: ',\n            dataInsertError,\n        );\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/ds_match_failures/ds-match-failures.ts",
      "bioverse-client/app/api/dosespot/_event-actions/dose-spot/order-matcher.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/employees/employees-api.ts",
    "exports": [
      {
        "name": "getEmployeeRecordById",
        "kind": "function",
        "signature": "export async function getEmployeeRecordById(employee_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('employees')\n        .select('*')\n        .eq('id', employee_id)\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        return null;\n    }\n\n    return data;\n}"
      },
      {
        "name": "getEmployeeAuthorization",
        "kind": "function",
        "signature": "export async function getEmployeeAuthorization(\n    user_id: string\n): Promise<BV_AUTH_TYPE | null> {\n    const supabase = createSupabaseServiceClient();\n\n    try {\n        const { data, error } = await supabase\n            .from('employees')\n            .select('authorization')\n            .eq('id', user_id)\n            .maybeSingle();\n\n        if (error) {\n            console.error('getProviderRole', error);\n            return null;\n        }\n\n        return data?.authorization as BV_AUTH_TYPE;\n    } catch (error: any) {\n        console.error('getProviderRole caught error', error);\n        return null;\n    }\n}"
      },
      {
        "name": "getCurrentEmployeeRole",
        "kind": "function",
        "signature": "export async function getCurrentEmployeeRole(): Promise<BV_AUTH_TYPE | null> {\n    const supabase = createSupabaseServiceClient();\n\n    try {\n        const user_id = (await readUserSession()).data.session?.user.id;\n\n        if (!user_id) {\n            return null;\n        }\n\n        const { data, error } = await supabase\n            .from('employees')\n            .select('authorization')\n            .eq('id', user_id)\n            .limit(1)\n            .maybeSingle();\n\n        if (error) {\n            console.error('getCurrentEmployeeRole', error);\n            return null;\n        }\n\n        return data?.authorization;\n    } catch (error: any) {\n        console.error('getCurrentEmployeeRole', error);\n        return null;\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/employees/employees-api.ts",
      "bioverse-client/app/utils/actions/auth/session-reader.ts",
      "bioverse-client/app/(employee)/(registered-nurse-portal)/registered-nurse/dashboard/page.tsx",
      "bioverse-client/app/(employee)/(registered-nurse-portal)/registered-nurse/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/page.tsx",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/containers/components/coordinator-task-action-info-bar.tsx",
      "bioverse-client/app/components/login/login-drawer/login-drawer-container.tsx",
      "bioverse-client/app/(employee)/(registered-nurse-portal)/registered-nurse/tasks/page.tsx",
      "bioverse-client/app/(employee)/(registered-nurse-portal)/registered-nurse/tasks/[taskId]/page.tsx",
      "bioverse-client/app/(employee)/(registered-nurse-portal)/registered-nurse/track-hours/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/tx-patient-list/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/tasks/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/tasks/[taskId]/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/intakes/[orderId]/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/track-hours/page.tsx",
      "bioverse-client/app/(employee)/(coordinator-portal)/coordinator/tasks/page.tsx",
      "bioverse-client/app/(employee)/(coordinator-portal)/coordinator/track-hours/page.tsx",
      "bioverse-client/app/components/coordinator-portal/tasks/task-action-page/utils/task-action-data-fetch.ts",
      "bioverse-client/app/api/coordinator-portal/tasks/route.ts",
      "bioverse-client/app/api/provider-portal/tasks/route.ts",
      "bioverse-client/_deprecated/clinical-intake-flow/order-table/utils/assign-provider-helper.ts",
      "bioverse-client/app/(testing_and_development)/layout.tsx",
      "bioverse-client/app/auth/layout.tsx",
      "bioverse-client/app/(administration)/admin/app-control/page.tsx",
      "bioverse-client/app/(administration)/layout.tsx",
      "bioverse-client/app/utils/actions/auth/authorization.ts",
      "bioverse-client/app/(employee)/(registered-nurse-portal)/registered-nurse/layout.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/all-patients/[patient_id]/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/layout.tsx",
      "bioverse-client/app/(employee)/layout.tsx",
      "bioverse-client/app/(employee)/(coordinator-portal)/layout.tsx",
      "bioverse-client/app/components/provider-portal/order-table/utils/assign-provider-helper.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/utils/verify-intake-view-permission.ts",
      "bioverse-client/app/(content)/layout.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/employees/employees-database-type.d.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/controller/escalations/escalations-api.ts",
    "exports": [
      {
        "name": "createSupabaseEscalation",
        "kind": "function",
        "signature": "export async function createSupabaseEscalation(\n    escalation_data: EscalationDataObject\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase.from('escalations').insert({\n        ...escalation_data,\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT!,\n    });\n\n    if (error) {\n        return Status.Error;\n    }\n\n    await triggerEvent(\n        '2eb849bc-62cf-46a0-b0ef-25b0b0efcdfd',\n        'escalate-order',\n        {\n            content: escalation_data.metadata.email_content,\n        }\n    );\n\n    return Status.Success;\n}"
      },
      {
        "name": "createSupabaseEscalationByPharmacy",
        "kind": "function",
        "signature": "export async function createSupabaseEscalationByPharmacy(\n    escalation_data: EscalationDataObject,\n    event: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase.from('escalations').insert({\n        ...escalation_data,\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT!,\n    });\n\n    if (error) {\n        return Status.Error;\n    }\n\n    await triggerEvent('2eb849bc-62cf-46a0-b0ef-25b0b0efcdfd', event, {\n        content: escalation_data.metadata.email_content,\n    });\n\n    return Status.Success;\n}"
      },
      {
        "name": "getAllEscalations",
        "kind": "function",
        "signature": "export async function getAllEscalations() {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('escalations')\n        .select(\n            '*, patient:profiles!patient_id(first_name, last_name), escalator:employees!escalated_by(display_name)'\n        )\n        .order('status', { ascending: true })\n        .order('created_at', { ascending: false })\n        .eq('environment', process.env.NEXT_PUBLIC_ENVIRONMENT!);\n\n    return data as PatientEscalationData[];\n}"
      },
      {
        "name": "getAllPatientEscalations",
        "kind": "function",
        "signature": "export async function getAllPatientEscalations(patient_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('escalations')\n        .select(\n            '*, patient:profiles!patient_id(first_name, last_name), escalator:employees!escalated_by(display_name)'\n        )\n        .order('status', { ascending: true })\n        .order('created_at', { ascending: false })\n        .eq('patient_id', patient_id);\n\n    return data as PatientEscalationData[];\n}"
      },
      {
        "name": "changeEscalationStatus",
        "kind": "function",
        "signature": "export async function changeEscalationStatus(\n    escalation_id: string | number,\n    new_status: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('escalations')\n        .update({ status: new_status, last_updated_at: new Date() })\n        .eq('id', escalation_id);\n\n    if (error) {\n        return Status.Error;\n    }\n\n    return Status.Success;\n}"
      },
      {
        "name": "editEscalationNote",
        "kind": "function",
        "signature": "export async function editEscalationNote(\n    escalation_id: string | number,\n    newNote: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('escalations')\n        .update({ note: newNote, last_updated_at: new Date() })\n        .eq('id', escalation_id);\n\n    if (error) {\n        return Status.Error;\n    }\n\n    return Status.Success;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/escalations/escalations-api.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/escalation/escalate-renewal-order-dialog.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/escalation/escalate-order-dialog.tsx",
      "bioverse-client/app/components/admin/all-orders/escalation/escalate-order-dialog.tsx",
      "bioverse-client/app/components/coordinator-portal/escalation-dashboard/components/escalation-dashboard-container.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/escalations/escalations-allpatients-content.tsx",
      "bioverse-client/app/components/coordinator-portal/escalation-dashboard/components/escalation-table-row.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/escalations/components/escalation-table-row-all-patients.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/escalations/components/edit-escalation-note-dialog.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/internal_notes/internal-notes-api.ts",
    "exports": [
      {
        "name": "createNewInternalNote",
        "kind": "function",
        "signature": "export async function createNewInternalNote(\n    written_by_id: string,\n    note: string,\n    order_id: string | number,\n    patient_id: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase.from('internal_notes').insert({\n        written_by: written_by_id,\n        note: note,\n        order_id: order_id,\n        patient_id: patient_id,\n    });\n\n    if (error) {\n        console.error(\n            'createNewInternalNote - error. Details: patient ID: ',\n            patient_id,\n            ' order ID: ',\n            order_id,\n            ' written by ID: ',\n            written_by_id,\n            ' error message: ',\n            error.message\n        );\n        return Status.Error;\n    }\n\n    return Status.Success;\n}"
      },
      {
        "name": "getInternalNotesForPatientId",
        "kind": "function",
        "signature": "export async function getInternalNotesForPatientId(patient_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('internal_notes')\n        .select('*, employee:employees!written_by(display_name)')\n        .eq('patient_id', patient_id);\n\n    if (error) {\n        console.error(\n            'getInternalNotesForPatientId, patient ID: ',\n            patient_id,\n            ' error message: ',\n            error\n        );\n        return null;\n    }\n\n    return data;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/internal_notes/internal-notes-api.ts",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/coordinator-manual-internal-note/coordinator-manual-internal-note.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/internal-notes/add-manual-note-dialog.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/internal-notes/internal-notes-tab.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/patient-information/internal-notes-accordion/internal-notes-accordion.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/job-scheduler/job-scheduler-actions.ts",
    "exports": [
      {
        "name": "handleJobSuccess",
        "kind": "function",
        "signature": "export async function handleJobSuccess(job: JobScheduler) {\n    const supabase = createSupabaseServiceClient();\n\n    await supabase\n        .from('job_scheduler')\n        .update({\n            status: JobSchedulerStatus.Completed,\n            last_run_at: new Date().toISOString(),\n        })\n        .eq('job_id', job.job_id);\n}"
      },
      {
        "name": "handleJobFailure",
        "kind": "function",
        "signature": "export async function handleJobFailure(\n    job: JobScheduler,\n    newScheduleTime: Date,\n    shouldRetry: boolean\n) {\n    const supabase = createSupabaseServiceClient();\n\n    if (shouldRetry) {\n        const exceededRetries = job.retry_count + 1 >= job.max_retries;\n\n        await supabase\n            .from('job_scheduler')\n            .update({\n                status: exceededRetries\n                    ? JobSchedulerStatus.Expired\n                    : job.status,\n                last_run_at: new Date().toISOString(),\n                retry_count: job.retry_count + 1,\n                schedule_time: newScheduleTime.toISOString(),\n            })\n            .eq('job_id', job.job_id);\n\n        if ('order_id' in job.metadata) {\n            await forwardOrderToEngineering(\n                job.metadata.order_id,\n                null,\n                EngineeringQueueNotes.RetryExpired\n            );\n        }\n    } else {\n        await supabase\n            .from('job_scheduler')\n            .update({\n                status: JobSchedulerStatus.Expired,\n                last_run_at: new Date().toISOString(),\n                retry_count: job.retry_count + 1,\n            })\n            .eq('job_id', job.job_id);\n\n        if ('order_id' in job.metadata) {\n            const statusTag = await getStatusTagForOrder(job.metadata.order_id);\n            if (!statusTag.data.status_tags?.includes(StatusTag.Engineer)) {\n                await forwardOrderToEngineering(\n                    job.metadata.order_id,\n                    null,\n                    EngineeringQueueNotes.RetryExpired\n                );\n            }\n        }\n    }\n}"
      },
      {
        "name": "auditJobScheduler",
        "kind": "function",
        "signature": "export async function auditJobScheduler(\n    job: JobScheduler,\n    status: Status,\n    reason: string | null\n) {\n    const supabase = createSupabaseServiceClient();\n\n    await supabase.from('job_scheduler_audit').insert({\n        job_id: job.job_id,\n        job_type: job.job_type,\n        status,\n        retry_count: job.retry_count,\n        reason,\n        metadata: job.metadata,\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n    });\n}"
      },
      {
        "name": "processJob",
        "kind": "function",
        "signature": "export async function processJob(jobData: JobScheduler) {\n    const jobFactory = new JobSchedulerFactory(jobData);\n    try {\n        await jobFactory.executeJob();\n        console.log('Job executed successfully.');\n    } catch (error: any) {\n        console.error(`Job execution failed: ${error.message}`);\n    }\n}"
      },
      {
        "name": "createNewSendPrescriptionJob",
        "kind": "function",
        "signature": "export async function createNewSendPrescriptionJob(order_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    await supabase.from('job_scheduler').insert({\n        job_type: JobSchedulerTypes.SendPrescription,\n        schedule_time: new Date().toISOString(),\n        status: JobSchedulerStatus.Active,\n        metadata: { order_id },\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n    });\n}"
      },
      {
        "name": "createNewStripeInvoicePaidJob",
        "kind": "function",
        "signature": "export async function createNewStripeInvoicePaidJob(\n    order_id: string,\n    invoice_id: string,\n    stripe_subscription_id: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    await supabase.from('job_scheduler').insert({\n        job_type: JobSchedulerTypes.StripeInvoicePaid,\n        schedule_time: new Date().toISOString(),\n        status: JobSchedulerStatus.Active,\n        metadata: { order_id, invoice_id, stripe_subscription_id },\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n    });\n    console.log('stripe invoice job created');\n}"
      },
      {
        "name": "createNewAutoRenewalJob",
        "kind": "function",
        "signature": "export async function createNewAutoRenewalJob(patient_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    await supabase.from('job_scheduler').insert({\n        job_type: JobSchedulerTypes.RenewalAutoship,\n        schedule_time: new Date().toISOString(),\n        status: JobSchedulerStatus.Active,\n        metadata: { patient_id },\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n    });\n}"
      },
      {
        "name": "createNewIDAndSelfieCheckPostCheckoutJob",
        "kind": "function",
        "signature": "export async function createNewIDAndSelfieCheckPostCheckoutJob(\n    patient_id: string,\n    order_id: string,\n    product_href: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const tenMinutesFromNow = new Date(\n        Date.now() + 10 * 60 * 1000\n    ).toISOString();\n\n    await supabase.from('job_scheduler').insert({\n        job_type: JobSchedulerTypes.IDAndSelfieCheck,\n        schedule_time: tenMinutesFromNow,\n        status: JobSchedulerStatus.Active,\n        metadata: { patient_id, order_id, product_href },\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n    });\n}"
      },
      {
        "name": "markIDAndSelfieCheckJobCompleted",
        "kind": "function",
        "signature": "export async function markIDAndSelfieCheckJobCompleted(patient_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data } = await supabase\n        .from('job_scheduler')\n        .update({ status: JobSchedulerStatus.Completed })\n        .eq('job_type', JobSchedulerTypes.IDAndSelfieCheck)\n        .eq('metadata->>patient_id', patient_id)\n        .select();\n\n    if (data && data[0]) {\n        const order_id = data[0].metadata.order_id;\n\n        if (order_id) {\n            const order = await getBaseOrderById(order_id);\n\n            if (order) {\n                if (order.order_status === OrderStatus.UnapprovedCardDown) {\n                    await updateStatusTagToReview(patient_id, String(order.id));\n                }\n            }\n        }\n    }\n}"
      },
      {
        "name": "createNewCommsJob",
        "kind": "function",
        "signature": "export async function createNewCommsJob(\n    jobType: JobSchedulerTypes,\n    nextStep: ScheduledComm,\n    metadata: CustomerIOCommsMetadata\n) {\n    const supabase = createSupabaseServiceClient();\n\n    await supabase.from('job_scheduler').insert({\n        job_type: jobType,\n        schedule_time: nextStep.sendDate.toISOString(),\n        status: JobSchedulerStatus.Active,\n        metadata: metadata,\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n    });\n}"
      },
      {
        "name": "createNewSpecificCommsJob",
        "kind": "function",
        "signature": "export async function createNewSpecificCommsJob(\n    jobType: JobSchedulerTypes,\n    endDate: string,\n    metadata: any\n) {\n    const supabase = createSupabaseServiceClient();\n\n    await supabase.from('job_scheduler').insert({\n        job_type: jobType,\n        schedule_time: endDate,\n        status: JobSchedulerStatus.Active,\n        metadata: metadata,\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n    });\n}"
      },
      {
        "name": "createNewFirstTimeCommJob",
        "kind": "function",
        "signature": "export async function createNewFirstTimeCommJob(\n    jobType: JobSchedulerTypes,\n    user_id: string,\n    subscription_id: number\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const metadata: CustomerIOCommsMetadata = {\n        user_id,\n        subscription_id,\n        current_step: -1,\n    };\n\n    await supabase.from('job_scheduler').insert({\n        job_type: jobType,\n        schedule_time: new Date().toISOString(),\n        status: JobSchedulerStatus.Active,\n        metadata: metadata,\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n    });\n}"
      },
      {
        "name": "getCommJobForSubscription",
        "kind": "function",
        "signature": "export async function getCommJobForSubscription(\n    subscription_id: number\n): Promise<JobScheduler> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('job_scheduler')\n        .select('*')\n        .eq('metadata ->> subscription_id', subscription_id)\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .single();\n\n    if (error) {\n        throw new Error(\n            `Failed to getCommJobForSubscription: ${subscription_id}`\n        );\n    }\n\n    return data as JobScheduler;\n}"
      },
      {
        "name": "createNewRenewalValidationJob",
        "kind": "function",
        "signature": "export async function createNewRenewalValidationJob(subscription_id: number) {\n    const supabase = createSupabaseServiceClient();\n\n    const metadata: RenewalValidationMetadata = {\n        subscription_id,\n    };\n\n    await supabase.from('job_scheduler').insert({\n        job_type: JobSchedulerTypes.RenewalValidation,\n        schedule_time: new Date().toISOString(),\n        status: JobSchedulerStatus.Active,\n        metadata: metadata,\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n    });\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/job-scheduler/job-scheduler-actions.ts",
      "bioverse-client/app/utils/functions/job-scheduler/BaseJobSchedulerHandler.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/BaseCommJobHandler.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/IDAndSelfieCheckJobHandler.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/SendPrescriptionJobHandler.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/RenewalValidationJobHandler.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/RenewalAutoshipJobHandler.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/StripeInvoicePaidJobHandler.ts",
      "bioverse-client/app/(testing_and_development)/ben-dev/page.tsx",
      "bioverse-client/app/api/stripe/webhook/invoice-paid/route.ts",
      "bioverse-client/app/api/renewal/autoship/route.ts",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component-ab.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v3/pages/id-verification-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/id-verification-noskip-v3.tsx",
      "bioverse-client/app/services/stripe/subscriptions.ts",
      "bioverse-client/app/api/easypost/route.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/macros/macros-api.ts",
    "exports": [
      {
        "name": "getAllMacrosByResponder",
        "kind": "function",
        "signature": "export async function getAllMacrosByResponder(\n    responder: string\n): Promise<{ macros: MacrosSBR[]; categories: any[] } | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('macros')\n        .select('*')\n        .eq('responder', responder);\n\n    const { data: macrosData, error: macrosDataError } = await supabase.rpc(\n        'get_distinct_categories',\n        { responder_: responder }\n    );\n    if (error) {\n        console.error(\n            'getAllMacrosByResponder',\n            error,\n            'responder: ',\n            responder,\n            error.message\n        );\n        return null;\n    }\n\n    if (macrosDataError) {\n        console.error(\n            'getAllMacrosByResponder',\n            macrosDataError,\n            'responder: ',\n            responder,\n            macrosDataError.message\n        );\n    }\n\n    return { macros: data as MacrosSBR[], categories: macrosData };\n}"
      },
      {
        "name": "getCategoriesByResponder",
        "kind": "function",
        "signature": "export async function getCategoriesByResponder(\n    responder: string\n): Promise<any> {\n    const supabase = await createSupabaseServiceClient();\n\n    const { data: macrosData, error: macrosDataError } = await supabase.rpc(\n        'get_distinct_categories',\n        { responder_: responder }\n    );\n\n    if (macrosDataError) {\n        console.error('Error fetching data:', macrosDataError);\n        return [];\n    }\n\n    return macrosData;\n}"
      },
      {
        "name": "getMacrosByResponder",
        "kind": "function",
        "signature": "export async function getMacrosByResponder(responder: string) {\n    const supabase = await createSupabaseServiceClient();\n\n    const { data: macrosData, error: macrosDataError } = await supabase\n        .from('macros')\n        .select('*')\n        .eq('responder', responder);\n\n    if (macrosDataError) {\n        console.log(\n            'Controller tablename: profiles, method: getIntakeProfileData, Error: ',\n            macrosDataError\n        );\n        return { data: null, error: macrosDataError };\n    }\n\n    return { data: macrosData, error: null };\n}"
      },
      {
        "name": "getMacrosByCategoryAndResponder",
        "kind": "function",
        "signature": "export async function getMacrosByCategoryAndResponder(\n    responder: string,\n    category: string\n): Promise<MacrosSBR[]> {\n    const supabase = await createSupabaseServiceClient();\n\n    const { data: macrosData, error: macrosDataError } = await supabase\n        .from('macros')\n        .select('*')\n        .eq('responder', responder)\n        .eq('category', category);\n\n    console.log(macrosData);\n    if (macrosDataError) {\n        return [];\n    }\n\n    return macrosData;\n}"
      },
      {
        "name": "getMacroById",
        "kind": "function",
        "signature": "export async function getMacroById(id: number) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('macros')\n        .select('macroHtml')\n        .eq('id', id)\n        .limit(1)\n        .single();\n\n    if (error) {\n        return { status: Status.Failure, data: null, error: error };\n    }\n\n    return { status: Status.Success, data, error: null };\n}"
      },
      {
        "name": "updateMacroTitle",
        "kind": "function",
        "signature": "export async function updateMacroTitle(\n    macroId: number | string,\n    newMacroTitle: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('macros')\n        .update({ name: newMacroTitle })\n        .eq('id', macroId);\n\n    if (error) {\n        console.error('updateMacroTitle function error: ', error.message);\n        return Status.Error;\n    }\n\n    return Status.Success;\n}"
      },
      {
        "name": "updateMacroTags",
        "kind": "function",
        "signature": "export async function updateMacroTags(\n    macroId: string | number,\n    newTags: string[]\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('macros')\n        .update({ tags: newTags })\n        .eq('id', macroId);\n\n    if (error) {\n        console.error('updateMacroTags function error: ', error.message);\n        return Status.Error;\n    }\n\n    return Status.Success;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/macros/macros-api.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/tab-column/macros/macros-display.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/macros/macros-display.tsx",
      "bioverse-client/app/utils/database/controller/messaging/messages/messages.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/id-issue-modal.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/utils/post-prescribe-macro-selector/post-prescribe-macro-selector.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approval-buttons.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/decline-dialog.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/patient-information/approval-buttons/review-approval-buttons.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/macros/dialog-menu/change-macro-title-dialog.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/macros/dialog-menu/tag-manager-dialog.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/macros/macros-dbtype.d.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/controller/macros/macros-types.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/controller/macros/macros.ts",
    "exports": [
      {
        "name": "replaceParameters",
        "kind": "function",
        "signature": "export function replaceParameters(\n    patient_data: DBPatientData,\n    providerName: string,\n    content: string,\n    credentials: string,\n    product_href?: string,\n    order_id?: string | number\n) {\n    if (patient_data.address_line1) {\n        let deliveryAddress =\n            patient_data.address_line1 +\n            ', ' +\n            patient_data.city +\n            ', ' +\n            patient_data.state +\n            ' ' +\n            patient_data.zip;\n\n        content = content.replace(\n            MacroParameters.DeliverAddress,\n            deliveryAddress\n        );\n    }\n\n    content = content.replace(\n        MacroParameters.PatientName,\n        patient_data.first_name\n    );\n\n    if (product_href) {\n        content = content.replace(\n            new RegExp(MacroParameters.ProductHref, 'g'),\n            product_href\n        );\n    }\n\n    if (order_id) {\n        content = content.replace(MacroParameters.OrderId, String(order_id));\n    }\n\n    content = content.replace(MacroParameters.ProviderName, providerName);\n\n    let signature = '<br/>' + providerName + ', ' + credentials;\n    content = content.replace(MacroParameters.Signature, signature);\n    return content;\n}"
      },
      {
        "name": "replaceParametersAutomaticSend",
        "kind": "function",
        "signature": "export function replaceParametersAutomaticSend(\n    patient_data: DBPatientData,\n    content: string,\n    providerName: string,\n    subscriptionRenewalDate: string,\n    credentials: string\n) {\n    content = content.replace(\n        MacroParameters.PatientName,\n        patient_data.first_name\n    );\n\n    content = content.replace(MacroParameters.ProviderName, providerName);\n\n    if (content.includes(MacroParameters.SubscriptionRenewalDate)) {\n        content = content.replace(\n            new RegExp(MacroParameters.SubscriptionRenewalDate, 'g'),\n            subscriptionRenewalDate\n        );\n    }\n\n    let signature = '<br/>' + providerName + ', ' + credentials;\n    content = content.replace(MacroParameters.Signature, signature);\n    return content;\n}"
      },
      {
        "name": "replaceCoordinatorParameters",
        "kind": "function",
        "signature": "export function replaceCoordinatorParameters(\n    patient_data: DBPatientData,\n    userFirstName: string,\n    userLastName: string,\n    content: string\n) {\n    if (patient_data.address_line1) {\n        let deliveryAddress =\n            patient_data.address_line1 +\n            ', ' +\n            patient_data.city +\n            ', ' +\n            patient_data.state +\n            ' ' +\n            patient_data.zip;\n\n        content = content.replace(\n            MacroParameters.DeliverAddress,\n            deliveryAddress\n        );\n    }\n\n    content = content.replace(\n        MacroParameters.PatientName,\n        patient_data.first_name\n    );\n\n    content = content.replace(MacroParameters.CoordinatorName, userFirstName);\n\n    let signature = '<br/>' + userFirstName + ' ' + userLastName;\n    content = content.replace(MacroParameters.Signature, signature);\n    return content;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/macros/macros.ts",
      "bioverse-client/app/utils/database/controller/messaging/messages/messages.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/message/message-display.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/utils/post-prescribe-macro-selector/post-prescribe-macro-selector.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/decline-dialog.tsx",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/tab-column/message/message-display.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/marketing_opt_ins/marketing.tsx",
    "exports": [
      {
        "name": "insertMarketingOptIn",
        "kind": "function",
        "signature": "export async function insertMarketingOptIn(\n    email:string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: createData, error: createError } = await supabase\n        .from('marketing_opt_ins')\n        .insert({\n            email:email\n        })\n        .select()\n\n\n    if (createError) {\n        console.error(createError);\n        console.error('Error inserting a marketing opt in', createError);\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/marketing_opt_ins/marketing.tsx",
      "bioverse-client/app/components/footer/darkFooter.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/messaging/messages/messages.ts",
    "exports": [
      {
        "name": "postNewMessage",
        "kind": "function",
        "signature": "export async function postNewMessage(message_payload: MessagePayload) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: recipient, error: recipient_error } = await supabase\n        .from('threads')\n        .select('patient_id')\n        .eq('id', message_payload.thread_id)\n        .maybeSingle();\n\n    const { data, error } = await supabase\n        .from('messages')\n        .insert(message_payload)\n        .select();\n\n    if (error) {\n        console.log('dispatch message error');\n        console.log(error, error.message);\n        return false;\n    }\n\n    await logPatientAction(\n        message_payload.sender_id,\n        PatientActionTask.SENT_MESSAGE,\n        {\n            message: message_payload.content,\n        }\n    );\n\n    let sender_name_fetched: string | undefined = undefined;\n\n    if (!message_payload.contains_phi) {\n        const { data, error } = await supabase\n            .from('profiles')\n            .select('first_name')\n            .eq('id', message_payload.sender_id)\n            .limit(1)\n            .maybeSingle();\n\n        if (data) {\n            sender_name_fetched = data.first_name;\n        }\n    }\n\n    if (recipient?.patient_id !== message_payload.sender_id) {\n        if (message_payload.contains_phi === true) {\n            await triggerEvent(recipient?.patient_id, NEW_MESSAGE);\n        } else if (!message_payload.contains_phi) {\n            await triggerEvent(recipient?.patient_id, NEW_NONPHI_MESSAGE, {\n                sender_name: sender_name_fetched ?? 'Team Member',\n                message: extractTextFromHTML(message_payload.content),\n            });\n        }\n    }\n\n    // updateThreadMemberLastReadAt(\n    //     message_payload.sender_id,\n    //     message_payload.thread_id\n    // );\n\n    return data;\n}"
      },
      {
        "name": "getMessagesForThread",
        "kind": "function",
        "signature": "export async function getMessagesForThread(thread_id: string): Promise<any[]> {\n    const supabase = await createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('messages')\n        .select(\n            `\n            id, created_at, sender_id, content, thread_id, attachment_urls,\n            sender:profiles!sender_id(\n                first_name,\n                last_name,\n                provider_data:providers!id(role, profile_picture_url)\n            )\n            `\n        )\n        .eq('thread_id', thread_id)\n        .order('created_at', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching messages for thread. ', error);\n        return [];\n    }\n\n    return data;\n}"
      },
      {
        "name": "getFirstMessageForThread",
        "kind": "function",
        "signature": "export async function getFirstMessageForThread(\n    thread_id: string\n): Promise<any> {\n    const supabase = await createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('messages')\n        .select(\n            `\n            id, created_at, sender_id, content, thread_id,\n            sender:profiles!sender_id(\n                first_name,\n                last_name,\n                provider_data:providers!id(role, profile_picture_url)\n            )\n            `\n        )\n        .eq('thread_id', thread_id)\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching messages for thread. ', error);\n        return null;\n    }\n\n    return data[0];\n}"
      },
      {
        "name": "getAutomaticMacroContent",
        "kind": "function",
        "signature": "export async function getAutomaticMacroContent(\n    orderData: DBOrderData,\n    patientData: DBPatientData,\n    provider_id: string,\n    macroId: number\n) {\n    const subscription = await getPrescriptionSubscription(\n        Number(orderData.subscription_id)\n    );\n\n    const { status, data: macroData, error } = await getMacroById(macroId);\n\n    const macroHTML = macroData?.macroHtml;\n\n    if (status === Status.Failure || !macroHTML) {\n        console.log('Nathin, Issue persisted here - 1 ======================');\n        return Status.Failure;\n    }\n\n    if (!subscription) {\n        console.log('Nathin, Issue persisted here - 2 ======================');\n        return Status.Failure;\n    }\n\n    const stripeSubscription = await getStripeSubscription(\n        subscription.stripe_subscription_id\n    );\n\n    const endDate = stripeSubscription.current_period_end;\n\n    const endDateFormatted = convertEpochToDate(endDate);\n\n    const options: Intl.DateTimeFormatOptions = {\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric',\n    };\n    const formattedDate = endDateFormatted.toLocaleDateString('en-US', options);\n\n    const providerData = await getProviderFromId(provider_id);\n\n    if (\n        !providerData ||\n        !providerData.id ||\n        !providerData.name ||\n        !providerData.credentials\n    ) {\n        console.error('Invalid provider id', provider_id, orderData);\n        return Status.Failure;\n    }\n\n    const formattedContent = replaceParametersAutomaticSend(\n        patientData,\n        macroHTML,\n        providerData.name,\n        formattedDate,\n        providerData.credentials\n    );\n\n    await triggerEvent(\n        patientData.id,\n        subscription.subscription_type === SubscriptionCadency.Quarterly\n            ? CONFIRM_TREATMENT_QUARTERLY\n            : CONFIRM_TREATMENT,\n        {\n            click_url: `https://app.gobioverse.com/dosage-selection/${orderData.product_href}`,\n            renewal_date: formattedDate,\n        }\n    );\n\n    return formattedContent;\n    // const thread_id = await getThreadIDByPatientIDAndProduct(\n    //     patientData.id,\n    //     orderData.product_href,\n    // );\n\n    // if (!thread_id) {\n    //     console.error(\n    //         'Unable to get thread id for patient',\n    //         orderData,\n    //         patientData,\n    //     );\n    //     return Status.Failure;\n    // }\n\n    // const messagePayload: MessagePayload = {\n    //     sender_id: providerData.id,\n    //     content: formattedContent,\n    //     thread_id: Number(thread_id),\n    //     contains_phi: true,\n    //     requires_coordinator: false,\n    //     requires_lead: false,\n    //     requires_provider: false,\n    // };\n\n    // await postNewMessage(messagePayload);\n\n    return Status.Success;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(testing_and_development)/olivier-dev/utils.ts",
      "bioverse-client/app/utils/database/controller/messaging/messages/messages.ts",
      "bioverse-client/app/utils/actions/intake/order-util.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/tab-column/message/message-display.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/messages/components/messages-allpatients-content.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/message/message-display.tsx",
      "bioverse-client/app/components/patient-portal/message/thread-container/thread-container-new.tsx",
      "bioverse-client/app/components/patient-portal/message/thread-container/thread-container.tsx",
      "bioverse-client/app/api/renewal/autoship/route.ts",
      "bioverse-client/app/services/pharmacy-integration/util/utils.ts",
      "bioverse-client/app/utils/actions/message/message-v2-actions.ts",
      "bioverse-client/app/utils/database/controller/messaging/threads/threads.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/quarterly-final-review-dialog.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/messaging/thread_escalations/thread_escalations.ts",
    "exports": [
      {
        "name": "getAllThreadEscalations",
        "kind": "function",
        "signature": "export async function getAllThreadEscalations() {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.from('thread_escalations').select(\n        `\n            *,\n            threads!inner(id, patient_id, product,\n                patient:profiles!patient_id(first_name, last_name, email, state) )\n            `\n    );\n\n    if (error) {\n        console.log(error);\n    }\n\n    return data;\n}"
      },
      {
        "name": "getCoordinatorThreadList",
        "kind": "function",
        "signature": "export async function getCoordinatorThreadList() {\n    const supabase = createSupabaseServiceClient();\n\n    let coordinator_id;\n\n    const session = await readUserSession();\n    coordinator_id = session.data.session?.user.id;\n\n    let tableName;\n    // TODO: Deprecate this and recognize better\n    if (coordinator_id === 'c25c6769-2d12-4e58-9585-7fb73f552aeb') {\n        tableName = 'get_lead_coordinator_messages';\n    } else {\n        // tableName = 'get_coordinator_threads';\n        tableName = 'get_latest_coordinator_messages';\n    }\n    const { data, error } = await supabase.rpc(tableName);\n\n    if (error) {\n        console.log(\n            'error in chat threads for coordiantors: ',\n            error,\n            error.message\n        );\n    }\n\n    // Sort the data such that indices where data[n].last_patient_message_time > last_bioverse_message_time come first\n    const sortedData = data.sort(\n        (\n            a: {\n                last_patient_message_time: string | number | Date;\n                last_bioverse_message_time: string | number | Date;\n                requires_coordinator: boolean;\n            },\n            b: {\n                last_patient_message_time: string | number | Date;\n                last_bioverse_message_time: string | number | Date;\n                requires_coordinator: boolean;\n            }\n        ) => {\n            const aTime = new Date(a.last_patient_message_time).getTime();\n            const bTime = new Date(b.last_patient_message_time).getTime();\n            const aBioverseTime = new Date(\n                a.last_bioverse_message_time\n            ).getTime();\n            const bBioverseTime = new Date(\n                b.last_bioverse_message_time\n            ).getTime();\n\n            // First, prioritize requires_coordinator\n            if (a.requires_coordinator && !b.requires_coordinator) {\n                return -1;\n            } else if (!a.requires_coordinator && b.requires_coordinator) {\n                return 1;\n            }\n\n            // If both require coordinator, or both don't, then sort by message times\n            if (a.requires_coordinator && b.requires_coordinator) {\n                if (aTime > aBioverseTime && bTime <= bBioverseTime) {\n                    return -1;\n                } else if (aTime <= aBioverseTime && bTime > bBioverseTime) {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            }\n\n            // If neither require coordinator, sort by message times\n            if (aTime > aBioverseTime && bTime <= bBioverseTime) {\n                return -1;\n            } else if (aTime <= aBioverseTime && bTime > bBioverseTime) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n    );\n\n    return sortedData;\n}"
      },
      {
        "name": "getProviderThreadList",
        "kind": "function",
        "signature": "export async function getProviderThreadList() {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc('get_provider_message_list');\n\n    if (error) {\n        console.log(\n            'error in chat threads for coordiantors: ',\n            error,\n            error.message\n        );\n    }\n\n    // Sort the data such that indices where data[n].last_patient_message_time > last_bioverse_message_time come first\n    const sortedData = data.sort(\n        (\n            a: {\n                last_patient_message_time: string | number | Date;\n                last_bioverse_message_time: string | number | Date;\n                requires_coordinator: boolean;\n            },\n            b: {\n                last_patient_message_time: string | number | Date;\n                last_bioverse_message_time: string | number | Date;\n                requires_coordinator: boolean;\n            }\n        ) => {\n            const aTime = new Date(a.last_patient_message_time).getTime();\n            const bTime = new Date(b.last_patient_message_time).getTime();\n            const aBioverseTime = new Date(\n                a.last_bioverse_message_time\n            ).getTime();\n            const bBioverseTime = new Date(\n                b.last_bioverse_message_time\n            ).getTime();\n\n            // First, prioritize requires_coordinator\n            if (a.requires_coordinator && !b.requires_coordinator) {\n                return -1;\n            } else if (!a.requires_coordinator && b.requires_coordinator) {\n                return 1;\n            }\n\n            // If both require coordinator, or both don't, then sort by message times\n            if (a.requires_coordinator && b.requires_coordinator) {\n                if (aTime > aBioverseTime && bTime <= bBioverseTime) {\n                    return -1;\n                } else if (aTime <= aBioverseTime && bTime > bBioverseTime) {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            }\n\n            // If neither require coordinator, sort by message times\n            if (aTime > aBioverseTime && bTime <= bBioverseTime) {\n                return -1;\n            } else if (aTime <= aBioverseTime && bTime > bBioverseTime) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n    );\n\n    return sortedData;\n}"
      },
      {
        "name": "getProviderThreadCount",
        "kind": "function",
        "signature": "export async function getProviderThreadCount() {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc('getprovidermessagecount');\n\n    if (error) {\n        console.error(error);\n    }\n\n    console.log('count!!', data);\n    return data;\n}"
      },
      {
        "name": "getLeadCoordinatorThreadList",
        "kind": "function",
        "signature": "export async function getLeadCoordinatorThreadList() {\n    const supabase = createSupabaseServiceClient();\n    /*\n- patient_first_name\n- patient_last_name\n- patient_email\n- product\n- created_at\n*/\n\n    const { data, error } = await supabase\n        .from('thread_escalations')\n        .select(\n            `\n            *,\n            threads!inner(id, patient_id, product,\n                patient:profiles!patient_id(first_name, last_name, email) )\n            `\n        )\n        .eq('requires_lead', true);\n\n    if (error) {\n        console.log(error);\n    }\n\n    return data;\n}"
      },
      {
        "name": "updateConsiderCompleteForThreadId",
        "kind": "function",
        "signature": "export async function updateConsiderCompleteForThreadId(\n    thread_id: number,\n    consider_complete: boolean\n): Promise<boolean> {\n    const supabse = createSupabaseServiceClient();\n\n    const { error } = await supabse\n        .from('thread_escalations')\n        .update({\n            consider_complete: consider_complete,\n        })\n        .eq('thread_id', thread_id);\n\n    if (error) {\n        console.log('error in updating thread column: consider_complete ');\n        return false;\n    }\n\n    return true;\n}"
      },
      {
        "name": "updateRequiresProviderForThreadId",
        "kind": "function",
        "signature": "export async function updateRequiresProviderForThreadId(\n    thread_id: number,\n    requires_provider: boolean\n): Promise<boolean> {\n    const supabse = createSupabaseServiceClient();\n\n    const { error } = await supabse\n        .from('thread_escalations')\n        .update({\n            requires_provider: requires_provider,\n        })\n        .eq('thread_id', thread_id);\n\n    if (error) {\n        console.log('error in updating thread column: consider_complete ');\n        return false;\n    }\n\n    return true;\n}"
      },
      {
        "name": "updateReadProviderTimeForThreadId",
        "kind": "function",
        "signature": "export async function updateReadProviderTimeForThreadId(\n    thread_id: number\n): Promise<boolean> {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('thread_escalations')\n        .update({\n            last_provider_read_time: new Date().toISOString(), // Use current time in ISO format\n        })\n        .eq('thread_id', thread_id);\n\n    if (error) {\n        console.log(\n            'Error in updating thread column: last_provider_read_time',\n            error.message\n        );\n        return false;\n    }\n\n    return true;\n}"
      },
      {
        "name": "updateRequiresLeadForThreadId",
        "kind": "function",
        "signature": "export async function updateRequiresLeadForThreadId(\n    thread_id: number,\n    requires_lead: boolean\n): Promise<boolean> {\n    const supabse = createSupabaseServiceClient();\n\n    const { error } = await supabse\n        .from('thread_escalations')\n        .update({\n            requires_lead: requires_lead,\n        })\n        .eq('thread_id', thread_id);\n\n    if (error) {\n        console.log('error in updating thread column: consider_complete ');\n        return false;\n    }\n\n    return true;\n}"
      },
      {
        "name": "removeCurrentProviderfromProvidersListForThreadId",
        "kind": "function",
        "signature": "export async function removeCurrentProviderfromProvidersListForThreadId(\n    thread_id: number,\n    user_id: string\n): Promise<boolean> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error: fetchError } = await supabase\n        .from('thread_escalations')\n        .select('providers')\n        .eq('thread_id', thread_id)\n        .single(); // Ensure we get a single row\n\n    if (fetchError) {\n        console.log(\n            'Error in fetching current providers list:',\n            fetchError.message\n        );\n        return false;\n    }\n\n    const updatedProviders = data.providers.filter(\n        (provider: string) => provider !== user_id\n    );\n\n    const { error: updateError } = await supabase\n        .from('thread_escalations')\n        .update({ providers: updatedProviders })\n        .eq('thread_id', thread_id);\n\n    if (updateError) {\n        console.log('error in updating thread column: providers ');\n        return false;\n    }\n\n    return true;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/messaging/thread_escalations/thread_escalations.ts",
      "bioverse-client/app/components/coordinator-portal/message-dashboard/message-dashboard-search-filter.tsx",
      "bioverse-client/app/components/provider-portal/messages/components/provider-message-dashboard/provider-message-dashboard-search-filter.tsx",
      "bioverse-client/app/components/coordinator-portal/message-dashboard/message-dashboard.tsx",
      "bioverse-client/app/components/provider-portal/messages/components/provider-message-dashboard/provider-message-dashboard.tsx",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/containers/coordinator-main-view-container.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/messaging/thread_members/thread_members.ts",
    "exports": [
      {
        "name": "addMemberToThread",
        "kind": "function",
        "signature": "export async function addMemberToThread(\n    user_id_to_add: string,\n    thread_id: string\n): Promise<boolean> {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('thread_members')\n        .insert({\n            thread_id: thread_id,\n            user_id: user_id_to_add,\n            last_read_at: new Date(),\n        });\n\n    if (error) {\n        console.error(error, error.message);\n    }\n\n    return false;\n}"
      },
      {
        "name": "updateThreadMemberLastReadAt",
        "kind": "function",
        "signature": "export async function updateThreadMemberLastReadAt(\n    user_id: string,\n    thread_id: number\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('thread_members')\n        .update({ last_read_at: new Date() })\n        .eq('user_id', user_id)\n        .eq('thread_id', thread_id);\n\n    if (error) {\n        console.error(error, error.message);\n    }\n}"
      },
      {
        "name": "updateThreadMemberLastReadAtWithPatientAndProduct",
        "kind": "function",
        "signature": "export async function updateThreadMemberLastReadAtWithPatientAndProduct(\n    user_id: string,\n    thread_id: number\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('thread_members')\n        .update({ last_read_at: new Date() })\n        .eq('user_id', user_id)\n        .eq('thread_id', thread_id);\n\n    if (error) {\n        console.error(error, error.message);\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/messaging/thread_members/thread_members.ts",
      "bioverse-client/app/utils/database/controller/messaging/messages/messages.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/messaging/threads/threads.ts",
    "exports": [
      {
        "name": "createNewThreadForPatientProduct",
        "kind": "function",
        "signature": "export async function createNewThreadForPatientProduct(\n    patient_id: string,\n    product_href: string\n): Promise<string> {\n    const supabase = createSupabaseServiceClient();\n\n    if (!patient_id || !product_href) {\n        return '';\n    }\n\n    const { data, error } = await supabase\n        .from('threads')\n        .insert({ patient_id: patient_id, product: product_href })\n        .select();\n\n    if (error || data.length === 0) {\n        console.log('create new thread error');\n        console.error(error, error?.message);\n        return '';\n    }\n\n    return data[0].id;\n}"
      },
      {
        "name": "createNewThreadForPatientProductWithCheck",
        "kind": "function",
        "signature": "export async function createNewThreadForPatientProductWithCheck(\n    patient_id: string,\n    product_href: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    console.log('creating thread for patient!');\n\n    const { data: pre_check, error: pre_check_error } = await supabase\n        .from('threads')\n        .select('*')\n        .eq('patient_id', patient_id)\n        .eq('product', product_href);\n\n    if (pre_check_error) {\n        console.log('create new thread error');\n        console.log(pre_check_error, pre_check_error?.message);\n        return false;\n    }\n\n    if (pre_check.length > 0) {\n        console.log(\n            'create new thread error - a thread already exists for this.'\n        );\n        return false;\n    }\n\n    const { data, error } = await supabase\n        .from('threads')\n        .insert({\n            patient_id: patient_id,\n            product: product_href,\n        })\n        .select();\n\n    if (error || data.length === 0) {\n        console.log('create new thread error');\n        console.log(error, error?.message);\n        return false;\n    }\n\n    return data[0].id;\n}"
      },
      {
        "name": "listAllThreadsForPatient",
        "kind": "function",
        "signature": "export async function listAllThreadsForPatient(\n    patient_id: string\n): Promise<{ id: any; product: any }[]> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('threads')\n        .select('id, product')\n        .eq('patient_id', patient_id);\n\n    if (error || !data) {\n        console.log('Error in fetching thread');\n        console.error(error, error?.message);\n        return [];\n    }\n\n    return data;\n}"
      },
      {
        "name": "getPatientThreadData",
        "kind": "function",
        "signature": "export async function getPatientThreadData(): Promise<any[]> {\n    const supabase = createSupabaseServerComponentClient();\n\n    const user_id = (await readUserSession()).data.session?.user.id;\n\n    if (!user_id) {\n        console.log('getPatientThreadData - found no userId');\n        return [];\n    }\n\n    const { data, error } = await supabase\n        .from('threads')\n        .select('id, product, product_data:products!product(name)')\n        .eq('patient_id', user_id);\n\n    if (error || !data) {\n        console.log('Error in fetching thread');\n        console.error(error, error?.message);\n        return [];\n    }\n\n    let thread_and_message_preview_data = [];\n\n    for (const item of data) {\n        const first_message_data = await getFirstMessageForThread(item.id);\n\n        thread_and_message_preview_data.push({\n            ...item,\n            message_preview: first_message_data,\n        });\n    }\n\n    return thread_and_message_preview_data;\n}"
      },
      {
        "name": "getThreadIDByPatientIDAndProduct",
        "kind": "function",
        "signature": "export async function getThreadIDByPatientIDAndProduct(\n    patient_id: string,\n    product_href: string\n): Promise<string> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('threads')\n        .select('id')\n        .eq('patient_id', patient_id)\n        .eq('product', product_href)\n        .maybeSingle();\n\n    if (error || !data) {\n        console.log('Error in fetching thread');\n        console.error(error, error?.message);\n        return '';\n    }\n\n    return data.id;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/orders/create-manual-order.ts",
      "bioverse-client/app/utils/database/controller/messaging/threads/threads.ts",
      "bioverse-client/app/components/intake-v3/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component-ab.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/ed/ed-checkout/ed-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/components/wl-checkout-component-fulltest.tsx",
      "bioverse-client/app/components/intake-v2/checkout/checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/utils/actions/message/message-v2-actions.ts",
      "bioverse-client/_deprecated/chat_old_6.10/chatUI.tsx",
      "bioverse-client/app/components/patient-portal/message/message-main-container.tsx",
      "bioverse-client/app/(testing_and_development)/olivier-dev/utils.ts",
      "bioverse-client/app/utils/database/controller/messaging/messages/messages.ts",
      "bioverse-client/app/utils/actions/intake/order-util.ts",
      "bioverse-client/app/api/renewal/autoship/route.ts",
      "bioverse-client/app/services/pharmacy-integration/util/utils.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/mixpanel/mixpanel.ts",
    "exports": [
      {
        "name": "checkMixpanelSignUpViewedFired",
        "kind": "function",
        "signature": "export async function checkMixpanelSignUpViewedFired(\n    anonId: string\n): Promise<{ data: MixPanelAudit | null; error: any }> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: startedData, error: startedError } = await supabase\n        .from('mixpanel-audit')\n        .select('*')\n        .eq('anon_id', anonId)\n        .eq('event_name', SIGNUP_VIEWED)\n        .maybeSingle();\n\n    if (startedError) {\n        console.error(\n            'Controller Error. tablename: mixpanel_audits, method: checkMixpanelSignUpViewedFired, error: ',\n            startedError\n        );\n        return { data: null, error: startedError };\n    }\n\n    return { data: startedData, error: null };\n}"
      },
      {
        "name": "checkMixpanelAliasFired",
        "kind": "function",
        "signature": "export async function checkMixpanelAliasFired(\n    user_id: string,\n    product_href: string\n): Promise<{ data: MixPanelAudit | null; error: any }> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: startedData, error: startedError } = await supabase\n        .from('mixpanel-audit')\n        .select('*')\n        .eq('user_id', user_id)\n        .eq('event_name', ALIAS_CREATED)\n        .eq('product_href', product_href)\n        .maybeSingle();\n\n    if (startedError) {\n        console.error(\n            'Controller Error. tablename: mixpanel_audits, method: checkMixpanelAliasFired, error: ',\n            startedError\n        );\n        return { data: null, error: startedError };\n    }\n\n    return { data: startedData, error: null };\n}"
      },
      {
        "name": "checkMixpanelEventFired",
        "kind": "function",
        "signature": "export async function checkMixpanelEventFired(\n    user_id: string,\n    event_name: string,\n    product_href: string\n): Promise<{ data: MixPanelAudit | null; error: any }> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: startedData, error: startedError } = await supabase\n        .from('mixpanel-audit')\n        .select('*')\n        .eq('user_id', user_id)\n        .eq('event_name', LEAD_STARTED)\n        .maybeSingle();\n\n    //If a lead start event does not already exist, then that means that the user did not come from the advertising and should be handled regularly\n    if (event_name != LEAD_STARTED && !startedData) {\n        return { data: { continue: 'false' }, error: null };\n    }\n\n    if (startedError) {\n        console.error(\n            'Controller Error. tablename: mixpanel_audits, method: checkMixpanelEventFired, error: ',\n            startedError\n        );\n        return { data: null, error: startedError };\n    }\n\n    const { data, error } = await supabase\n        .from('mixpanel-audit')\n        .select('*')\n        .eq('user_id', user_id)\n        .eq('event_name', event_name)\n        .eq('product_href', product_href)\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            'Controller Error. tablename: mixpanel_audits, method: checkMixpanelEventFired, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: data, error: null };\n}"
      },
      {
        "name": "createMixpanelEventAudit",
        "kind": "function",
        "signature": "export async function createMixpanelEventAudit(\n    user_id: string,\n    event_name: string,\n    product_href: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.from('mixpanel-audit').insert([\n        {\n            user_id,\n            event_name,\n            product_href,\n        },\n    ]);\n\n    if (error) {\n        console.error(\n            'Controller Error. tablename: mixpanel-audit, method: createMixpanelEventAudit, error: ',\n            error\n        );\n        return Status.Error;\n    }\n\n    return Status.Success;\n}"
      },
      {
        "name": "createMixpanelSignUpAudit",
        "kind": "function",
        "signature": "export async function createMixpanelSignUpAudit(\n    anon_id: string,\n    event_name: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.from('mixpanel-audit').insert([\n        {\n            anon_id,\n            event_name,\n        },\n    ]);\n\n    if (error) {\n        console.error(\n            'Controller Error. tablename: mixpanel-audit, method: createMixpanelSignUpAudit, error: ',\n            error\n        );\n        return Status.Error;\n    }\n\n    return Status.Success;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/mixpanel/mixpanel.ts",
      "bioverse-client/app/components/intake-v3/registration/intake-signup-form/intake-signup-form-v3.tsx",
      "bioverse-client/app/components/intake-v2/registration/intake-signup-form/intake-signup-form.tsx",
      "bioverse-client/app/auth/callback/route.ts",
      "bioverse-client/app/components/intake-v3/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component-ab.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v3/wl-graph/wl-login-verification-screen.tsx",
      "bioverse-client/app/components/intake-v3/wl-graph/wl-registration-pre-graph-dialog.tsx",
      "bioverse-client/app/components/intake-v3/pages/question-id-pre-signup.tsx",
      "bioverse-client/app/components/intake-v3/pages/shipping-information-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/id-verification-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/pre-question-id-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/id-verification-noskip-v3.tsx",
      "bioverse-client/app/components/intake-v2/ed/ed-checkout/ed-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/components/wl-checkout-component-fulltest.tsx",
      "bioverse-client/app/components/intake-v2/checkout/checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/pages/id-verification.tsx",
      "bioverse-client/app/components/intake-v2/pages/shipping-information.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/order_data_audit/order_audit_descriptions.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/controller/order_data_audit/order_data_audit_api.ts",
    "exports": [
      {
        "name": "createOrderDataAudit",
        "kind": "function",
        "signature": "export async function createOrderDataAudit(\n    order_id: number,\n    renewal_order_id: string | undefined,\n    description: string | undefined,\n    action: OrderDataAuditActions,\n    metadata: any,\n    payload: any\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const orderDataAuditToInsert: Partial<OrderDataAuditType> = {\n        order_id: order_id,\n        renewal_order_id: renewal_order_id,\n        description: description,\n        action: action,\n        metadata: metadata,\n        payload_data: payload,\n    };\n\n    const { error } = await supabase\n        .from('order_data_audit')\n        .insert(orderDataAuditToInsert);\n\n    if (error) {\n        console.error('Error in creating Order Data Audit: ', error);\n    }\n    return;\n}"
      },
      {
        "name": "getLatestDosageSelectionForRenewalOrder",
        "kind": "function",
        "signature": "export async function getLatestDosageSelectionForRenewalOrder(\n    renewal_order_id: string\n): Promise<OrderDataAuditType | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('order_data_audit')\n        .select('*')\n        .in('action', [\n            OrderDataAuditActions.CoordinatorDosageSelection,\n            OrderDataAuditActions.DosageSelection,\n            OrderDataAuditActions.CoordinatorManualCreateOrder,\n        ])\n        .eq('renewal_order_id', renewal_order_id)\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        throw new Error(\n            'Error getting latest dosage selection for renewal order'\n        );\n    }\n\n    if (isEmpty(data)) {\n        return null;\n    }\n\n    return data as OrderDataAuditType;\n}"
      },
      {
        "name": "hasOrderPharmacyScriptBeenSent",
        "kind": "function",
        "signature": "export async function hasOrderPharmacyScriptBeenSent(\n    order_id: number,\n    renewal_order_id?: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    let audit_data;\n\n    if (renewal_order_id) {\n        const { data, error } = await supabase\n            .from('order_data_audit')\n            .select('*')\n            .eq('action', OrderDataAuditActions.PrescriptionSent)\n            .eq('renewal_order_id', renewal_order_id);\n\n        if (error) {\n            console.log(error);\n            //returning true as a safeguard.\n            return true;\n        }\n\n        audit_data = data;\n    } else {\n        const { data, error } = await supabase\n            .from('order_data_audit')\n            .select('*')\n            .eq('action', OrderDataAuditActions.PrescriptionSent)\n            .eq('order_id', order_id);\n\n        if (error) {\n            console.log(error);\n            //returning true as a safeguard.\n            return true;\n        }\n\n        audit_data = data;\n    }\n\n    if (!audit_data || audit_data.length === 0) {\n        return false;\n    }\n    return true;\n}"
      },
      {
        "name": "getRenewalDosageSelectionAudit",
        "kind": "function",
        "signature": "export async function getRenewalDosageSelectionAudit(\n    renewal_order_id: string\n): Promise<{\n    selectedDosageString: string;\n    selectedVariantIndex: string;\n    pharmacy: string;\n    created_at: string;\n} | null> {\n    const supabase = createSupabaseServiceClient();\n    if (renewal_order_id) {\n        const { data, error } = await supabase\n            .from('order_data_audit')\n            .select('*')\n            .in('action', [OrderDataAuditActions.DosageSelection])\n            .eq('renewal_order_id', renewal_order_id)\n            .order('created_at', { ascending: true });\n\n        if (error) {\n            console.log(error);\n            return null;\n        }\n\n        if (data && data.length > 0) {\n            const latestRecord = data[data.length - 1];\n            return {\n                selectedDosageString:\n                    latestRecord?.metadata?.dosageUpdateString ?? '',\n                selectedVariantIndex:\n                    latestRecord?.metadata?.selectedVariantIndex.toString() ??\n                    '',\n                pharmacy: latestRecord?.metadata?.new_pharmacy ?? '',\n                created_at: latestRecord?.created_at ?? '',\n            };\n        }\n    }\n\n    return null;\n}"
      },
      {
        "name": "getPrescriptionSentAudit",
        "kind": "function",
        "signature": "export async function getPrescriptionSentAudit(\n    order_id: number,\n    renewal_order_id?: string\n): Promise<OrderDataAuditType[] | null> {\n    const supabase = createSupabaseServiceClient();\n\n    let audit_data;\n\n    if (renewal_order_id) {\n        const { data, error } = await supabase\n            .from('order_data_audit')\n            .select('*')\n            .in('action', [\n                OrderDataAuditActions.PrescriptionSent,\n                OrderDataAuditActions.ResendPrescription,\n                OrderDataAuditActions.SecondSplitShipmentScriptSent,\n                OrderDataAuditActions.SecondAnnualShipmentSent,\n            ])\n            .eq('renewal_order_id', renewal_order_id)\n            .order('created_at', { ascending: true });\n\n        if (error) {\n            console.log(error);\n            //returning true as a safeguard.\n            return null;\n        }\n\n        audit_data = data;\n    } else {\n        const { data, error } = await supabase\n            .from('order_data_audit')\n            .select('*')\n            .in('action', [\n                OrderDataAuditActions.PrescriptionSent,\n                OrderDataAuditActions.ResendPrescription,\n                OrderDataAuditActions.SecondSplitShipmentScriptSent,\n                OrderDataAuditActions.SecondAnnualShipmentSent,\n            ])\n            .eq('order_id', order_id)\n            .is('renewal_order_id', null);\n\n        if (error) {\n            console.log(error);\n            //returning true as a safeguard.\n            return null;\n        }\n\n        audit_data = data;\n    }\n\n    if (!audit_data || audit_data.length === 0) {\n        return null;\n    }\n    return audit_data as OrderDataAuditType[];\n}"
      },
      {
        "name": "getResendCount",
        "kind": "function",
        "signature": "export async function getResendCount(\n    order_id: number,\n    renewal_order_id?: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    let resend_count = 0;\n\n    let records;\n\n    if (renewal_order_id) {\n        const { data } = await supabase\n            .from('order_data_audit')\n            .select('id')\n            .eq('action', OrderDataAuditActions.ResendPrescription)\n            .eq('renewal_order_id', renewal_order_id);\n\n        records = data;\n    } else {\n        const { data } = await supabase\n            .from('order_data_audit')\n            .select('id')\n            .eq('action', OrderDataAuditActions.ResendPrescription)\n            .eq('order_id', order_id);\n\n        records = data;\n    }\n\n    resend_count = records?.length ?? 0;\n    return resend_count;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/orders/process-manual-order.ts",
      "bioverse-client/app/utils/database/controller/order_data_audit/order_data_audit_api.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/RenewalValidationJobHandler.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/StripeInvoicePaidJobHandler.ts",
      "bioverse-client/app/api/revive/send-script/route.ts",
      "bioverse-client/app/api/empower/send-script/route.ts",
      "bioverse-client/app/api/hallandale/send-script/route.ts",
      "bioverse-client/app/api/boothwyn/send-script/route.ts",
      "bioverse-client/app/services/pharmacy-integration/util/utils.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/order-tab-row.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/RenewalOrderTabRow.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/orders-content.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/orders-components/order-accordion.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/orders-components/renewal-order-accordion.tsx",
      "bioverse-client/app/utils/functions/prescription-scripts/hallandale-approval-script-generator.ts",
      "bioverse-client/app/utils/functions/prescription-scripts/empower-approval-script-generator.ts",
      "bioverse-client/app/utils/functions/prescription-scripts/boothwyn-script-generator.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/order_data_audit/order_data_audit_type.d.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/controller/orders/address-in-most-recent-order.ts",
    "exports": [
      {
        "name": "getAddressOfMostRecentOrder",
        "kind": "function",
        "signature": "export async function getAddressOfMostRecentOrder(userId: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: addressData, error: addressDataFetchError } = await supabase\n    .from('orders')\n    .select(\n        `\n        address_line1,\n        address_line2,\n        city,\n        state,\n        zip\n        `\n    )\n    .eq('customer_uid', userId)\n    .not('address_line1', 'is', null) \n    .not('city', 'is', null)\n    .not('state', 'is', null)\n    .not('zip', 'is', null)\n    .order('created_at', { ascending: false }) \n    .limit(1);\n\n\n    if (addressDataFetchError) {\n        console.log('Address in most recent order TS: ', addressDataFetchError.message);\n        return { data: null, error: addressDataFetchError };\n    }\n\n    return { data: addressData, error: null };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/orders/address-in-most-recent-order.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/ManualOrderCreationDialog.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/orders/create-manual-order.ts",
    "exports": [
      {
        "name": "getPreloadManualCreateOrderInformation",
        "kind": "function",
        "signature": "export async function getPreloadManualCreateOrderInformation(\n    orderInformation: ManualOrderInformation\n) {\n    const { profile_data, product_href, variant_index, needsProviderReview } =\n        orderInformation;\n\n    const new_price_id = await getPriceIdForProductVariant(\n        product_href,\n        variant_index,\n        process.env.NEXT_PUBLIC_ENVIRONMENT!\n    );\n\n    if (!isGLP1Product(product_href)) {\n        return {\n            paymentAction: ManualOrderAction.NewBaseOrder,\n            //We don't use amount for new first time orders that are no GLP-1, so we can pass 0.\n            amount: 0,\n        };\n    }\n\n    if (!new_price_id) {\n        throw new Error(\n            `Could not find new price id for ${product_href} ${variant_index}`\n        );\n    }\n\n    let subscription = await getSubscriptionByProduct(\n        product_href,\n        profile_data.id\n    );\n\n    if (!subscription) {\n        const baseOrder = await getBaseOrderByProduct(\n            profile_data.id,\n            orderInformation.product_href\n        );\n\n        if (!baseOrder) {\n            return {\n                paymentAction: ManualOrderAction.NewBaseOrder,\n                amount: await getPriceForStripePriceId(new_price_id),\n            };\n        }\n\n        if (baseOrder.order_status !== OrderStatus.ApprovedCardDownFinalized) {\n            return {\n                paymentAction: ManualOrderAction.NewBaseOrderVoidOrder,\n                amount: await getPriceForStripePriceId(new_price_id),\n            };\n        }\n        throw new Error('Could not find subscription for user');\n    }\n\n    if (\n        subscription.status === SubscriptionStatus.Canceled ||\n        subscription.status === SubscriptionStatus.Scheduled_Cancel\n    ) {\n        return {\n            paymentAction: ManualOrderAction.ReactivateSubscription,\n            amount: await getPriceForStripePriceId(new_price_id),\n        };\n    }\n    if (subscription.status !== 'active') {\n        throw new Error('Could not find active subscription for user');\n    }\n\n    await triggerEvent(profile_data.id, WEIGHT_LOSS_SWAP_PRODUCT);\n    await triggerEvent(profile_data.id, WL_CHECKIN_COMPLETE);\n\n    if (needsProviderReview) {\n        return await handleOrderNeedsProviderReview(\n            orderInformation,\n            subscription,\n            new_price_id\n        );\n    } else {\n        return await handleOrderDoesntNeedProviderReview(\n            orderInformation,\n            subscription,\n            new_price_id\n        );\n    }\n}"
      },
      {
        "name": "isUserEligibleForManualOrderCreation",
        "kind": "function",
        "signature": "export async function isUserEligibleForManualOrderCreation(\n    patient_id: string,\n    product_href: PRODUCT_HREF\n): Promise<boolean> {\n    const getProductsToCheck = (href: PRODUCT_HREF): PRODUCT_HREF[] => {\n        switch (href) {\n            case PRODUCT_HREF.SEMAGLUTIDE:\n            case PRODUCT_HREF.TIRZEPATIDE:\n                return [PRODUCT_HREF.SEMAGLUTIDE, PRODUCT_HREF.TIRZEPATIDE];\n            default:\n                return [href];\n        }\n    };\n\n    const products_to_check = getProductsToCheck(product_href);\n\n    const supabase = createSupabaseServiceClient();\n\n    const { data: subscriptions, error } = await supabase\n        .from('prescription_subscriptions')\n        .select('id, status')\n        .eq('patient_id', patient_id)\n        .in('product_href', products_to_check);\n\n    if (error) {\n        console.error('Error fetching subscriptions', error);\n        return false;\n    }\n\n    // Return true if there are no subscriptions or if all subscriptions are canceled\n    return (\n        subscriptions.length === 0 ||\n        subscriptions.every(\n            (subscription) =>\n                subscription.status === SubscriptionStatus.Canceled\n        )\n    );\n}"
      },
      {
        "name": "handleUserThreadsOnManualCreateOrder",
        "kind": "function",
        "signature": "export async function handleUserThreadsOnManualCreateOrder(\n    patient_id: string,\n    new_product_href: PRODUCT_HREF\n) {\n    try {\n        const target_thread_product = (() => {\n            switch (new_product_href) {\n                case PRODUCT_HREF.TIRZEPATIDE:\n                    return PRODUCT_HREF.SEMAGLUTIDE;\n                case PRODUCT_HREF.SEMAGLUTIDE:\n                    return PRODUCT_HREF.TIRZEPATIDE;\n                default:\n                    return new_product_href;\n            }\n        })();\n\n        const supabase = createSupabaseServiceClient();\n\n        const { data: threads, error } = await supabase\n            .from('threads')\n            .select('*')\n            .eq('patient_id', patient_id);\n\n        if (error) {\n            console.error('Error fetching threads', error);\n            return Status.Error;\n        }\n\n        if (threads.length === 0) {\n            await createNewThreadForPatientProduct(\n                patient_id,\n                new_product_href\n            );\n            return Status.Failure;\n        }\n\n        const target_thread = threads.find(\n            (thread) => thread.product === target_thread_product\n        );\n\n        if (!target_thread) {\n            await createNewThreadForPatientProduct(\n                patient_id,\n                new_product_href\n            );\n            return Status.Failure;\n        }\n\n        if (target_thread.product === new_product_href) {\n            return Status.Success;\n        }\n\n        await supabase\n            .from('threads')\n            .update({\n                product: new_product_href,\n            })\n            .eq('id', target_thread.id);\n\n        if (error) {\n            console.error('Error swapping user thread on GLP-1 product', error);\n            return Status.Error;\n        }\n    } catch (error) {\n        console.error('Error swapping user thread on GLP-1 product', error);\n        return Status.Error;\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/orders/create-manual-order.ts",
      "bioverse-client/app/api/supabase/orders/getManualOrderInfo/route.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/ManualOrderCreationDialog.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/orders/create-order-utils.ts",
    "exports": [
      {
        "name": "getNextRenewalOrderId",
        "kind": "function",
        "signature": "export function getNextRenewalOrderId(\n    original_order_id: string,\n    old_renewal_order_id: string\n) {\n    const nextCount =\n        getRenewalOrderCountFromRenewalOrderId(old_renewal_order_id);\n\n    return `${original_order_id}-${Number(nextCount) + 1 || '100'}`;\n}"
      },
      {
        "name": "getRenewalOrderCountFromRenewalOrderId",
        "kind": "function",
        "signature": "export function getRenewalOrderCountFromRenewalOrderId(\n    renewal_order_id: string\n) {\n    const parts = renewal_order_id.split('-');\n    return parts.length > 1 ? parts[1] : null;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/orders/create-order.ts",
      "bioverse-client/app/utils/database/controller/orders/create-order-utils.ts",
      "bioverse-client/app/utils/database/controller/orders/process-manual-order.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/orders/create-order.ts",
    "exports": [
      {
        "name": "createNewManualOrder",
        "kind": "function",
        "signature": "export async function createNewManualOrder(\n    profile_data: DBPatientData,\n    product_href: PRODUCT_HREF,\n    variant_index: number,\n    hasPaid: boolean,\n    cadence: SubscriptionCadency,\n    selectedPaymentMethod: string\n) {\n    const baseOrder = await getBaseOrderByProduct(\n        profile_data.id,\n        product_href\n    );\n\n    const pvc = new ProductVariantController(\n        product_href as PRODUCT_HREF,\n        variant_index,\n        profile_data.state as USStates\n    );\n\n    const pvc_conversion = pvc.getConvertedVariantIndex();\n    const newPharmacy = pvc_conversion.pharmacy;\n    const newVariantIndex = pvc_conversion.variant_index!;\n\n    const new_price_id = await getPriceIdForProductVariant( \n        product_href,\n        newVariantIndex,\n        process.env.NEXT_PUBLIC_ENVIRONMENT!\n    );\n\n    if (!new_price_id) {\n        throw new Error(\n            `Could not find price id for this product ${product_href} ${newVariantIndex}`\n        );\n    }\n\n    if (!newPharmacy) {\n        throw new Error(\n            `Could not find pharmacy for this product and var index ${product_href} ${newVariantIndex}`\n        );\n    }\n\n    // Do subscription stuff here\n\n    if (!baseOrder) {\n        // Swapping from A -> B, just create a new order\n        await createNewBaseOrder(\n            profile_data,\n            product_href,\n            newVariantIndex,\n            cadence,\n            selectedPaymentMethod,\n            new_price_id,\n            newPharmacy\n        );\n        // Void current glp 1 subscription\n    } else {\n        // A base order exists for this product. Check if a renewal order exists for it, if yes then create a new renewal\n        // If no, then reasonable to assume the base order is 'incomplete' and can be overwritten\n\n        const latestRenewalOrder =\n            await getLatestRenewalOrderByCustomerAndProduct(\n                profile_data.id,\n                product_href\n            );\n\n        if (\n            !latestRenewalOrder &&\n            baseOrder.order_status !== OrderStatus.ApprovedCardDownFinalized\n        ) {\n            // No renewal order exists, can overwrite the existing order\n            await overwriteExistingBaseOrder(\n                baseOrder,\n                newVariantIndex,\n                cadence,\n                selectedPaymentMethod,\n                new_price_id,\n                newPharmacy\n            );\n\n            // Need to void / cancel other GLP-1 order if exists\n        } else if (latestRenewalOrder) {\n            // Renewal order exists, void the latest one and create a new renewal\n            // await createNewNthRenewalOrder(\n            //     latestRenewalOrder,\n            //     variant_index,\n            //     cadence,\n            //     new_price_id,\n            //     newPharmacy,\n            // );\n        } else {\n            // Base Order is finalized, create a first time renewal order\n            // await createNewFirstTimeRenewalOrder(\n            //     baseOrder,\n            //     variant_index,\n            //     cadence,\n            //     new_price_id,\n            //     newPharmacy,\n            // );\n        }\n    }\n}"
      },
      {
        "name": "getManualCreateOrderInformation",
        "kind": "function",
        "signature": "export async function getManualCreateOrderInformation(\n    profile_data: APProfileData,\n    product_href: PRODUCT_HREF,\n    variant_index: number,\n    hasPaid: boolean,\n    cadence: SubscriptionCadency,\n    selectedPaymentMethod: string\n) {\n    const baseOrder = await getBaseOrderByProduct(\n        profile_data.id,\n        product_href\n    );\n\n    const pvc = new ProductVariantController(\n        product_href as PRODUCT_HREF,\n        variant_index,\n        profile_data.state as USStates\n    );\n\n    const pvc_conversion = pvc.getConvertedVariantIndex();\n    const newPharmacy = pvc_conversion.pharmacy;\n    const newVariantIndex = pvc_conversion.variant_index!;\n\n    const new_price_id = await getPriceIdForProductVariant(\n        product_href,\n        newVariantIndex,\n        process.env.NEXT_PUBLIC_ENVIRONMENT!\n    );\n\n    if (!new_price_id) {\n        throw new Error('Could not find new price id');\n    }\n\n    if (!newPharmacy) {\n        throw new Error(\n            `Could not find pharmacy for price id ${product_href} ${newVariantIndex}`\n        );\n    }\n\n    // Do subscription stuff here\n\n    // If user hasn't paid yet, can just always use updateStripeProduct\n    // If customer has paid, show much extra they will be charged or refunded\n\n    const newStripePrice = await getPriceForStripePriceId(new_price_id);\n    if (!newStripePrice) {\n        throw new Error('Unable to get new stripe price');\n    }\n\n    if (!baseOrder) {\n        // Swapping from A -> B, just create a new order\n\n        if (hasPaid) {\n            const oldStripePrice = await getLastPaidAmountForGLP1(\n                profile_data.id\n            );\n            if (oldStripePrice && newStripePrice) {\n                const payload = getOrderInformationPayload(\n                    profile_data,\n                    oldStripePrice,\n                    newStripePrice\n                );\n                // If the new product is more expensive than last paid, credit the user the amount of last paid\n                return {\n                    action: ManualOrderAction.NewBaseOrder,\n                    ...payload,\n                };\n            } else {\n                throw new Error(\n                    'Could not get old price and new price for user'\n                );\n            }\n        }\n        // If subscriptions exist for the user, find them\n        // If need to pay more, refund a selected invoice entirely\n        // If need to get a refund, do it via prorations\n\n        // If no subscriptions exist, do nothing\n        else {\n            return {\n                action: ManualOrderAction.NewBaseOrder,\n                price: convertStripePriceToDollars(newStripePrice),\n            };\n        }\n        // Void current glp 1 subscription\n    } else {\n        // A base order exists for this product. Check if a renewal order exists for it, if yes then create a new renewal\n        // If no, then reasonable to assume the base order is 'incomplete' and can be overwritten\n\n        const latestRenewalOrder =\n            await getLatestRenewalOrderByCustomerAndProduct(\n                profile_data.id,\n                product_href\n            );\n\n        if (\n            !latestRenewalOrder &&\n            baseOrder.order_status !== OrderStatus.ApprovedCardDownFinalized\n        ) {\n            await deleteOrderById(baseOrder.id);\n            return await getManualCreateOrderInformation(\n                profile_data,\n                product_href,\n                newVariantIndex,\n                hasPaid,\n                cadence,\n                selectedPaymentMethod\n            );\n\n            // Need to void / cancel other GLP-1 order if exists\n        } else if (latestRenewalOrder) {\n            // Renewal order exists, void the latest one and create a new renewal\n            if (hasPaid) {\n                const oldStripePrice = await getLastPaidAmountForGLP1(\n                    profile_data.id\n                );\n\n                if (oldStripePrice && newStripePrice) {\n                    const payload = await getOrderInformationPayload(\n                        profile_data,\n                        oldStripePrice,\n                        newStripePrice\n                    );\n                    console.log('payload', payload);\n                    // If the new product is more expensive than last paid, credit the user the amount of last paid\n                    return {\n                        action: ManualOrderAction.NewRenewalOrder,\n                        ...payload,\n                    };\n                } else {\n                    throw new Error(\n                        'Could not get old price and new price for user'\n                    );\n                }\n            }\n            return {\n                action: ManualOrderAction.NewRenewalOrder,\n                price: convertStripePriceToDollars(newStripePrice),\n            };\n        } else {\n            // Base Order is finalized, create a first time renewal order\n            throw new Error(\n                '[EDGE CASE] Need to create first time renewal order - flag engineering'\n            );\n        }\n    }\n}"
      },
      {
        "name": "getPriceForStripePriceId",
        "kind": "function",
        "signature": "export async function getPriceForStripePriceId(price_id: string) {\n    const stripePrice = await getStripePriceId(price_id);\n\n    return stripePrice.unit_amount;\n}"
      },
      {
        "name": "processOnCreateOrder",
        "kind": "function",
        "signature": "export async function processOnCreateOrder(\n    profile_data: APProfileData,\n    orderInformation: any,\n    selectedVariant: number,\n    selectedCadence: SubscriptionCadency,\n    selectedPaymentMethod: string,\n    selectedProduct: string,\n    needsProviderReview: boolean,\n    hasPaid: boolean,\n    metadata: any\n) {\n    const pvc = new ProductVariantController(\n        selectedProduct as PRODUCT_HREF,\n        selectedVariant,\n        profile_data.state as USStates\n    );\n\n    const pvc_conversion = pvc.getConvertedVariantIndex();\n    const newPharmacy = pvc_conversion.pharmacy;\n    const newVariantIndex = pvc_conversion.variant_index!;\n\n    const priceId = await getPriceIdForProductVariant( \n        selectedProduct,\n        newVariantIndex,\n        process.env.NEXT_PUBLIC_ENVIRONMENT!\n    );\n\n    if (!priceId) {\n        throw new Error('Unable to find price id');\n    }\n\n    if (!newPharmacy) {\n        throw new Error('Unable to locate pharmacy for product');\n    }\n\n    if (orderInformation.credit) {\n        const creditAmount = orderInformation.creditAmount;\n\n        await createBalanceTransaction(\n            profile_data.stripe_customer_id,\n            -creditAmount\n        );\n    } else if (orderInformation.refund) {\n        const invoiceId: string = metadata.invoiceId;\n\n        const refundStatus = await refundStripeInvoice(invoiceId);\n\n        if (refundStatus === Status.Failure) {\n            throw new Error('Failed to refund invoice for user');\n        }\n        // Refund the charge on the invoice and then create new order\n    }\n\n    if (orderInformation.action === ManualOrderAction.NewBaseOrder) {\n        const orderPayload: OrdersSBR = {\n            customer_uid: profile_data.id,\n            variant_index: newVariantIndex,\n            variant_text: metadata.variant_text,\n            subscription_type: selectedCadence,\n            stripe_metadata: {\n                clientSecret: '',\n                setupIntentId: '',\n                paymentMethodId: selectedPaymentMethod,\n            },\n            order_status: OrderStatus.UnapprovedCardDown,\n            product_href: selectedProduct,\n            price_id: priceId,\n            discount_id: undefined,\n            assigned_pharmacy: newPharmacy,\n            environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n            address_line1: profile_data.address_line1,\n            address_line2: profile_data.address_line2,\n            city: profile_data.city,\n            state: profile_data.state,\n            zip: profile_data.zip,\n            source: 'admin',\n        };\n\n        const order = await insertNewManualOrder(orderPayload);\n\n        // Cancel and void any ongoing GLP-1 subscriptions\n        const subscriptions = await getAllActiveGLP1SubscriptionsForProduct(\n            profile_data.id\n        );\n        if (subscriptions.length === 1) {\n            const subscription = subscriptions[0];\n\n            await cancelStripeSubscriptionManualOrder(subscription);\n        }\n\n        await updateStatusTagToReview(profile_data.id, String(order.id));\n    } else if (orderInformation.action === ManualOrderAction.NewRenewalOrder) {\n        const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {});\n\n        const latestRenewalOrder =\n            await getLatestRenewalOrderByCustomerAndProduct(\n                profile_data.id,\n                selectedProduct\n            );\n\n        if (!latestRenewalOrder) {\n            throw new Error('Could not find latest renewal order for user');\n        }\n\n        let subscription = await getPrescriptionSubscription(\n            latestRenewalOrder.subscription_id\n        );\n\n        if (!subscription) {\n            const subscriptions = await getAllActiveGLP1SubscriptionsForProduct(\n                profile_data.id\n            );\n            if (subscriptions.length === 1) {\n                subscription = subscriptions[0];\n            } else {\n                throw new Error(\n                    'Could not find subscription for renewal order'\n                );\n            }\n        }\n\n        if (subscription.status === 'scheduled-cancel') {\n            await stripe.subscriptions.update(\n                subscription.stripe_subscription_id,\n                {\n                    cancel_at_period_end: false,\n                }\n            );\n        }\n\n        if (subscription.status !== 'active') {\n            throw new Error('Unexpected subscription status');\n        }\n\n        const new_renewal_order_id = getNextRenewalOrderId(\n            String(latestRenewalOrder.original_order_id),\n            latestRenewalOrder.renewal_order_id\n        );\n\n        if (needsProviderReview) {\n            if (hasPaid) {\n                await updateStripeProductWithProduct(\n                    { ...subscription, product_href: selectedProduct },\n                    newVariantIndex,\n                    true\n                );\n            } else {\n                await updateStripeProductWithProduct(\n                    { ...subscription, product_href: selectedProduct },\n                    newVariantIndex,\n                    false\n                );\n            }\n            const order_status = hasPaid\n                ? RenewalOrderStatus.CheckupComplete_Unprescribed_Paid\n                : RenewalOrderStatus.CheckupComplete_Unprescribed_Unpaid;\n\n            const renewalOrderPayload: Partial<RenewalOrder> = {\n                customer_uuid: profile_data.id,\n                variant_index: newVariantIndex,\n                subscription_type: selectedCadence,\n                order_status,\n                product_href: selectedProduct,\n                assigned_pharmacy: newPharmacy,\n                environment: process.env.NEXT_PUBLIC_ENVIRONMENT!,\n                address_line1: profile_data.address_line1,\n                address_line2: profile_data.address_line2,\n                city: profile_data.city,\n                state: profile_data.state,\n                zip: profile_data.zip,\n                original_order_id: latestRenewalOrder.original_order_id,\n                renewal_order_id: new_renewal_order_id,\n                subscription_id: latestRenewalOrder.subscription_id,\n                price_id: priceId,\n            };\n\n            await createRenewalOrderWithPayload(renewalOrderPayload);\n\n            await updateStatusTagToReview(\n                profile_data.id,\n                new_renewal_order_id\n            );\n        } else {\n            if (hasPaid) {\n                const renewalOrderPayload: Partial<RenewalOrder> = {\n                    customer_uuid: profile_data.id,\n                    variant_index: newVariantIndex,\n                    subscription_type: selectedCadence,\n                    order_status:\n                        RenewalOrderStatus.CheckupComplete_Prescribed_Unpaid,\n                    product_href: selectedProduct,\n                    assigned_pharmacy: newPharmacy,\n                    environment: process.env.NEXT_PUBLIC_ENVIRONMENT!,\n                    address_line1: profile_data.address_line1,\n                    address_line2: profile_data.address_line2,\n                    city: profile_data.city,\n                    state: profile_data.state,\n                    zip: profile_data.zip,\n                    original_order_id: latestRenewalOrder.original_order_id,\n                    renewal_order_id: new_renewal_order_id,\n                    subscription_id: latestRenewalOrder.subscription_id,\n                    price_id: priceId,\n                };\n\n                await createRenewalOrderWithPayload(renewalOrderPayload);\n\n                await updateStripeProductWithProduct(\n                    { ...subscription, product_href: selectedProduct },\n                    newVariantIndex,\n                    true\n                );\n            } else {\n                const renewalOrderPayload: Partial<RenewalOrder> = {\n                    customer_uuid: profile_data.id,\n                    variant_index: newVariantIndex,\n                    subscription_type: selectedCadence,\n                    order_status:\n                        RenewalOrderStatus.CheckupComplete_Prescribed_Unpaid,\n                    product_href: selectedProduct,\n                    assigned_pharmacy: newPharmacy,\n                    environment: process.env.NEXT_PUBLIC_ENVIRONMENT!,\n                    address_line1: profile_data.address_line1,\n                    address_line2: profile_data.address_line2,\n                    city: profile_data.city,\n                    state: profile_data.state,\n                    zip: profile_data.zip,\n                    original_order_id: latestRenewalOrder.original_order_id,\n                    renewal_order_id: new_renewal_order_id,\n                    subscription_id: latestRenewalOrder.subscription_id,\n                    price_id: priceId,\n                };\n\n                await createRenewalOrderWithPayload(renewalOrderPayload);\n\n                await updateStripeProductWithProduct(\n                    { ...subscription, product_href: selectedProduct },\n                    newVariantIndex,\n                    false\n                );\n            }\n        }\n\n        await updatePrescriptionSubscription(subscription.id, {\n            product_href: selectedProduct,\n            assigned_pharmacy: newPharmacy,\n            since_last_checkup: 0,\n            status: 'active',\n            subscription_type: selectedCadence,\n            price_id: priceId,\n            order_id: latestRenewalOrder.original_order_id,\n            variant_text: metadata.variant_text,\n        });\n\n        // When creating a new renewal order, will need to create it accordingly\n        // Move customer's existing glp1 subscription\n        // If active stripe sub exists:\n        // If needs provider review\n        // If has paid: updateStripeProduct\n        // If hasn't paid: updateStripeProduct\n        // Order status: checkupcomplete_unprescribed_paid/unpaid\n\n        // If doesn't need provider review:\n        // If has paid: updateStripeProduct\n        // Update renewal order details\n        // updateStripeProduct\n        // if hasn't paid: updateStripeProduct\n        // order status: checkupcomplete_prescribed_unpaid\n        // variant index, pharmacy\n\n        // If no active glp1 stripe sub exists:\n        // break\n    }\n}"
      },
      {
        "name": "createNewBaseOrder",
        "kind": "function",
        "signature": "export async function createNewBaseOrder(\n    profile_data: DBPatientData,\n    product_href: PRODUCT_HREF,\n    variant_index: number,\n    cadence: SubscriptionCadency,\n    selectedPaymentMethod: string,\n    new_price_id: string,\n    newPharmacy: string\n) {\n    const newOrder: OrdersSBR = {\n        customer_uid: profile_data.id,\n        variant_index: variant_index,\n        subscription_type: cadence,\n        stripe_metadata: {\n            clientSecret: '',\n            setupIntentId: '',\n            paymentMethodId: selectedPaymentMethod,\n        },\n        order_status: OrderStatus.UnapprovedCardDown,\n        product_href: product_href,\n        price_id: new_price_id,\n        assigned_pharmacy: newPharmacy,\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n        address_line1: profile_data.address_line1,\n        address_line2: profile_data.address_line2,\n        city: profile_data.city,\n        state: profile_data.state,\n        zip: profile_data.zip,\n        source: 'admin',\n    };\n\n    const resp = await insertNewManualOrder(newOrder);\n\n    if (resp) {\n        await updateStatusTagToReview(profile_data.id, String(resp.id));\n    } else {\n        throw new Error('Failed to update status tag to review');\n    }\n}"
      },
      {
        "name": "overwriteExistingBaseOrder",
        "kind": "function",
        "signature": "export async function overwriteExistingBaseOrder(\n    baseOrder: BaseOrderInterface,\n    variant_index: number,\n    cadence: SubscriptionCadency,\n    selectedPaymentMethod: string,\n    new_price_id: string,\n    newPharmacy: string\n) {\n    const updatedOrderPayload: OrdersSBR = {\n        variant_index: variant_index,\n        subscription_type: cadence,\n        stripe_metadata: {\n            clientSecret: '',\n            setupIntentId: '',\n            paymentMethodId: selectedPaymentMethod,\n        },\n        assigned_pharmacy: newPharmacy,\n        order_status: OrderStatus.UnapprovedCardDown,\n        price_id: new_price_id,\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n        address_line1: baseOrder.address_line1,\n        address_line2: baseOrder.address_line2,\n        city: baseOrder.city,\n        state: baseOrder.state,\n        zip: baseOrder.zip,\n        source: 'admin',\n    };\n\n    await updateOrder(baseOrder.id, updatedOrderPayload);\n\n    await updateStatusTagToReview(baseOrder.customer_uid, String(baseOrder.id));\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/orders/create-order.ts",
      "bioverse-client/app/utils/database/controller/orders/create-manual-order.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/ManualOrderCreationDialog.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/orders/order-matching-dose-spot.ts",
    "exports": [
      {
        "name": "getBestOrderMatchesFromDatabase",
        "kind": "function",
        "signature": "export async function getBestOrderMatchesFromDatabase(\n    userId: string,\n    pharmacy: string,\n    doseSpotPrescriptionData: any\n) {\n    //matchBasedOnDrugDisplayName\n\n    const { data: displayNameNameMatchedOrder } =\n        await matchBasedOnDrugDisplayName(\n            userId,\n            doseSpotPrescriptionData.DisplayName,\n            pharmacy\n        );\n    if (displayNameNameMatchedOrder) {\n        console.log(\n            `Server: Order Match system: matched with Generic Drug Name: ${doseSpotPrescriptionData.DisplayName}`,\n            displayNameNameMatchedOrder\n        );\n        return displayNameNameMatchedOrder;\n    }\n\n    const { data: genericNameMatchedOrder } =\n        await matchBasedOnDispensableDrugId(\n            userId,\n            doseSpotPrescriptionData.DispensableDrugId,\n            pharmacy\n        );\n    if (genericNameMatchedOrder) {\n        console.log(\n            `Server: Order Match system: matched with Generic Drug Name: ${doseSpotPrescriptionData.GenericDrugName}`,\n            genericNameMatchedOrder\n        );\n        return genericNameMatchedOrder;\n    }\n\n    const { data: lexicompMatchedOrder } = await matchBasedOnLexicompId(\n        userId,\n        doseSpotPrescriptionData.LexiGenDrugId,\n        pharmacy\n    );\n    if (lexicompMatchedOrder) {\n        console.log(\n            `Server: Order Match system: matched with LexiGen Drug ID: ${doseSpotPrescriptionData.LexiGenDrugId}`,\n            lexicompMatchedOrder\n        );\n        return lexicompMatchedOrder;\n    }\n\n    const { data: compound_id_matched_order } =\n        await matchBasedOnCompoundNumber(\n            userId,\n            doseSpotPrescriptionData.CompoundId,\n            pharmacy\n        );\n    if (compound_id_matched_order) {\n        console.log(\n            `Server: Order Match system: matched with Compound ID: ${doseSpotPrescriptionData.CompoundId}`,\n            compound_id_matched_order\n        );\n        return compound_id_matched_order;\n    }\n\n    const { data: first_empty_order } =\n        await matchOrderAnyEmptyMatchingPharmacy(userId, pharmacy);\n    if (first_empty_order) {\n        console.log(\n            `Server: Order Match system: matched with first open order`,\n            first_empty_order\n        );\n        return first_empty_order;\n    }\n\n    return null;\n}"
      },
      {
        "name": "matchBasedOnGenericDrugName",
        "kind": "function",
        "signature": "export async function matchBasedOnGenericDrugName(\n    patientId: string,\n    generic_drug_name: string,\n    pharmacy: string\n) {\n    const matched_product_href =\n        DOSE_SPOT_GENERIC_DRUG_NAME_PAIRS[generic_drug_name] || null;\n\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select(\n            `\n        id,\n        external_tracking_metadata,\n        order_status,\n        product_href,\n        assigned_pharmacy,\n        subscription_type,\n        price_id,\n        customer_uid,\n        assigned_provider,\n        address_line1,\n        address_line2,\n        state,\n        zip,\n        city,\n        subscription_id\n      `\n        )\n        .eq('customer_uid', patientId) //return only records for this patient.\n        .eq('product_href', matched_product_href)\n        .eq('assigned_pharmacy', pharmacy)\n        .maybeSingle();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: getBestOrderMatchFromDatabase, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: data, error: null };\n}"
      },
      {
        "name": "matchBasedOnDrugDisplayName",
        "kind": "function",
        "signature": "export async function matchBasedOnDrugDisplayName(\n    patientId: string,\n    drug_display_name: string,\n    pharmacy: string\n) {\n    const matched_product_href =\n        DOSE_SPOT_DISPLAY_NAME_PAIRS[drug_display_name] || null;\n\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select(\n            `\n        id,\n        external_tracking_metadata,\n        order_status,\n        product_href,\n        assigned_pharmacy,\n        subscription_type,\n        price_id,\n        customer_uid,\n        assigned_provider,\n        address_line1,\n        address_line2,\n        state,\n        zip,\n        city,\n        subscription_id\n      `\n        )\n        .eq('customer_uid', patientId) //return only records for this patient.\n        .eq('product_href', matched_product_href)\n        .eq('assigned_pharmacy', pharmacy)\n        .maybeSingle();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: getBestOrderMatchFromDatabase, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: data, error: null };\n}"
      },
      {
        "name": "matchBasedOnDispensableDrugId",
        "kind": "function",
        "signature": "export async function matchBasedOnDispensableDrugId(\n    patientId: string,\n    dispensable_drug_id: number,\n    pharmacy: string\n) {\n    const matched_product_href =\n        DOSE_SPOT_DISPENSABLE_DRUG_ID_PAIRS[dispensable_drug_id] || null;\n\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select(\n            `\n        id,\n        external_tracking_metadata,\n        order_status,\n        product_href,\n        assigned_pharmacy,\n        subscription_type,\n        price_id,\n        customer_uid,\n        assigned_provider,\n        address_line1,\n        address_line2,\n        state,\n        zip,\n        city,\n        subscription_id\n      `\n        )\n        .eq('customer_uid', patientId) //return only records for this patient.\n        .eq('product_href', matched_product_href)\n        .eq('assigned_pharmacy', pharmacy)\n        .maybeSingle();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: getBestOrderMatchFromDatabase, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: data, error: null };\n}"
      },
      {
        "name": "matchBasedOnNDCNumber",
        "kind": "function",
        "signature": "export async function matchBasedOnNDCNumber(\n    patientId: string,\n    ndc_number: string,\n    pharmacy: string\n) {\n    const matched_product_href = DOSE_SPOT_NDC_PAIRS[ndc_number] || null;\n\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select(\n            `\n        id,\n        external_tracking_metadata,\n        order_status,\n        product_href,\n        assigned_pharmacy,\n        subscription_type,\n        price_id,\n        customer_uid,\n        assigned_provider,\n        address_line1,\n        address_line2,\n        state,\n        zip,\n        city,\n        subscription_id\n      `\n        )\n        .eq('customer_uid', patientId) //return only records for this patient.\n        .eq('product_href', matched_product_href)\n        .eq('assigned_pharmacy', pharmacy)\n        .order('last_updated', { ascending: false })\n        .maybeSingle();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: getBestOrderMatchFromDatabase, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: data, error: null };\n}"
      },
      {
        "name": "matchBasedOnCompoundNumber",
        "kind": "function",
        "signature": "export async function matchBasedOnCompoundNumber(\n    patientId: string,\n    compound_id: string,\n    pharmacy: string\n) {\n    const matched_product_href = DOSE_SPOT_COMPOUND_PAIRS[compound_id] || null;\n\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select(\n            `\n        id,\n        external_tracking_metadata,\n        order_status,\n        product_href,\n        assigned_pharmacy,\n        subscription_type,\n        price_id,\n        customer_uid,\n        assigned_provider,\n        address_line1,\n        address_line2,\n        state,\n        zip,\n        city,\n        subscription_id\n      `\n        )\n        .eq('customer_uid', patientId) //return only records for this patient.\n        .eq('product_href', matched_product_href)\n        .eq('assigned_pharmacy', pharmacy)\n        .order('last_updated', { ascending: false })\n        .maybeSingle();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: getBestOrderMatchFromDatabase, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: data, error: null };\n}"
      },
      {
        "name": "matchBasedOnLexicompId",
        "kind": "function",
        "signature": "export async function matchBasedOnLexicompId(\n    patientId: string,\n    lexicomp_id: string,\n    pharmacy: string\n) {\n    const matched_product_href =\n        DOSE_SPOT_LEXICOMP_DRUG_ID_PAIRS[lexicomp_id] || null;\n\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select(\n            `\n        id,\n        external_tracking_metadata,\n        order_status,\n        product_href,\n        assigned_pharmacy,\n        subscription_type,\n        price_id,\n        customer_uid,\n        assigned_provider,\n        address_line1,\n        address_line2,\n        state,\n        zip,\n        city,\n        subscription_id\n      `\n        )\n        .eq('customer_uid', patientId) //return only records for this patient.\n        .eq('product_href', matched_product_href)\n        .eq('assigned_pharmacy', pharmacy)\n        .order('last_updated', { ascending: false })\n        .maybeSingle();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: getBestOrderMatchFromDatabase, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: data, error: null };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/orders/order-matching-dose-spot.ts",
      "bioverse-client/app/api/dosespot/_event-actions/dose-spot/order-matcher.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/orders/orders-api.ts",
    "exports": [
      {
        "name": "getQuestionSetVersionForLastCompleteOrder",
        "kind": "function",
        "signature": "export async function getQuestionSetVersionForLastCompleteOrder(\n    user_id: string,\n    product_href: PRODUCT_HREF\n): Promise<number> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select('question_set_version')\n        .eq('customer_uid', user_id)\n        .eq('product_href', product_href)\n        .order('created_at', { ascending: true })\n        .limit(1)\n        .single();\n\n    if (error || !data.question_set_version) {\n        return 1;\n    }\n\n    return data.question_set_version as number;\n}"
      },
      {
        "name": "getFirstCompletedOrderCreatedDate",
        "kind": "function",
        "signature": "export async function getFirstCompletedOrderCreatedDate(\n    user_id: string,\n    product_href: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select('created_at')\n        .eq('customer_uid', user_id)\n        .eq('product_href', product_href)\n        .order('created_at', { ascending: true })\n        .limit(1)\n        .single();\n\n    if (error || !data) {\n        return new Date();\n    }\n\n    return data.created_at;\n}"
      },
      {
        "name": "getFirstCompletedOrder",
        "kind": "function",
        "signature": "export async function getFirstCompletedOrder(\n    user_id: string,\n    product_href: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select('*')\n        .eq('customer_uid', user_id)\n        .eq('product_href', product_href)\n        .order('created_at', { ascending: true })\n        .limit(1)\n        .single();\n\n    if (error || !data) {\n        return null;\n    }\n\n    return data as BaseOrderInterface;\n}"
      },
      {
        "name": "deleteOrderById",
        "kind": "function",
        "signature": "export async function deleteOrderById(order_id: number) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .delete()\n        .eq('id', order_id);\n\n    if (error) {\n        console.error('Error getting base order by order id', order_id);\n        return null;\n    }\n}"
      },
      {
        "name": "assignProviderToOrderUsingOrderId",
        "kind": "function",
        "signature": "export async function assignProviderToOrderUsingOrderId(\n    orderId: number,\n    providerId: string\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const current_time = new Date();\n\n    const { data: fetchedData, error } = await supabase\n        .from('orders')\n        .update({\n            assigned_provider: providerId,\n            assigned_provider_timestamp: current_time,\n        })\n        .eq('id', orderId)\n        .select();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: assignProviderToOrderUsingOrderId, error: ',\n            error\n        );\n\n        return { data: null, error: error };\n    }\n\n    return { data: fetchedData, error: null };\n}"
      },
      {
        "name": "getBaseOrderById",
        "kind": "function",
        "signature": "export async function getBaseOrderById(order_id: number) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select('*')\n        .eq('id', order_id)\n        .maybeSingle();\n\n    if (error) {\n        console.error('Error getting base order by order id', order_id);\n        return null;\n    }\n\n    return data as BaseOrderInterface;\n}"
      },
      {
        "name": "getOrderForProduct",
        "kind": "function",
        "signature": "export async function getOrderForProduct(\n    product_href: string,\n    customer_id: string\n): Promise<BaseOrder | null> {\n    const supabase = createSupabaseServiceClient();\n\n    if (\n        [\n            PRODUCT_HREF.METFORMIN,\n            PRODUCT_HREF.SEMAGLUTIDE,\n            PRODUCT_HREF.TIRZEPATIDE,\n            PRODUCT_HREF.OZEMPIC,\n            PRODUCT_HREF.MOUNJARO,\n            PRODUCT_HREF.WEGOVY,\n            PRODUCT_HREF.ZEPBOUND,\n            PRODUCT_HREF.WL_CAPSULE,\n        ].includes(product_href as PRODUCT_HREF)\n    ) {\n        console.log('Fetching individual wl order');\n        return await getOrderForIndividualWLProduct(product_href, customer_id);\n    }\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select('*')\n        .eq('product_href', product_href)\n        .eq('customer_uid', customer_id)\n        .limit(1)\n        .order('created_at', { ascending: false })\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            'Error doesCustomerHaveOrderWithProduct',\n            error,\n            product_href,\n            customer_id\n        );\n        return null;\n    }\n\n    return data as BaseOrder;\n}"
      },
      {
        "name": "getOrderForIndividualWLProduct",
        "kind": "function",
        "signature": "export async function getOrderForIndividualWLProduct(\n    product_href: string,\n    customer_id: string\n): Promise<BaseOrder | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select('*')\n        .eq('product_href', product_href)\n        .eq('customer_uid', customer_id)\n        .is('metadata->selected_product', null) //make sure it's not a global wl order by checking if selected_product metadata exists\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            'Error doesCustomerHaveOrderWithProduct',\n            error,\n            product_href,\n            customer_id\n        );\n        return null;\n    }\n\n    return data as BaseOrder;\n}"
      },
      {
        "name": "getOrderForProductV2",
        "kind": "function",
        "signature": "export async function getOrderForProductV2(\n    product_href: string,\n    customer_id: string\n): Promise<BaseOrder[] | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select('*')\n        .eq('product_href', product_href)\n        .eq('customer_uid', customer_id);\n\n    if (error) {\n        console.error(\n            'Error getOrderForProduct',\n            error,\n            product_href,\n            customer_id\n        );\n        return null;\n    }\n\n    return data?.length ? (data as BaseOrder[]) : null;\n}"
      },
      {
        "name": "checkAndCreateOrder",
        "kind": "function",
        "signature": "export async function checkAndCreateOrder(\n    user_id: string,\n    productData: {\n        product_href: string;\n        variant: number;\n        subscriptionType: string;\n    },\n    priceData?: ProductVariantRecord[]\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select('*')\n        .eq('product_href', productData.product_href)\n        .eq('customer_uid', user_id)\n        .eq('source', 'intake')\n        .limit(1)\n        .maybeSingle();\n\n    //to be deleted (those product hrefs will be handled by checkAndCreateIndividualWLOrder():\n    if (['tirzepatide', 'semaglutide'].includes(productData.product_href)) {\n        const { data: glp1data, error: glp1error } = await supabase\n            .from('orders')\n            .select('*')\n            .in('product_href', ['semaglutide', 'tirzepatide'])\n            .eq('customer_uid', user_id)\n            .eq('source', 'intake');\n\n        // return null if the patient has a semaglutide or tirzepatide order that was completed (not incomplete/canceled)\n        const shouldReturnNull = glp1data?.some(\n            (order) =>\n                order &&\n                ![\n                    OrderStatus.Incomplete,\n                    OrderStatus.AdministrativeCancel,\n                    OrderStatus.Canceled,\n                ].includes(order.order_status)\n        );\n\n        if (shouldReturnNull) {\n            return null;\n        }\n    }\n\n    // if they do have an incomplete order for the chosen product, use that order in the flow\n    if (data && data.order_status === OrderStatus.Incomplete) {\n        console.log(\n            'returning an existing order to be used for the current flow'\n        );\n        return { order: data, error: null };\n    }\n\n    if (data && data.order_status !== OrderStatus.Incomplete) {\n        return null;\n    }\n\n    if (!data) {\n        //create a new order since no orders with the intake's product_href exist\n        console.log('creating a new order for the current flow');\n               // Only apply the placeholder for sermorelin\n        if (\n            productData.product_href === PRODUCT_HREF.SERMORELIN &&\n            (!productData.subscriptionType || productData.subscriptionType === '')\n        ) {\n            const fixedProductData = { ...productData, subscriptionType: 'monthly' };\n            return await createNewOrderV2(\n                user_id,\n                fixedProductData,\n                priceData ?? undefined\n            );\n        }\n     return await createNewOrderV2(\n            user_id,\n            productData,\n            priceData ?? undefined\n        );\n    }\n}"
      },
      {
        "name": "checkAndCreateIndividualWLOrder",
        "kind": "function",
        "signature": "export async function checkAndCreateIndividualWLOrder(\n    user_id: string,\n    productData: {\n        product_href: string;\n        variant: number;\n        subscriptionType: string;\n    },\n    priceData?: ProductVariantRecord[]\n) {\n    const supabase = createSupabaseServiceClient();\n\n    //'individual' as opposed to global weight-loss order\n    const { data: individualWLProductOrder, error } = await supabase\n        .from('orders')\n        .select('*')\n        .eq('product_href', productData.product_href)\n        .eq('customer_uid', user_id)\n        .eq('source', 'intake')\n        .is('metadata->selected_product', null) //make sure it's not a global wl order by checking if selected_product metadata exists\n        .limit(1)\n        .maybeSingle();\n\n    // if this is a semaglutide or tirzepatide order, check if the user has an existing completed order and if they do, return null\n    if (['tirzepatide', 'semaglutide'].includes(productData.product_href)) {\n        const { data: glp1data, error: glp1error } = await supabase\n            .from('orders')\n            .select('*')\n            .in('product_href', ['semaglutide', 'tirzepatide'])\n            .eq('customer_uid', user_id)\n            .eq('source', 'intake');\n\n        // return null if the patient has a semaglutide or tirzepatide order that was completed (not incomplete/canceled)\n        const shouldReturnNull = glp1data?.some(\n            (order) =>\n                order &&\n                ![\n                    OrderStatus.Incomplete,\n                    OrderStatus.AdministrativeCancel,\n                    OrderStatus.Canceled,\n                ].includes(order.order_status)\n        );\n\n        if (shouldReturnNull) {\n            console.log('Patient has already completed a glp-1 intake');\n            return null;\n        }\n    }\n\n    // if they do have an incomplete order for the chosen product, use that order in the flow\n    if (\n        individualWLProductOrder &&\n        individualWLProductOrder.order_status === OrderStatus.Incomplete\n    ) {\n        console.log(\n            'returning an existing order to be used for the current flow'\n        );\n        return { order: individualWLProductOrder, error: null };\n    }\n\n    if (!individualWLProductOrder) {\n        //create a new order since no orders with the intake's product_href exist\n        console.log('creating a new order for the current flow');\n        return await createNewOrderV2(\n            user_id,\n            productData,\n            priceData ?? undefined\n        );\n    }\n}"
      },
      {
        "name": "checkAndCreateCombinedWeightLossOrder",
        "kind": "function",
        "signature": "export async function checkAndCreateCombinedWeightLossOrder(\n    user_id: string,\n    productData: {\n        product_href: string;\n        variant: number;\n        subscriptionType: string;\n    },\n    priceData?: ProductVariantRecord[]\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: existingWeightLossProductOrders, error } = await supabase\n        .from('orders')\n        .select('*')\n        .in('product_href', [\n            PRODUCT_HREF.WEIGHT_LOSS,\n            PRODUCT_HREF.METFORMIN,\n            PRODUCT_HREF.SEMAGLUTIDE,\n            PRODUCT_HREF.TIRZEPATIDE,\n            PRODUCT_HREF.OZEMPIC,\n            PRODUCT_HREF.MOUNJARO,\n            PRODUCT_HREF.WEGOVY,\n            PRODUCT_HREF.ZEPBOUND,\n        ])\n        .eq('customer_uid', user_id)\n        .eq('source', 'intake');\n\n    let existingGlobalWLOrder = null;\n    let completedWLProductOrder = false;\n    existingWeightLossProductOrders?.forEach((order) => {\n        if (\n            order.metadata.selected_product &&\n            order.order_status === OrderStatus.Incomplete\n        ) {\n            existingGlobalWLOrder = order;\n            return { order: order, error: null };\n        } else {\n            if (\n                ![\n                    OrderStatus.Incomplete,\n                    OrderStatus.Canceled,\n                    OrderStatus.AdministrativeCancel,\n                ].includes(order.order_status)\n            ) {\n                console.log(\n                    'Patient has already completed a weight loss product intake'\n                );\n                completedWLProductOrder = true;\n                return null;\n            }\n        }\n    });\n\n    if (completedWLProductOrder) {\n        return null;\n    }\n\n    if (existingGlobalWLOrder) {\n        console.log(\n            'Returning existing global wl order to be used for the current flow'\n        );\n        return { order: existingGlobalWLOrder, error: null };\n    }\n\n    let price_data_empty: boolean = false;\n    if (isEmpty(priceData)) {\n        price_data_empty = true;\n    }\n\n    //since the user doens't have a weight-loss order, and since none of their other wl orders (if any) are complete/active --> create a new order\n    return await createNewOrderV2(\n        user_id,\n        productData,\n        price_data_empty ? undefined : priceData,\n        { selected_product: 'no selection yet' } //make sure to add the metadata here so it will always be known as global wl order\n    );\n}"
      },
      {
        "name": "createNewOrderV2",
        "kind": "function",
        "signature": "export async function createNewOrderV2(\n    user_id: string,\n    productData: {\n        product_href: string;\n        variant: number;\n        subscriptionType: string;\n    },\n    priceData?: ProductVariantRecord[],\n    metadata?: { [key: string]: any }\n) {\n    const variantPriceData = priceData?.find(\n        (variant) => variant.variant_index == productData.variant\n    );\n\n    const environment = process.env.NEXT_PUBLIC_ENVIRONMENT;\n\n    const order: Order = {\n        customer_uid: user_id,\n        product_href: productData.product_href,\n        variant_index: productData.variant,\n        subscription_type: productData.subscriptionType,\n        price: priceData\n            ? variantPriceData?.price_data.product_price\n            : undefined, //undefined because with combined weight loss, this may not be determinant for a bit.\n        price_id: priceData\n            ? variantPriceData?.stripe_price_ids[environment! as 'dev' | 'prod']\n            : undefined, //undefined because with combined weight loss, this may not be determinant for a bit.\n        order_status: 'Incomplete',\n        stripe_metadata: {\n            setupIntentId: '',\n            clientSecret: '',\n            paymentMethodId: '',\n        },\n        environment: environment ?? 'dev',\n        metadata: metadata ?? {},\n        ...(metadata?.source !== undefined ? { source: metadata.source } : {}), //only add source if it exists. This was added as a part of subscription reactivation 5/12/25\n    };\n\n    const supabase = createSupabaseServiceClient();\n    const { data: product_q_version_data, error: q_version_error } =\n        await supabase\n            .from('products')\n            .select('current_question_set_version')\n            .eq('href', order.product_href)\n            .limit(1)\n            .single();\n\n    const current_question_set_version =\n        product_q_version_data?.current_question_set_version;\n\n    const { data: newlyCreatedOrder, error } = await supabase\n        .from('orders')\n        .insert([\n            {\n                customer_uid: order.customer_uid,\n                product_href: order.product_href,\n                variant_index: order.variant_index,\n                subscription_type: order.subscription_type,\n                price: order.price,\n                order_status: order.order_status,\n                rx_questionnaire_answers: order.rxQuestionnaireAnswers,\n                stripe_metadata: order.stripe_metadata,\n                price_id: order.price_id,\n                environment: order.environment,\n                metadata: order.metadata,\n                ...(current_question_set_version\n                    ? { question_set_version: current_question_set_version }\n                    : {}),\n            },\n        ])\n        .select('id');\n\n    if (error) return { order: null, error: 'creation error' + error.message };\n\n    const questionnaire_session_id = await createQuestionnaireSessionForOrder(\n        order.customer_uid,\n        newlyCreatedOrder[0].id\n    );\n\n    const updatedOrder = {\n        ...order,\n        orderId: newlyCreatedOrder[0].id,\n        questionnaire_session_id: questionnaire_session_id,\n    };\n\n    return { order: updatedOrder, error: null };\n}"
      },
      {
        "name": "insertNewManualOrder",
        "kind": "function",
        "signature": "export async function insertNewManualOrder(\n    order_data: OrdersSBR,\n    getLatestVersion: boolean = true\n) {\n    const supabase = createSupabaseServiceClient();\n\n    if (getLatestVersion) {\n        const { data: product_q_version_data, error: q_version_error } =\n            await supabase\n                .from('products')\n                .select('current_question_set_version')\n                .eq('href', order_data.product_href)\n                .single();\n\n        const current_question_set_version =\n            product_q_version_data?.current_question_set_version;\n\n        order_data.question_set_version = current_question_set_version;\n    }\n\n    const { data, error } = await supabase\n        .from('orders')\n        .insert(order_data)\n        .select();\n\n    if (error) {\n        throw error;\n    }\n\n    return data[0] as BaseOrderInterface;\n}"
      },
      {
        "name": "insertNewFirstTimeOrder",
        "kind": "function",
        "signature": "export async function insertNewFirstTimeOrder(\n    order_data: Partial<BaseOrderInterface>\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .insert(order_data)\n        .select();\n\n    if (error) {\n        console.error(error);\n        throw error;\n    }\n\n    return data[0] as BaseOrderInterface;\n}"
      },
      {
        "name": "getBaseOrderByProduct",
        "kind": "function",
        "signature": "export async function getBaseOrderByProduct(\n    user_id: string,\n    product_href: PRODUCT_HREF\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select('*')\n        .eq('product_href', product_href)\n        .eq('customer_uid', user_id)\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            'Error doesCustomerHaveOrderWithProduct',\n            error,\n            product_href,\n            user_id\n        );\n        return null;\n    }\n\n    return data as BaseOrderInterface;\n}"
      },
      {
        "name": "getAllOrdersByPatientId",
        "kind": "function",
        "signature": "export async function getAllOrdersByPatientId(patientId: string) {\n    const supabase = createSupabaseServerComponentClient();\n    const { data, error } = await supabase\n        .from('orders')\n        .select(\n            `\n        id,\n        created_at,\n        variant_text,\n        product_href,\n        product:products!product_href (\n          name\n        )\n      `\n        )\n        .eq('customer_uid', patientId);\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: getAllOrdersByPatientId, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: data, error: null };\n}"
      },
      {
        "name": "getCombinedOrderForBanner",
        "kind": "function",
        "signature": "export async function getCombinedOrderForBanner(user_id: string) {\n    const combinedOrder = await getCombinedOrder(user_id);\n}"
      },
      {
        "name": "getCombinedOrder",
        "kind": "function",
        "signature": "export async function getCombinedOrder(\n    user_id: string | false | undefined\n): Promise<BaseOrder | null> {\n    if (!user_id) {\n        return null;\n    }\n\n    var finalOrder;\n\n    const orderData = await getOrderForProduct(\n        PRODUCT_HREF.WEIGHT_LOSS,\n        user_id\n    );\n\n    if (!orderData) {\n        const combinedOrder = await getCombinedWeightlossOrderForUser(user_id);\n        if (!combinedOrder) {\n            console.error('Could not get combined order for user', user_id);\n        }\n        finalOrder = combinedOrder;\n    } else {\n        finalOrder = orderData;\n    }\n\n    return finalOrder;\n}"
      },
      {
        "name": "getCombinedOrderV2",
        "kind": "function",
        "signature": "export async function getCombinedOrderV2(\n    user_id: string | false | undefined\n): Promise<BaseOrder | null> {\n    if (!user_id) {\n        return null;\n    }\n\n    var finalOrder;\n\n    const orderData = await getOrderForProduct(\n        PRODUCT_HREF.WEIGHT_LOSS,\n        user_id\n    );\n\n    if (!orderData) {\n        const combinedOrder = await getIncompleteGlobalWLOrderPostHrefSwap(\n            user_id\n        );\n        if (!combinedOrder) {\n            console.error('Could not get combined order for user', user_id);\n        }\n        finalOrder = combinedOrder;\n    } else {\n        finalOrder = orderData;\n    }\n\n    return finalOrder;\n}"
      },
      {
        "name": "getPossibleDoseSpotMatchOrdersUsingPatientId",
        "kind": "function",
        "signature": "export async function getPossibleDoseSpotMatchOrdersUsingPatientId(\n    patientId: string\n) {\n    const supabase = createSupabaseServerComponentClient();\n    const { data, error } = await supabase\n        .from('orders')\n        .select(\n            `\n          id,\n          created_at,\n          variant_text,\n          product_href,\n          assigned_pharmacy,\n          external_tracking_metadata,\n          stripe_metadata,\n          price_id\n        `\n        )\n        .is('assigned_pharmacy', null)\n        .eq('customer_uid', patientId);\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: getPossibleDoseSpotMatchOrdersUsingPatientId, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: data, error: null };\n}"
      },
      {
        "name": "getOrdersForCustomer",
        "kind": "function",
        "signature": "export async function getOrdersForCustomer(\n    customer_id: string\n): Promise<OrderItem[]> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc('get_orders_for_patientv2', {\n        customer_id,\n    });\n\n    if (error) {\n        console.error('Error retreiving orders for customer', error);\n        return [];\n    }\n\n    console.log('order data', data);\n\n    return data as OrderItem[];\n}"
      },
      {
        "name": "getOrderIdByPatientIdAndProductHref",
        "kind": "function",
        "signature": "export async function getOrderIdByPatientIdAndProductHref(\n    patient_id: string,\n    product_href: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select('id')\n        .eq('customer_uid', patient_id)\n        .eq('product_href', product_href)\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .single();\n\n    if (error) {\n        console.log(error);\n    }\n\n    return data?.id;\n}"
      },
      {
        "name": "getCombinedWeightlossOrderForUser",
        "kind": "function",
        "signature": "export async function getCombinedWeightlossOrderForUser(\n    user_id: string\n): Promise<BaseOrder | null> {\n    const productHrefs = [\n        PRODUCT_HREF.SEMAGLUTIDE,\n        PRODUCT_HREF.TIRZEPATIDE,\n        PRODUCT_HREF.METFORMIN,\n    ];\n\n    const orders = await Promise.all(\n        productHrefs.map((href) => getOrderForProduct(href, user_id))\n    );\n\n    const validOrders = orders.filter((order) => order !== null);\n\n    if (validOrders.length !== 1) {\n        console.error('Fetched more than 1 glp1 order', user_id);\n        return null;\n    }\n\n    return validOrders[0];\n}"
      },
      {
        "name": "getIncompleteGlobalWLOrderPostHrefSwap",
        "kind": "function",
        "signature": "export async function getIncompleteGlobalWLOrderPostHrefSwap(\n    user_id: string\n): Promise<BaseOrder | null> {\n    const productHrefs = [\n        PRODUCT_HREF.SEMAGLUTIDE,\n        PRODUCT_HREF.TIRZEPATIDE,\n        PRODUCT_HREF.METFORMIN,\n        PRODUCT_HREF.WL_CAPSULE,\n    ];\n\n    const ordersArray = await Promise.all(\n        productHrefs.map((href) => getOrderForProductV2(href, user_id))\n    );\n\n    // Flatten the array and filter out null values\n    const orders = ordersArray.flat().filter(Boolean);\n\n    const validOrders = orders.filter(\n        (order) =>\n            order !== null &&\n            order.order_status === OrderStatus.Incomplete &&\n            order.metadata?.['selected_product']\n    );\n\n    if (validOrders.length !== 1) {\n        //if there are multiple orders just get the most recently created one\n        const orderWithSelectedProduct = validOrders\n            .filter((order) => order?.metadata?.['selected_product'])\n            .sort(\n                (a, b) =>\n                    new Date(b?.created_at ?? 0).getTime() -\n                    new Date(a?.created_at ?? 0).getTime()\n            )[0];\n\n        if (orderWithSelectedProduct) {\n            return orderWithSelectedProduct;\n        }\n\n        console.error(\n            'Fetched more than 1 weight loss order and none had selected_product metadata',\n            user_id\n        );\n        return null;\n    }\n\n    return validOrders[0];\n}"
      },
      {
        "name": "getAllOrdersForProduct",
        "kind": "function",
        "signature": "export async function getAllOrdersForProduct(\n    user_id: string,\n    product_href: string\n): Promise<CustomPrescriptionOrder[]> {\n    const supabase = createSupabaseServiceClient();\n    //ASSIGNED PROVIDER\n    const { data: orders, error } = await supabase\n        .from('orders')\n        .select('*')\n        .eq('product_href', product_href)\n        .eq('customer_uid', user_id)\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error getAllOrdersForProduct', error, user_id);\n        return [];\n    }\n\n    const { data: renewalOrders, error: renewalsError } = await supabase\n        .from('renewal_orders')\n        .select('*')\n        .eq('product_href', product_href)\n        .eq('customer_uuid', user_id)\n        .order('created_at', { ascending: false });\n\n    if (renewalsError) {\n        console.error('Error getAllOrdersForProduct', error, user_id);\n        return [];\n    }\n\n    const mergedOrders = concat(orders, renewalOrders);\n\n    return mergedOrders.map((order: any) => {\n        return {\n            order_id: order.renewal_order_id\n                ? order.renewal_order_id\n                : String(order.id),\n            product_href: order.product_href,\n            created_at: order.created_at,\n            assigned_provider:\n                order.assigned_provider ?? providerInfoMeylinC.uuid,\n        };\n    });\n}"
      },
      {
        "name": "getAllGLP1RenewalOrdersForProduct",
        "kind": "function",
        "signature": "export async function getAllGLP1RenewalOrdersForProduct(\n    customer_id: string\n): Promise<RenewalOrder[] | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('renewal_orders')\n        .select('*')\n        .in('product_href', [PRODUCT_HREF.WEIGHT_LOSS])\n        .eq('customer_uuid', customer_id);\n\n    if (error) {\n        console.error(\n            'Error doesCustomerHaveOrderWithProduct',\n            error,\n            customer_id\n        );\n        return null;\n    }\n\n    return data as RenewalOrder[];\n}"
      },
      {
        "name": "getAllGLP1OrdersForProduct",
        "kind": "function",
        "signature": "export async function getAllGLP1OrdersForProduct(\n    customer_id: string\n): Promise<BaseOrder[] | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select('*')\n        .in('product_href', [PRODUCT_HREF.WEIGHT_LOSS])\n        .eq('customer_uid', customer_id);\n\n    if (error) {\n        console.error(\n            'Error doesCustomerHaveOrderWithProduct',\n            error,\n            customer_id\n        );\n        return null;\n    }\n\n    return data as BaseOrder[];\n}"
      },
      {
        "name": "getAllOrdersWithStatusArray",
        "kind": "function",
        "signature": "export async function getAllOrdersWithStatusArray(\n    statuses: string[],\n    afterDate: Date\n) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data: order_array, error: error } = await supabase\n        .from('orders')\n        .select('id, last_updated')\n        .in('order_status', statuses)\n        .eq('environment', 'prod');\n\n    if (error) {\n        console.log('admin error check progress: ', error);\n    }\n\n    const filtered_array = order_array!.filter(\n        (order) => new Date(order.last_updated) > afterDate\n    );\n\n    return filtered_array;\n}"
      },
      {
        "name": "doesOrderExistWithTrackingNumber",
        "kind": "function",
        "signature": "export async function doesOrderExistWithTrackingNumber(\n    trackingNumber: string,\n    orderId: string,\n    isRenewalOrder: boolean\n): Promise<boolean> {\n    const supabase = createSupabaseServiceClient();\n\n    if (isRenewalOrder) {\n        const { data: renewalOrderData, error: renewalOrdersError } =\n            await supabase\n                .from('renewal_orders')\n                .select('tracking_number')\n                .eq('renewal_order_id', orderId)\n                .maybeSingle();\n\n        if (renewalOrdersError) {\n            console.error(\n                'Error checking if there is an order with this tracking number',\n                trackingNumber,\n                renewalOrdersError\n            );\n        }\n\n        if (renewalOrderData?.tracking_number === trackingNumber) {\n            return true;\n        }\n    } else {\n        const { data: orderData, error: orderError } = await supabase\n            .from('orders')\n            .select('tracking_number')\n            .eq('id', orderId)\n            .maybeSingle();\n\n        if (orderError) {\n            console.error(\n                'Error checking if there is an order with this tracking number',\n                trackingNumber,\n                orderError\n            );\n        }\n\n        if (orderData?.tracking_number === trackingNumber) {\n            return true;\n        }\n    }\n\n    return false;\n}"
      },
      {
        "name": "doesOrderExistWithEasypostTrackingId",
        "kind": "function",
        "signature": "export async function doesOrderExistWithEasypostTrackingId(\n    trackingNumber: string,\n    orderId: string,\n    isRenewalOrder: boolean\n): Promise<boolean> {\n    const supabase = createSupabaseServiceClient();\n\n    if (isRenewalOrder) {\n        const { data: renewalOrderData, error: renewalOrdersError } =\n            await supabase\n                .from('renewal_orders')\n                .select('easypost_tracking_id')\n                .eq('renewal_order_id', orderId)\n                .maybeSingle();\n\n        if (renewalOrdersError) {\n            console.error(\n                'Error checking if there is an order with this tracking number',\n                trackingNumber,\n                renewalOrdersError\n            );\n        }\n\n        if (renewalOrderData?.easypost_tracking_id) {\n            return true;\n        }\n        return false;\n    } else {\n        const { data: orderData, error: orderError } = await supabase\n            .from('orders')\n            .select('easypost_tracking_id')\n            .eq('id', orderId)\n            .maybeSingle();\n\n        if (orderError) {\n            console.error(\n                'Error checking if there is an order with this tracking number',\n                trackingNumber,\n                orderError\n            );\n        }\n\n        if (orderData?.easypost_tracking_id) {\n            return true;\n        }\n        return false;\n    }\n\n    return false;\n}"
      },
      {
        "name": "getOrderIdUsingHallandaleOrderId",
        "kind": "function",
        "signature": "export async function getOrderIdUsingHallandaleOrderId(\n    hallandale_order_id: string\n): Promise<string | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select('id')\n        .eq(\n            'external_tracking_metadata -> hallandaleOrderId',\n            hallandale_order_id\n        )\n        .limit(1)\n        .maybeSingle();\n\n    if (!data || isEmpty(data)) {\n        const { data: renewalData, error: renewalError } = await supabase\n            .from('renewal_orders')\n            .select('renewal_order_id')\n            .eq(\n                'external_tracking_metadata -> hallandaleOrderId',\n                hallandale_order_id\n            )\n            .limit(1)\n            .maybeSingle();\n\n        if (!renewalData || isEmpty(renewalData)) {\n            console.error(\n                'Could not find order for hallandale order id',\n                hallandale_order_id\n            );\n            return null;\n        }\n\n        return renewalData.renewal_order_id;\n    }\n\n    if (data.id) {\n        return data.id;\n    }\n    return null;\n}"
      },
      {
        "name": "getPriceForProduct",
        "kind": "function",
        "signature": "export async function getPriceForProduct(order_id: number) {\n    const calculateDiscountPrice = (\n        product_href: string,\n        priceJson: any,\n        subscription_type: string,\n        discount_id: string[]\n    ) => {\n        const product_price = parseFloat(priceJson['product_price']);\n        // If weightloss product, always give discount\n        if (isWeightlossProduct(product_href)) {\n            if (priceJson.discount_price.discount_type === 'fixed') {\n                const discounted_price =\n                    product_price -\n                    priceJson['discount_price']['discount_amount'];\n                return discounted_price;\n            }\n\n            const discounted_price =\n                product_price -\n                (product_price *\n                    priceJson['discount_price']['discount_amount']) /\n                    100;\n            return discounted_price;\n        }\n\n        // Never give discount for non-weightloss one-time purchase products\n        if (subscription_type === 'one_time') {\n            return product_price;\n        }\n\n        // Only give discount to people who had discount_id populated\n        if (!discount_id || discount_id.length === 0) {\n            return product_price;\n        }\n\n        if (priceJson.discount_price.discount_type === 'percent') {\n            const discounted_price =\n                product_price -\n                (product_price *\n                    priceJson['discount_price']['discount_amount']) /\n                    100;\n            return discounted_price;\n        }\n\n        if (priceJson.discount_price.discount_type === 'fixed') {\n            const discounted_price =\n                product_price - priceJson['discount_price']['discount_amount'];\n            return discounted_price;\n        }\n        return 0;\n    };\n\n    const isWeightlossProduct = (product_href: string) => {\n        if (\n            product_href === 'ozempic' ||\n            product_href === 'metformin' ||\n            product_href === 'semaglutide' ||\n            product_href === 'wegovy' ||\n            product_href === 'tirzepatide' ||\n            product_href === 'mounjaro'\n        ) {\n            return true;\n        }\n        return false;\n    };\n\n    const supabase = await createSupabaseServerComponentClient();\n\n    try {\n        console.log('ORDER ID', order_id);\n        const { data, error } = await supabase\n            .from('orders')\n            .select(\n                'product_href, variant_index, subscription_type, discount_id'\n            )\n            .eq('id', order_id)\n            .single();\n\n        if (error) {\n            console.log(error, error.message);\n            return;\n        }\n        const { data: priceDataArray, error: productError } =\n            await getPriceVariantTableData(data?.product_href);\n\n        if (productError) {\n            console.log(productError, productError.message);\n            return;\n        }\n\n        const cadenceMatchedRecord = priceDataArray?.find(\n            (record) => record.variant_index == data.variant_index\n        );\n\n        const priceJson = cadenceMatchedRecord?.price_data;\n\n        const discountedPrice = calculateDiscountPrice(\n            data?.product_href,\n            priceJson,\n            data?.subscription_type,\n            data?.discount_id\n        );\n        return discountedPrice;\n    } catch (error: any) {\n        console.error(error, error.message);\n    }\n}"
      },
      {
        "name": "getProductFromOrderId",
        "kind": "function",
        "signature": "export async function getProductFromOrderId(order_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    // Check orders first\n    const { data, error } = await supabase\n        .from('orders')\n        .select('product_href')\n        .eq('id', order_id)\n        .maybeSingle();\n    if (error) {\n        console.error(\n            'Error fetching product from orders with order id',\n            error,\n            order_id\n        );\n    }\n\n    if (data) {\n        // Order is valid\n        return data.product_href;\n    }\n    // Check renewal_orders now\n    const { data: renewalOrders, error: renewalOrdersError } = await supabase\n        .from('renewal_orders')\n        .select('product_href')\n        .eq('renewal_order_id', order_id)\n        .maybeSingle();\n\n    if (renewalOrdersError) {\n        console.error(\n            'Error fetching product from order_renewals with order id',\n            error,\n            order_id\n        );\n    }\n    if (renewalOrders) {\n        return renewalOrders.product_href;\n    }\n    console.error('Unknown product_href for order_id', order_id);\n    return 'unknown';\n}"
      },
      {
        "name": "checkForExistingOrderV2",
        "kind": "function",
        "signature": "export async function checkForExistingOrderV2(\n    userUid: string,\n    productHref: string\n) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data: fetchedData, error } = await supabase\n        .from('orders')\n        .select(\n            'id, stripe_metadata, order_status, variant_index, subscription_type, address_line1, address_line2, city, state, zip, product_href'\n        )\n        .eq('customer_uid', userUid)\n        .eq('product_href', productHref)\n        .eq('source', 'intake')\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        console.log(\n            'order-control.ts | checkForExistingOrder: There was an error in fetching data from the server',\n            error.message\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: fetchedData ?? null, error: null };\n}"
      },
      {
        "name": "checkForExistingOrderWeightLoss",
        "kind": "function",
        "signature": "export async function checkForExistingOrderWeightLoss(userUid: string) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data: fetchedData, error } = await supabase\n        .from('orders')\n        .select(\n            'id, stripe_metadata, order_status, variant_index, subscription_type, address_line1, address_line2, city, state, zip, product_href'\n        )\n        .eq('customer_uid', userUid)\n        .in('product_href', ['semaglutide', 'tirzepatide', 'metformin'])\n        .eq('source', 'intake')\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        console.log(\n            'order-control.ts | checkForExistingOrder: There was an error in fetching data from the server',\n            error.message\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: fetchedData ?? null, error: null };\n}"
      },
      {
        "name": "getPatientOrderTabData",
        "kind": "function",
        "signature": "export async function getPatientOrderTabData(customer_uid: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select(\n            `id, \n            external_tracking_metadata, \n            order_status, \n            approval_denial_timestamp, \n            assigned_pharmacy, \n            shipping_status, \n            tracking_number, \n            product_href,\n            variant_index,\n            variant_text,\n            discount_id,\n            assigned_provider, \n            created_at, \n            subscription_type,\n            submission_time,\n            customer_uid,\n            address_line1,\n            address_line2,\n            state,\n            zip,\n            city,\n            question_set_version,\n            pharmacy_script,\n            product:products!product_href (\n                name\n            ),\n            provider:providers!assigned_provider (\n                id,\n                name\n            ),\n            subscription:prescription_subscriptions!subscription_id (\n                last_used_script,\n                stripe_subscription_id,\n                id,\n                status\n            ),\n            payment_failure:payment_failure_tracker!id (\n                status,\n                created_at\n            )\n            `\n        )\n        .eq('customer_uid', customer_uid)\n        .order('id', { ascending: true });\n\n    if (error) {\n        console.error(error);\n    }\n\n    return { data: data, error: error };\n}"
      },
      {
        "name": "getCustomerIDFromEasyPostTrackingID",
        "kind": "function",
        "signature": "export async function getCustomerIDFromEasyPostTrackingID(\n    easypost_tracking_id: string\n): Promise<EasyPostTrackerIDResponse> {\n    const supabase = createSupabaseServiceClient();\n\n    try {\n        const [resultOrders, resultOrderRenewals, resultCustomOrder] =\n            await Promise.all([\n                supabase\n                    .from('orders')\n                    .select('customer_uid, id, product_href, subscription_type')\n                    .eq('easypost_tracking_id', easypost_tracking_id)\n                    .maybeSingle(),\n                supabase\n                    .from('renewal_orders')\n                    .select(\n                        'customer_uuid, renewal_order_id, product_href, subscription_type'\n                    )\n                    .eq('easypost_tracking_id', easypost_tracking_id)\n                    .maybeSingle(),\n                supabase\n                    .from('custom_orders')\n                    .select('patient_id, custom_order_id, product_href')\n                    .eq('easypost_tracking_id', easypost_tracking_id)\n                    .maybeSingle(),\n            ]);\n\n        if (\n            resultOrders &&\n            resultOrders.data &&\n            resultOrderRenewals &&\n            resultOrderRenewals.data\n        ) {\n            // This shouldn't happen, use order renewal's customer id\n            console.error(\n                'Two orders found for easypost tracking id',\n                easypost_tracking_id\n            );\n            return {\n                success: true,\n                id: resultOrderRenewals.data.customer_uuid,\n                order_id: resultOrderRenewals.data.renewal_order_id,\n                product_href: resultOrderRenewals.data.product_href,\n                subscription_type: resultOrderRenewals.data.subscription_type,\n                type: OrderType.RenewalOrder,\n            };\n        } else if (resultOrders && resultOrders.data) {\n            // Order exists\n            return {\n                success: true,\n                id: resultOrders.data.customer_uid,\n                order_id: resultOrders.data.id,\n                product_href: resultOrders.data.product_href,\n                subscription_type: resultOrders.data.subscription_type,\n                type: OrderType.Order,\n            };\n        } else if (resultOrderRenewals && resultOrderRenewals.data) {\n            // Renewal order exists\n            return {\n                success: true,\n                id: resultOrderRenewals.data.customer_uuid,\n                order_id: resultOrderRenewals.data.renewal_order_id,\n                product_href: resultOrderRenewals.data.product_href,\n                subscription_type: resultOrderRenewals.data.subscription_type,\n                type: OrderType.RenewalOrder,\n            };\n        } else if (resultCustomOrder && resultCustomOrder.data) {\n            return {\n                success: true,\n                id: resultCustomOrder.data.patient_id,\n                order_id: resultCustomOrder.data.custom_order_id,\n                product_href: resultCustomOrder.data.product_href,\n                subscription_type: SubscriptionCadency.Monthly, // not needed\n                type: OrderType.CustomOrder,\n            };\n        } else {\n            // Neither\n            return {\n                success: false,\n                id: null,\n                type: OrderType.Order,\n                subscription_type: SubscriptionCadency.Monthly,\n            };\n        }\n    } catch (error) {\n        console.error(\n            'Controller Error. tablename: orders, method: getCustomerIDFromEasyPostTrackingID, error: ',\n            error,\n            easypost_tracking_id\n        );\n    }\n    return {\n        success: false,\n        id: null,\n        type: OrderType.Order,\n        subscription_type: SubscriptionCadency.Monthly,\n    };\n}"
      },
      {
        "name": "getCustomerIDFromTrackingNumber",
        "kind": "function",
        "signature": "export async function getCustomerIDFromTrackingNumber(tracking_number: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: fetchedData, error } = await supabase\n        .rpc('get_customer_from_tracking_number', {\n            tracking_number_: tracking_number,\n        })\n        .single();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: getCustomerIDFromTrackingNumber, error: ',\n            error,\n            tracking_number\n        );\n        return {\n            success: false,\n            order_id: null,\n            id: null,\n        } as ShippoTrackerIDResponse;\n    }\n    return {\n        ...(fetchedData as object),\n        success: true,\n    } as ShippoTrackerIDResponse;\n}"
      },
      {
        "name": "getAllOrdersForProviderOrderTableV2",
        "kind": "function",
        "signature": "export async function getAllOrdersForProviderOrderTableV2() {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_all_orders_for_provider_overview_v2',\n        {\n            environment_: process.env.NEXT_PUBLIC_ENVIRONMENT,\n        }\n    );\n\n    if (error) {\n        console.log('error', error);\n        return null;\n    }\n\n    // console.log('DATA', data);\n\n    return data;\n}"
      },
      {
        "name": "fetchMostRecentBaseOrder",
        "kind": "function",
        "signature": "export async function fetchMostRecentBaseOrder(\n    user_id: string,\n    product_href: PRODUCT_HREF\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select('*')\n        .eq('customer_uid', user_id)\n        .eq('product_href', product_href)\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .single();\n\n    if (error) {\n        return null;\n    }\n\n    return data as BaseOrderInterface;\n}"
      },
      {
        "name": "getAllOrdersForProviderOrderTable",
        "kind": "function",
        "signature": "export async function getAllOrdersForProviderOrderTable(providerId?: string) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select(\n            `\n            *,\n            product:products!product_href (\n                name\n            ),\n            patient:profiles!customer_uid (\n                first_name,\n                last_name,\n                state,\n                license_photo_url,\n                selfie_photo_url\n            )\n            `\n        )\n        .in('order_status', [\n            // 'Unapproved-NoCard', //this and the two below are disabled for early stages until more is added on payment failure paths.\n            'Unapproved-CardDown',\n            // 'Approved-NoCard',\n            'Approved-CardDown',\n            'Pending-Customer-Response',\n            'Denied-CardDown',\n            // 'Denied-NoCard',\n\n            'Approved-NoCard',\n\n            'Payment-Completed',\n            'Payment-Declined',\n\n            'Canceled',\n            'Incomplete',\n\n            'Approved-NoCard-Finalized',\n            'Approved-CardDown-Finalized',\n\n            'Order-Processing',\n            'Administrative-Cancel',\n        ])\n        .eq('environment', process.env.NEXT_PUBLIC_ENVIRONMENT)\n        // .or(`assigned_provider.eq.${providerId}, assigned_provider.is.${null}`) //temporarily disabled because maylin cannot see.\n        .order('created_at', { ascending: false });\n\n    if (error) return { error: error, data: null };\n\n    return { data: data, error: null };\n}"
      },
      {
        "name": "getAllOrdersForProviderOrderTablev2",
        "kind": "function",
        "signature": "export async function getAllOrdersForProviderOrderTablev2() {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        // 'get_all_orders_for_provider_dashboard',\n        'get_all_orders_for_provider_overview_v2',\n        {\n            environment_: process.env.NEXT_PUBLIC_ENVIRONMENT,\n        }\n    );\n\n    if (error) return { error: error, data: null };\n\n    if (error) return { error: error, data: null };\n    return { data: data, error: null };\n}"
      },
      {
        "name": "getLeadProviderOrders",
        "kind": "function",
        "signature": "export async function getLeadProviderOrders() {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc('get_lead_provider_orders', {\n        environment_: process.env.NEXT_PUBLIC_ENVIRONMENT,\n    });\n\n    if (error) return { error: error, data: null };\n\n    if (error) return { error: error, data: null };\n    return { data: data, error: null };\n}"
      },
      {
        "name": "getNextOrderForTaskQueue",
        "kind": "function",
        "signature": "export async function getNextOrderForTaskQueue(\n    licensed_states: USStates[],\n    environment_override: boolean = false,\n    assigned_provider: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_next_intake_for_task_queue_and_assign',\n        {\n            environment_: environment_override\n                ? 'dev'\n                : process.env.NEXT_PUBLIC_ENVIRONMENT,\n            licensed_states_: licensed_states,\n            provider_id_: assigned_provider,\n        }\n    );\n\n    if (error) {\n        console.error(\n            'Controller Error. tablename: orders, method: getNextOrderForTaskQueue, error: ',\n            error\n        );\n    }\n\n    return { data: data[0] as TaskOrderObject, error: null };\n}"
      },
      {
        "name": "getAllOrdersForTaskQueue",
        "kind": "function",
        "signature": "export async function getAllOrdersForTaskQueue(licensed_states: USStates[]) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_all_orders_for_task_queue_v2',\n        {\n            environment_: process.env.NEXT_PUBLIC_ENVIRONMENT,\n            licensed_states_: licensed_states,\n        }\n    );\n\n    if (error) return { error: error, data: null };\n\n    if (error) return { error: error, data: null };\n    return { data: data, error: null };\n}"
      },
      {
        "name": "getAllTaskQueueTotaOrderCount",
        "kind": "function",
        "signature": "export async function getAllTaskQueueTotaOrderCount() {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc('count_orders_for_task_queue', {\n        environment_: process.env.NEXT_PUBLIC_ENVIRONMENT,\n        licensed_states_: [\n            'AL',\n            'AK',\n            'AZ',\n            'AR',\n            'CA',\n            'CO',\n            'CT',\n            'DE',\n            'FL',\n            'GA',\n            'HI',\n            'ID',\n            'IL',\n            'IN',\n            'IA',\n            'KS',\n            'KY',\n            'LA',\n            'ME',\n            'MD',\n            'MA',\n            'MI',\n            'MN',\n            'MS',\n            'MO',\n            'MT',\n            'NE',\n            'NV',\n            'NH',\n            'NJ',\n            'NM',\n            'NY',\n            'NC',\n            'ND',\n            'OH',\n            'OK',\n            'OR',\n            'PA',\n            'RI',\n            'SC',\n            'SD',\n            'TN',\n            'TX',\n            'UT',\n            'VT',\n            'VA',\n            'WA',\n            'WV',\n            'WI',\n            'WY',\n        ],\n    });\n\n    if (error) return { error: error, data: null };\n\n    if (error) return { error: error, data: null };\n    return { data: data, error: null };\n}"
      },
      {
        "name": "getCurrentAssignedDosageForOrder",
        "kind": "function",
        "signature": "export async function getCurrentAssignedDosageForOrder(\n    order_id: number\n): Promise<string> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select('assigned_dosage')\n        .eq('id', order_id)\n        .limit(1)\n        .maybeSingle();\n\n    if (data?.assigned_dosage) {\n        return data?.assigned_dosage;\n    }\n\n    return '';\n}"
      },
      {
        "name": "getSafeGuardProviderId",
        "kind": "function",
        "signature": "export async function getSafeGuardProviderId(original_order_id: string) {\n    const order = await getBaseOrderById(Number(original_order_id));\n\n    if (!order || (order && !order.assigned_provider)) {\n        return providerInfoMeylinC.uuid;\n    }\n\n    return order.assigned_provider;\n}"
      },
      {
        "name": "getAssignedOrdersForProviderOrderTable",
        "kind": "function",
        "signature": "export async function getAssignedOrdersForProviderOrderTable(\n    providerId: string\n) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_assigned_orders_for_provider_overview',\n        {\n            environment_: process.env.NEXT_PUBLIC_ENVIRONMENT,\n            provider_id_: providerId,\n        }\n    );\n\n    if (error) {\n        console.error('error', error);\n        return { error: error, data: null };\n    }\n\n    return { data: data, error: null };\n}"
      },
      {
        "name": "fetchOrderDataByTaskId",
        "kind": "function",
        "signature": "export async function fetchOrderDataByTaskId(\n    taskId: string\n): Promise<OrderData> {\n    const supabase = createSupabaseServiceClient();\n\n    let { data: coordinator_task, error } = await supabase\n        .from('coordinator_tasks')\n        .select('*')\n        .eq('id', Number(taskId))\n        .limit(1)\n        .single();\n\n    if (error) {\n        return {\n            type: OrderType.Invalid,\n            data: {},\n        };\n    }\n\n    const orderId = coordinator_task.order_id;\n\n    const orderType = await getOrderType(orderId);\n\n    switch (orderType) {\n        case OrderType.Order:\n            const order = await getOrderById(orderId);\n            return {\n                type: OrderType.Order,\n                data: order.data,\n            };\n        case OrderType.RenewalOrder:\n            return {\n                type: OrderType.RenewalOrder,\n                data: await getRenewalOrderForPatientIntake(orderId),\n            };\n        default:\n            return {\n                type: OrderType.Invalid,\n                data: {},\n            };\n    }\n}"
      },
      {
        "name": "fetchOrderData",
        "kind": "function",
        "signature": "export async function fetchOrderData(orderId: string): Promise<OrderData> {\n    const orderType = await getOrderType(orderId);\n\n    switch (orderType) {\n        case OrderType.Order:\n            const order = await getOrderById(orderId);\n            return {\n                type: OrderType.Order,\n                data: order.data,\n            };\n        case OrderType.RenewalOrder:\n            return {\n                type: OrderType.RenewalOrder,\n                data: await getRenewalOrderForPatientIntake(orderId),\n            };\n        default:\n            return {\n                type: OrderType.Invalid,\n                data: {},\n            };\n    }\n}"
      },
      {
        "name": "getOrdersWithAssignedProvider",
        "kind": "function",
        "signature": "export async function getOrdersWithAssignedProvider(provider_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select(\n            '*, patient:profiles!customer_uid(first_name, last_name, date_of_birth)'\n        )\n        .eq('assigned_provider', provider_id);\n\n    if (error) {\n        console.log(error);\n        return null;\n    }\n\n    return data;\n}"
      },
      {
        "name": "getAllOrdersForPatient",
        "kind": "function",
        "signature": "export async function getAllOrdersForPatient(patient_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select('product_href, question_set_version, created_at')\n        .eq('customer_uid', patient_id);\n\n    if (error) {\n        console.error(\n            'getAllOrdersForPatient error for patient ID: ',\n            patient_id,\n            'error: ',\n            error\n        );\n    }\n\n    const uniqueArray = _.uniqBy(data, 'product_href');\n\n    return uniqueArray;\n}"
      },
      {
        "name": "getOrderById",
        "kind": "variable",
        "signature": "getOrderById = async (orderId: string) => {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select(\n            `\n          *,\n          patient:profiles!customer_uid (\n            first_name,\n            last_name\n          ),\n          product:products!product_href (\n            name\n          ),\n          provider:providers!assigned_provider (\n            name\n          ),\n          subscription:prescription_subscriptions!subscription_id (\n            status,\n            stripe_subscription_id\n          )`\n        )\n        .eq('id', orderId)\n        .single();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: getOrderById, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: data, error: null };\n}"
      },
      {
        "name": "getOrderDetailsById",
        "kind": "variable",
        "signature": "getOrderDetailsById = async (orderId: number) => {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select('*')\n        .eq('id', orderId)\n        .single();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: getOrderDetailsById, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: data, error: null };\n}"
      },
      {
        "name": "checkIsRenewalOrder",
        "kind": "variable",
        "signature": "checkIsRenewalOrder = async (orderId: number) => {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('renewal_orders')\n        .select('*')\n        .eq('original_order_id', orderId)\n        .single();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: getOrderDetailsById, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n    if (data) {\n        return { data: true, error: error };\n    }\n    return { data: null, error: error };\n}"
      },
      {
        "name": "updateOrder",
        "kind": "function",
        "signature": "export async function updateOrder(\n    orderId: number,\n    updatedPayload: Partial<OrdersSBR | any>\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .update(updatedPayload)\n        .eq('id', orderId);\n\n    if (error) {\n        console.log('Error updating order', error, orderId, updatedPayload);\n        return Status.Failure;\n    }\n    return Status.Success;\n}"
      },
      {
        "name": "updateOrderSubscriptionID",
        "kind": "function",
        "signature": "export async function updateOrderSubscriptionID(\n    order_id: number | undefined,\n    subscription_id: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error: updateError } = await supabase\n        .from('orders')\n        .update({ subscription_id: subscription_id })\n        .eq('id', order_id);\n\n    if (updateError) {\n        console.log(\n            'Update order with subscription ID error: could not update. reason: ',\n            updateError.message\n        );\n    }\n}"
      },
      {
        "name": "updateAssignedPharmacyWithOrderId",
        "kind": "function",
        "signature": "export async function updateAssignedPharmacyWithOrderId(\n    orderId: string,\n    updated_pharmacy: string\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { error: updateError } = await supabase\n        .from('orders')\n        .update({ assigned_pharmacy: updated_pharmacy })\n        .eq('id', orderId);\n\n    if (updateError) {\n        console.log(\n            'Controller Error. tablename: orders, method: updateAssignedPharmacyWithOrderId, error: ',\n            updateError\n        );\n    }\n}"
      },
      {
        "name": "updateOrderAfterCardDown",
        "kind": "function",
        "signature": "export async function updateOrderAfterCardDown(\n    orderId: number,\n    orderUpdateData: any,\n    otherFields?: any\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    console.log('ORDER UPDATE DATA', orderUpdateData);\n    console.log('OTHER FIELDS', otherFields);\n\n    console.log('ALL UPDATED', {\n        stripe_metadata: orderUpdateData,\n        order_status: 'Unapproved-CardDown',\n        submission_time: new Date(),\n        ...(otherFields ? { ...otherFields } : {}),\n    });\n\n    const { data: updateData, error: updateError } = await supabase\n        .from('orders')\n        .update({\n            stripe_metadata: orderUpdateData,\n            order_status: 'Unapproved-CardDown',\n            submission_time: new Date(),\n            ...(otherFields ? { ...otherFields } : {}),\n        })\n        .eq('id', orderId);\n\n    if (updateError) {\n        console.log(\n            'Controller Error. tablename: orders, method: updateOrderAfterCardDown, error: ',\n            updateError\n        );\n        return 'error';\n    } else {\n        return 'success';\n    }\n}"
      },
      {
        "name": "addMetadataToRenewalOrder",
        "kind": "function",
        "signature": "export async function addMetadataToRenewalOrder(\n    renewalOrderId: string,\n    updatedPayload: Partial<OrdersSBR | any>\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: existingData, error: fetchError } = await supabase\n        .from('renewal_orders')\n        .select('metadata')\n        .eq('renewal_order_id', renewalOrderId)\n        .single();\n\n    if (fetchError) {\n        console.log(\n            'Error fetching existing metadata',\n            fetchError,\n            renewalOrderId\n        );\n        return Status.Failure;\n    }\n\n    const existingMetadata = existingData?.metadata || {};\n\n    // Merge new metadata with the existing one\n    const mergedMetadata = { ...existingMetadata, ...updatedPayload.metadata };\n\n    const { data, error } = await supabase\n        .from('renewal_orders')\n        .update({ metadata: mergedMetadata })\n        .eq('id', renewalOrderId);\n\n    if (error) {\n        console.log(\n            'Error updating order',\n            error,\n            renewalOrderId,\n            updatedPayload\n        );\n        return Status.Failure;\n    }\n    return Status.Success;\n}"
      },
      {
        "name": "addMetadataToOrder",
        "kind": "function",
        "signature": "export async function addMetadataToOrder(\n    orderId: string,\n    updatedPayload: Partial<OrdersSBR | any>\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: existingData, error: fetchError } = await supabase\n        .from('orders')\n        .select('metadata')\n        .eq('id', orderId)\n        .single();\n\n    if (fetchError) {\n        console.log('Error fetching existing metadata', fetchError, orderId);\n        return Status.Failure;\n    }\n\n    const existingMetadata = existingData?.metadata || {};\n\n    // Merge new metadata with the existing one\n    const mergedMetadata = { ...existingMetadata, ...updatedPayload.metadata };\n\n    const { data, error } = await supabase\n        .from('orders')\n        .update({ metadata: mergedMetadata })\n        .eq('id', orderId);\n\n    if (error) {\n        console.log('Error updating order', error, orderId, updatedPayload);\n        return Status.Failure;\n    }\n    return Status.Success;\n}"
      },
      {
        "name": "updateOrderAssignedDosage",
        "kind": "function",
        "signature": "export async function updateOrderAssignedDosage(\n    order_id: string | number,\n    new_dosage: string\n) {\n    if (typeof order_id === 'string' && order_id.includes('-')) {\n        order_id = order_id.split('-')[0];\n    }\n\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('orders')\n        .update({ assigned_dosage: new_dosage })\n        .eq('id', order_id);\n\n    if (error) {\n        console.error('updateOrderAssignedDosage, error: ', error);\n    }\n\n    return;\n}"
      },
      {
        "name": "updateShippingStatusByEasyPostTrackingID",
        "kind": "function",
        "signature": "export async function updateShippingStatusByEasyPostTrackingID(\n    easypost_tracking_id: string,\n    shippingStatus: ShippingStatus\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: orderData, error: orderError } = await supabase\n        .from('orders')\n        .select('id')\n        .eq('easypost_tracking_id', easypost_tracking_id)\n        .maybeSingle();\n\n    if (orderError) {\n        console.error(\n            'Error retreiving order by easypost tracking id',\n            orderError\n        );\n        return;\n    }\n\n    if (!orderData || orderData == null) {\n        // That means the order is in renewal_orders\n        const { data: orderRenewalData, error: orderRenewalError } =\n            await supabase\n                .from('renewal_orders')\n                .select('id')\n                .eq('easypost_tracking_id', easypost_tracking_id)\n                .maybeSingle();\n\n        if (orderRenewalError) {\n            console.error(\n                'Error retreiving order renewal by easypost tracking id',\n                orderError,\n                easypost_tracking_id\n            );\n            return;\n        }\n\n        // If unable to find here, we have an issue\n        if (!orderRenewalData || orderRenewalData == null) {\n            console.error(\n                'Could not find order from easypost tracking id',\n                easypost_tracking_id,\n                orderError\n            );\n            auditShippingTrackingFailed(\n                easypost_tracking_id,\n                'Could not find order from easypost tracking id',\n                JSON.stringify({ orderError, orderRenewalError }),\n                ''\n            );\n            return;\n        }\n\n        updateShippingStatusForOrder(\n            'renewal_orders',\n            orderRenewalData.id,\n            shippingStatus\n        );\n    } else {\n        updateShippingStatusForOrder('orders', orderData.id, shippingStatus);\n    }\n}"
      },
      {
        "name": "updateShippingStatusForOrder",
        "kind": "function",
        "signature": "export async function updateShippingStatusForOrder(\n    table: string,\n    id: string,\n    shippingStatus: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const order_status =\n        table === 'orders'\n            ? OrderStatus.ApprovedCardDownFinalized\n            : RenewalOrderStatus.PharmacyProcessing;\n\n    const { data, error } = await supabase\n        .from(table)\n        .update({ shipping_status: shippingStatus, order_status })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\n            'Error updating shipping status for',\n            table,\n            id,\n            shippingStatus,\n            error\n        );\n        throw new Error('Could not update shipping status for order');\n    }\n}"
      },
      {
        "name": "updateOrderShippingStatusAndExternalMetadata",
        "kind": "function",
        "signature": "export async function updateOrderShippingStatusAndExternalMetadata(\n    orderId: number | string,\n    shippingStatus: string,\n    externalMetadata: any,\n    renewal: boolean = false\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: originalMetadata, error: originalError } = await supabase\n        .from(renewal ? 'renewal_orders' : 'orders')\n        .select('external_tracking_metadata')\n        .eq(renewal ? 'renewal_order_id' : 'id', orderId)\n        .single();\n\n    if (originalError) {\n        console.log(\n            'Controller Error. tablename: orders, method: updateOrderShippingStatusAndExternalMetadata, error: ',\n            originalError\n        );\n        return { data: null, error: originalError };\n    }\n\n    const { data: fetchedData, error } = await supabase\n        .from(renewal ? 'renewal_orders' : 'orders')\n        .update({\n            // shipping_status: shippingStatus,\n            external_tracking_metadata: originalMetadata\n                ? {\n                      ...originalMetadata.external_tracking_metadata,\n                      ...externalMetadata,\n                  }\n                : externalMetadata,\n        })\n        .eq(renewal ? 'renewal_order_id' : 'id', orderId)\n        .select();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: updateOrderShippingStatusAndExternalMetadata, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: fetchedData, error: null };\n}"
      },
      {
        "name": "updateOrderExternalMetadata",
        "kind": "function",
        "signature": "export async function updateOrderExternalMetadata(\n    orderId: number,\n    externalMetadata: any\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { data: originalMetadata, error: originalError } = await supabase\n        .from('orders')\n        .select('external_tracking_metadata')\n        .eq('id', orderId)\n        .limit(1)\n        .maybeSingle();\n\n    if (originalError) {\n        console.log(\n            'Controller Error. tablename: orders, method: updateOrderExternalMetadata, error: ',\n            originalError\n        );\n        return { data: null, error: originalError };\n    }\n\n    const updatePayload = originalMetadata\n        ? {\n              ...originalMetadata.external_tracking_metadata,\n              ...externalMetadata,\n          }\n        : { ...externalMetadata };\n\n    if (updatePayload.external_tracking_metadata === null) {\n        delete updatePayload.external_tracking_metadata;\n    }\n\n    const { data: fetchedData, error } = await supabase\n        .from('orders')\n        .update({ external_tracking_metadata: updatePayload })\n        .eq('id', orderId)\n        .select();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: updateOrderExternalMetadata, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: fetchedData, error: null };\n}"
      },
      {
        "name": "updateOrderTrackingNumber",
        "kind": "function",
        "signature": "export async function updateOrderTrackingNumber(\n    orderId: string | number,\n    trackingNumber: string,\n    renewal: boolean = false\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: fetchedData, error } = await supabase\n        .from(renewal ? 'renewal_orders' : 'orders')\n        .update({\n            tracking_number: trackingNumber,\n        })\n        .eq(renewal ? 'renewal_order_id' : 'id', orderId)\n        .select();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: updateOrderTrackingNumber, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: fetchedData, error: null };\n}"
      },
      {
        "name": "updateTMCOrderMetadata",
        "kind": "function",
        "signature": "export async function updateTMCOrderMetadata(\n    orderId: number,\n    TMCOrderId: number\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { data: fetchedData, error } = await supabase\n        .from('orders')\n        .update({\n            external_tracking_metadata: { tmc_order_id: TMCOrderId },\n        })\n        .eq('id', orderId)\n        .select();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: updateTMCOrderMetadata, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: fetchedData, error: null };\n}"
      },
      {
        "name": "updateGGMOrderMetadata",
        "kind": "function",
        "signature": "export async function updateGGMOrderMetadata(\n    orderId: number,\n    GGMOrderId: number\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { data: fetchedData, error } = await supabase\n        .from('orders')\n        .update({\n            external_tracking_metadata: { ggm_order_id: GGMOrderId },\n        })\n        .eq('id', orderId)\n        .select();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: updateTMCOrderMetadata, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: fetchedData, error: null };\n}"
      },
      {
        "name": "updateExistingOrderStatusAndPharmacyUsingId",
        "kind": "function",
        "signature": "export async function updateExistingOrderStatusAndPharmacyUsingId(\n    orderId: number | string,\n    updateStatus: string,\n    pharmacy: string,\n    orderType: OrderType\n) {\n    const supabase = await createSupabaseServiceClient();\n\n    if (orderType === OrderType.Order) {\n        const { data: fetchedData, error } = await supabase\n            .from('orders')\n            .update({\n                order_status: updateStatus,\n                assigned_pharmacy: pharmacy,\n                approval_denial_timestamp: new Date(),\n            })\n            .eq('id', orderId)\n            .select();\n\n        if (error) {\n            console.log(\n                'Controller Error. tablename: orders, method: updateExistingOrderStatusAndPharmacyUsingId, error: ',\n                error\n            );\n\n            return { data: null, error: error };\n        }\n\n        return { data: fetchedData, error: null };\n    } else if (orderType === OrderType.RenewalOrder) {\n        const { data: fetchedData, error } = await supabase\n            .from('renewal_orders')\n            .update({\n                order_status: updateStatus,\n                assigned_pharmacy: pharmacy,\n                approval_denial_timestamp: new Date(),\n            })\n            .eq('renewal_order_id', orderId)\n            .select();\n\n        if (error) {\n            console.log(\n                'Controller Error. tablename: orders, method: updateExistingOrderStatusAndPharmacyUsingId, error: (Renewal Order)',\n                error\n            );\n\n            return { data: null, error: error };\n        }\n\n        return { data: fetchedData, error: null };\n    }\n}"
      },
      {
        "name": "updateExistingOrderPharmacyUsingId",
        "kind": "function",
        "signature": "export async function updateExistingOrderPharmacyUsingId(\n    orderId: number | string,\n    pharmacy: string\n) {\n    const supabase = await createSupabaseServiceClient();\n\n    const { data: fetchedData, error } = await supabase\n        .from('orders')\n        .update({\n            assigned_pharmacy: pharmacy,\n            approval_denial_timestamp: new Date(),\n        })\n        .eq('id', orderId)\n        .select();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: updateExistingOrderStatusAndPharmacyUsingId, error: ',\n            error\n        );\n\n        return { data: null, error: error };\n    }\n\n    return { data: fetchedData, error: null };\n}"
      },
      {
        "name": "updateExistingOrderPharmacyAndVariantIndexUsingId",
        "kind": "function",
        "signature": "export async function updateExistingOrderPharmacyAndVariantIndexUsingId(\n    orderId: number | string,\n    pharmacy: string,\n    variant_index: number\n) {\n    const supabase = await createSupabaseServiceClient();\n\n    const { data: fetchedData, error } = await supabase\n        .from('orders')\n        .update({\n            assigned_pharmacy: pharmacy,\n            approval_denial_timestamp: new Date(),\n            variant_index: variant_index,\n        })\n        .eq('id', orderId)\n        .select();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: updateExistingOrderStatusAndPharmacyUsingId, error: ',\n            error\n        );\n\n        return { data: null, error: error };\n    }\n\n    return { data: fetchedData, error: null };\n}"
      },
      {
        "name": "getAllOrdersForCoordinatorOrderTable",
        "kind": "function",
        "signature": "export async function getAllOrdersForCoordinatorOrderTable() {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_all_orders_for_coordinator_dashboardv2',\n        {\n            environment_: process.env.NEXT_PUBLIC_ENVIRONMENT,\n        }\n    );\n\n    if (error) return { error: error, data: null };\n\n    return { data: data, error: null };\n}"
      },
      {
        "name": "getAllLeadCoordinatorOrders",
        "kind": "function",
        "signature": "export async function getAllLeadCoordinatorOrders() {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: lead_coordinator_orders, error: lead_errors } =\n        await supabase.rpc('get_all_orders_for_status_tag_v2', {\n            lookup_status_tag: 'LeadCoordinator',\n        });\n\n    const { data: coordinator_new_order_tag_orders, error: new_order_errors } =\n        await supabase.rpc('get_all_orders_for_status_tag_v2', {\n            lookup_status_tag: 'CoordinatorCreateOrder',\n        });\n\n    if (lead_errors || new_order_errors) {\n        console.error(\n            'getAllLeadCoordinatorOrders',\n            lead_errors ?? new_order_errors\n        );\n        return null;\n    }\n\n    const list = concat(\n        lead_coordinator_orders,\n        coordinator_new_order_tag_orders\n    );\n\n    return list;\n}"
      },
      {
        "name": "removeAssignedProviderForProviderAssignedQueue",
        "kind": "function",
        "signature": "export async function removeAssignedProviderForProviderAssignedQueue(\n    provider_id: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase.rpc('unassign_provider_orders', {\n        p_environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n        p_uuid: provider_id,\n    });\n\n    if (error) {\n        console.error(\n            'removeAssignedProviderForProviderAssignedQueue: ',\n            error\n        );\n    }\n\n    return { error: null };\n}"
      },
      {
        "name": "getAllOrdersForCoordinatorOrderTablev2",
        "kind": "function",
        "signature": "export async function getAllOrdersForCoordinatorOrderTablev2() {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_all_orders_for_coordinator_dashboardv2',\n        {\n            environment_: process.env.NEXT_PUBLIC_ENVIRONMENT,\n        }\n    );\n\n    if (error) return { error: error, data: null };\n\n    return { data: data, error: null };\n}"
      },
      {
        "name": "getAllOrdersForAdminTable",
        "kind": "function",
        "signature": "export async function getAllOrdersForAdminTable(\n    startDate?: Date,\n    endDate?: Date\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc('getallordersadmintable', {\n        environment_: process.env.NEXT_PUBLIC_ENVIRONMENT,\n    });\n\n    if (error) {\n        console.log(error);\n        return { error: error, data: null };\n    }\n\n    let filteredData = data;\n\n    if (startDate && endDate) {\n        filteredData = data.filter((order: any) => {\n            const orderDate = new Date(order.created_at);\n            const isWithinRange =\n                orderDate >= (startDate ?? new Date('01-01-2024')) &&\n                orderDate <= (endDate ?? new Date());\n            return isWithinRange;\n        });\n    }\n\n    return { data: filteredData, error: null };\n}"
      },
      {
        "name": "updateOrderDiscount",
        "kind": "function",
        "signature": "export async function updateOrderDiscount(orderId: number) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data: fetchedOrderData, error: orderError } = await supabase\n        .from('orders')\n        .select('variant_index, subscription_type, discount_id, product_href')\n        .eq('id', orderId)\n        .single();\n\n    if (orderError) {\n        console.log(\n            'Controller Error. tablename: orders, method: updateOrderDiscount, cause: order fetch error: ',\n            orderError\n        );\n        console.log(orderId);\n        return;\n    }\n\n    const couponTable =\n        process.env.NEXT_PUBLIC_ENVIRONMENT === 'dev'\n            ? 'stripe_product_coupon_pairs'\n            : 'stripe_product_coupon_pairs_production';\n\n    const { data: couponId, error: couponFetchError } = await supabase\n        .from(couponTable)\n        .select('coupon_id')\n        .eq('product_href', fetchedOrderData.product_href)\n        .eq('variant_index', fetchedOrderData.variant_index)\n        .eq('cadence', fetchedOrderData.subscription_type)\n        .maybeSingle();\n\n    if (couponFetchError || !couponId) {\n        const { error } = await supabase\n            .from('orders')\n            .update({ discount_id: [] })\n            .eq('id', orderId);\n        return;\n    }\n\n    const { error } = await supabase\n        .from('orders')\n        .update({ discount_id: [couponId.coupon_id] })\n        .eq('id', orderId);\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: updateOrderDiscount, cause: update failure, error: ',\n            error\n        );\n        return;\n    }\n    return;\n}"
      },
      {
        "name": "updateExistingOrderStatusUsingId",
        "kind": "function",
        "signature": "export async function updateExistingOrderStatusUsingId(\n    orderId: number,\n    updateStatus: string\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { data: fetchedData, error } = await supabase\n        .from('orders')\n        .update({\n            order_status: updateStatus,\n        })\n        .eq('id', orderId)\n        .select();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: updateExistingOrderStatusUsingId, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: fetchedData, error: null };\n}"
      },
      {
        "name": "updateExistingOrderStatusUsingIdAfterPaymentFailure",
        "kind": "function",
        "signature": "export async function updateExistingOrderStatusUsingIdAfterPaymentFailure(\n    orderId: number,\n    updateStatus: string\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { data: fetchedData, error } = await supabase\n        .from('orders')\n        .update({\n            order_status: updateStatus,\n        })\n        .eq('id', orderId)\n        .select();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: updateExistingOrderStatusUsingId, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n\n    const { error: updateError } = await supabase\n        .from('payment_failure_tracker')\n        .update({ status: 'resolved' })\n        .eq('order_id', orderId);\n\n    return { data: fetchedData, error: null };\n}"
      },
      {
        "name": "updateExistingOrderStatusAndExternalMetadataUsingId",
        "kind": "function",
        "signature": "export async function updateExistingOrderStatusAndExternalMetadataUsingId(\n    orderId: number,\n    updateStatus: string,\n    externalMetadata: any\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { data: originalMetadata, error: originalError } = await supabase\n        .from('orders')\n        .select('external_tracking_metadata')\n        .eq('id', orderId)\n        .single();\n\n    if (originalError) {\n        console.log(\n            'Controller Error. tablename: orders, method: updateOrderShippingStatusAndExternalMetadata, error: ',\n            originalError\n        );\n        return { data: null, error: originalError };\n    }\n\n    const { data: fetchedData, error } = await supabase\n        .from('orders')\n        .update({\n            order_status: updateStatus,\n            external_tracking_metadata: originalMetadata\n                ? { ...originalMetadata, ...externalMetadata }\n                : externalMetadata,\n        })\n        .eq('id', orderId)\n        .select();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: updateExistingOrderStatusUsingId, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: fetchedData, error: null };\n}"
      },
      {
        "name": "updateOrderShippingStatus",
        "kind": "function",
        "signature": "export async function updateOrderShippingStatus(\n    orderId: number,\n    shippingStatus: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: fetchedData, error } = await supabase\n        .from('orders')\n        .update({\n            shipping_status: shippingStatus,\n        })\n        .eq('id', orderId)\n        .select();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: updateOrderShippingStatus, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: fetchedData, error: null };\n}"
      },
      {
        "name": "updateStripeMetadataForOrder",
        "kind": "function",
        "signature": "export async function updateStripeMetadataForOrder(\n    order_id: string,\n    stripe_metadata: any\n) {\n    const supabase = createSupabaseServiceClient();\n\n    await supabase\n        .from('orders')\n        .update({ stripe_metadata: stripe_metadata })\n        .eq('id', order_id);\n}"
      },
      {
        "name": "addEasyPostTrackingIDToOrder",
        "kind": "function",
        "signature": "export async function addEasyPostTrackingIDToOrder(\n    order_id: string,\n    tracking_id: string,\n    pharmacy: string\n) {\n    function countHyphens(str: string) {\n        const matches = str.match(/-/g);\n        return matches ? matches.length : 0;\n    }\n    const supabase = createSupabaseServiceClient();\n\n    const numHyphens = countHyphens(order_id);\n\n    // No hyphen - update in orders table\n    // 1 hyphen and gogo - update in orders table\n    if (\n        numHyphens === 0 ||\n        (numHyphens === 1 && pharmacy === EASYPOST_PHARMACIES.GOGO_MEDS)\n    ) {\n        const { data, error } = await supabase\n            .from('orders')\n            .update({\n                easypost_tracking_id: tracking_id,\n                shipping_status: ShippingStatus.Shipped,\n            })\n            .eq('id', order_id)\n            .select()\n            .maybeSingle();\n\n        if (error) {\n            console.error(error, error.message);\n            console.log('TRIGGERED???');\n            console.error(\n                `Failed to add easypost tracking id for order ${order_id}`,\n                data\n            );\n            auditShippingTrackingFailed(\n                order_id,\n                `Failed to add easypost tracking id for order ${order_id}`,\n                error,\n                pharmacy\n            );\n            throw error;\n        }\n        return { success: Status.Success, data };\n        // Contains 1 hypen and not gogo: order_renewals)\n        // Contains 2 hyphens: order_renewals\n    } else if (\n        (numHyphens === 1 && pharmacy !== EASYPOST_PHARMACIES.GOGO_MEDS) ||\n        numHyphens === 2\n    ) {\n        const { data, error } = await supabase\n            .from('renewal_orders')\n            .update({\n                easypost_tracking_id: tracking_id,\n                shipping_status: ShippingStatus.Shipped,\n            })\n            .eq('renewal_order_id', order_id)\n            .select()\n            .maybeSingle();\n\n        if (error) {\n            console.error(error, error.message);\n            console.error(\n                `Failed to add easypost tracking id for order ${order_id}`,\n                data\n            );\n            auditShippingTrackingFailed(\n                order_id,\n                `Failed to add easypost tracking id for order ${order_id}`,\n                error,\n                pharmacy\n            );\n\n            throw error;\n        }\n        return { success: Status.Success, data };\n    } else {\n        auditShippingTrackingFailed(\n            order_id,\n            `Failed to add easypost tracking id for order ${order_id}`,\n            'Something weird happened',\n            pharmacy\n        );\n        return { success: Status.Failure, data: {} };\n    }\n}"
      },
      {
        "name": "updateOrderShippingInformation",
        "kind": "function",
        "signature": "export async function updateOrderShippingInformation(\n    data: ShippingInformation,\n    order_id: number,\n    userId: string\n) {\n    if (order_id === -1) {\n        console.error(\n            'Could not update order shipping information - no order id found'\n        );\n        return false;\n    }\n    const supabase = createSupabaseServiceClient();\n\n    const { data: orderUpdateData, error: orderUpdateError } = await supabase\n        .from('orders')\n        .update({\n            address_line1: data.address_line1,\n            address_line2: data.address_line2,\n            city: data.city,\n            state: data.state,\n            zip: data.zip,\n        })\n        .eq('id', order_id);\n\n    const latestRenewalOrder = await getLatestRenewalOrderForOriginalOrderId(\n        String(order_id)\n    );\n\n    if (!latestRenewalOrder) {\n        return true;\n    }\n\n    await updateRenewalOrder(latestRenewalOrder.id, {\n        address_line1: data.address_line1,\n        address_line2: data.address_line2,\n        city: data.city,\n        state: data.state,\n        zip: data.zip,\n    });\n\n    //check if we need to update the address in Revive as well, then do so if necessary\n    await changePatientAddressInReviveIfNecessary(\n        userId,\n        {\n            address_line1: data.address_line1,\n            address_line2: data.address_line2,\n            city: data.city,\n            state: data.state,\n            zip: data.zip,\n        },\n        order_id.toString()\n    );\n\n    if (orderUpdateError) {\n        console.log(\n            'Controller tablename: orders, method: updateOrderShippingInformation, Error: ',\n            orderUpdateError\n        );\n        return false;\n    }\n\n    return true;\n}"
      },
      {
        "name": "updateOrderPharmacyScript",
        "kind": "function",
        "signature": "export async function updateOrderPharmacyScript(\n    pharmacy_script: any,\n    order_id: string | number\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .update({ pharmacy_script: pharmacy_script })\n        .eq('id', order_id)\n        .select();\n\n    if (error) {\n        console.error(\n            'updateOrderPharmacyScript ',\n            `pharmacy_script: ${pharmacy_script}`,\n            `order_id: ${order_id}`,\n            error,\n            error.message\n        );\n        return null;\n    }\n\n    return data;\n}"
      },
      {
        "name": "updateOrderPharmacyDisplayName",
        "kind": "function",
        "signature": "export async function updateOrderPharmacyDisplayName(\n    pharmacy_script: any,\n    order_id: string | number\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .update({ pharmacy_display_name: pharmacy_script['DisplayName'] })\n        .eq('id', order_id)\n        .select();\n\n    if (error) {\n        console.error(\n            'updateOrderPharmacyDisplayName ',\n            `pharmacy_script: ${pharmacy_script}`,\n            `order_id: ${order_id}`,\n            error,\n            error.message\n        );\n        return null;\n    }\n\n    return data;\n}"
      },
      {
        "name": "getOrderByCustomerIdAndProductHref",
        "kind": "function",
        "signature": "export async function getOrderByCustomerIdAndProductHref(\n    patient_id: string,\n    product_href: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('orders')\n        .select('*')\n        .eq('customer_uid', patient_id)\n        .eq('product_href', product_href)\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .single();\n\n    if (error) {\n        console.log(error);\n        return null;\n    }\n\n    return data as BaseOrderInterface;\n}"
      },
      {
        "name": "updateOrderMetadata",
        "kind": "function",
        "signature": "export async function updateOrderMetadata(\n    new_metadata: any,\n    order_id: number | string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: current_metadata, error: current_error } = await supabase\n        .from('orders')\n        .select('metadata')\n        .eq('id', order_id)\n        .limit(1)\n        .maybeSingle();\n\n    if (current_error) {\n        console.log('Error in updating order metadata. ', current_error);\n    }\n\n    const { error } = await supabase\n        .from('orders')\n        .update({\n            metadata: { ...current_metadata?.metadata, ...new_metadata },\n        })\n        .eq('id', order_id);\n\n    console.log('update metadata error ', error);\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/orders/orders-api.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/ManualOrderCreationDialog.tsx",
      "bioverse-client/app/utils/database/controller/renewal_orders/renewal_orders.ts",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/utils/coordinator-task-data-fetch.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/utils/data-fetch/intake-view-datafetch.ts",
      "bioverse-client/app/utils/database/controller/orders/create-order.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/intake-response-column/approval-buttons.tsx",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/confirm-prescription-dialog.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approval-buttons.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/decline-dialog.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approve-script-dialog.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/patient-information/approval-buttons/review-approval-buttons.tsx",
      "bioverse-client/app/api/provider-portal/tasks/route.ts",
      "bioverse-client/_deprecated/clinical-intake-flow/approval-buttons/provider-approval-buttons.tsx",
      "bioverse-client/app/(testing_and_development)/olivier-dev/utils.ts",
      "bioverse-client/app/utils/database/controller/job-scheduler/job-scheduler-actions.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/IDAndSelfieCheckJobHandler.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/StripeInvoicePaidJobHandler.ts",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component-ab.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/api/easypost/route.tsx",
      "bioverse-client/app/api/stripe/webhook/invoice-paid/route.ts",
      "bioverse-client/app/(patient-portal)/dosage/first-time/[order_id]/[variant_index]/page.tsx",
      "bioverse-client/app/(patient-portal)/dosage/first-time/[order_id]/page.tsx",
      "bioverse-client/app/services/customerio/customerioApiFactory.ts",
      "bioverse-client/app/(testing_and_development)/ben-dev/page.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-reviews-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/id-verification-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/id-verification-noskip-v3.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/select-wl-treatment-v3.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/glp-surgery-doc-upload.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/glp-surgery-doc-upload.tsx",
      "bioverse-client/app/components/intake-v2/questions/functions/questions-functions.ts",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/order-summary-v3-zbp/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/order-summary-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/order-summary-v4/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/order-summary-v3-ap/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/general-order-summary/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-supply/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-calculating-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-supply-v2/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v2/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-calculating/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-supply-v3-no-6/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-supply-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3-abtest/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-dosage/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/general-order-summary-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/select-supply-ap/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-dosage-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/ed-pre-id/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/bmi-summary/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-graph/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/ed-checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/skin-care-see-others/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/whats-next/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-female-safety/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-graph-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/order-summary/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-capsule-cadence-selection/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/questions-v3/[question_id]/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/questions-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/select-supply/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3-zbp/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/select-supply-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/skincare-frequency/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-reviews-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/ed-selection/[frequency]/[treatmentType]/[medication]/confirmation/page.tsx",
      "bioverse-client/app/services/stripe/subscriptions.ts",
      "bioverse-client/app/components/intake-v3/pages/demographic-collection.tsx",
      "bioverse-client/app/components/intake-v2/pages/demographic-information.tsx",
      "bioverse-client/app/components/intake-v2/pages/demographic-collection.tsx",
      "bioverse-client/app/components/intake-v3/pages/demographic-wl-v3.tsx",
      "bioverse-client/app/components/intake-v2/pages/demographic-wl.tsx",
      "bioverse-client/app/components/intake-v2/pages/combined-wl-demographic.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/SubscriptionList/utils/SubscriptionItem-functions.ts",
      "bioverse-client/app/utils/actions/alternatives/weight-loss/alternative-weight-loss-actions.ts",
      "bioverse-client/app/utils/database/controller/orders/create-manual-order.ts",
      "bioverse-client/app/components/intake-v3/topnav/banner.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-intro-3.tsx",
      "bioverse-client/app/components/intake-v3/pages/question-id-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/pre-question-id-v3.tsx",
      "bioverse-client/app/components/intake-v2/topnav/banner.tsx",
      "bioverse-client/app/components/intake-v2/pages/question-id.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/select-wl-treatment.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/select-wl-treatment-ro.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/pre-id-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-in-good-hands/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/pre-id-v3-post-co/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-up-next-preview/page.tsx",
      "bioverse-client/app/(testing_and_development)/dev/mock/order-history/[user_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/order-history/page.tsx",
      "bioverse-client/app/components/provider-portal/messages/components/provider-message-dashboard/provider-message-dashboard.tsx",
      "bioverse-client/app/utils/database/controller/profiles/profiles.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/custom-prescription-script/components/CustomPrescriptionConfirmationDialog.tsx",
      "bioverse-client/app/utils/database/controller/questionnaires/questionnaire.ts",
      "bioverse-client/app/(administration)/admin/check-progress/_components/number-display.tsx",
      "bioverse-client/app/services/pharmacy-integration/belmar/update-order.ts",
      "bioverse-client/app/services/pharmacy-integration/empower/update-order.ts",
      "bioverse-client/app/services/pharmacy-integration/revive/update-order.ts",
      "bioverse-client/app/services/pharmacy-integration/hallandale/update-order.ts",
      "bioverse-client/app/services/pharmacy-integration/boothwyn/update-order-boothwyn.ts",
      "bioverse-client/app/utils/functions/patient-portal/patient-portal-utils.ts",
      "bioverse-client/app/components/intake-v3/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/components/wl-checkout-component-fulltest.tsx",
      "bioverse-client/app/components/intake-v2/checkout/checkout-component.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/new-checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/product-overview/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/new-checkout/page.tsx",
      "bioverse-client/_deprecated/checkout-test/page.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/intakes/intake-tab-function.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/order-content.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/orders-content.tsx",
      "bioverse-client/app/utils/actions/admin/dashboard-scripts.ts",
      "bioverse-client/app/utils/actions/provider/dashboard-scripts.ts",
      "bioverse-client/app/components/admin/task-overview/task-overview-container.tsx",
      "bioverse-client/app/components/provider-portal/tasks/task-action-page/utils/task-action-data-fetch.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/quarterly-final-review-dialog.tsx",
      "bioverse-client/app/components/provider-portal/order-table/utils/assigned-order-fetch-helper.ts",
      "bioverse-client/_deprecated/clinical-intake-flow/order-table/utils/assigned-order-fetch-helper.ts",
      "bioverse-client/app/(employee)/(coordinator-portal)/coordinator/tasks/[taskId]/page.tsx",
      "bioverse-client/app/utils/classes/Pharmacy.ts",
      "bioverse-client/app/utils/classes/Scripts/BaseScriptHandler.ts",
      "bioverse-client/app/utils/functions/pharmacy-helpers/bundle-to-single-vial-converter.ts",
      "bioverse-client/app/utils/functions/annual-glp1/annual-glp1-controller.ts",
      "bioverse-client/app/utils/functions/split-shipment-glp1/split-shipment-glp1-controller.ts",
      "bioverse-client/app/utils/functions/prescription-scripts/hallandale-approval-script-generator.ts",
      "bioverse-client/app/utils/functions/prescription-scripts/revive-script-generator.ts",
      "bioverse-client/app/utils/functions/prescription-scripts/empower-approval-script-generator.ts",
      "bioverse-client/app/utils/functions/prescription-scripts/boothwyn-script-generator.ts",
      "bioverse-client/app/(employee)/(registered-nurse-portal)/registered-nurse/tasks/[taskId]/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/tasks/[taskId]/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/intakes/[orderId]/page.tsx",
      "bioverse-client/app/(employee)/(coordinator-portal)/coordinator/orders/[orderId]/page.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/CoordinatorConfirmDosage.tsx",
      "bioverse-client/app/api/supabase/annual-glp1/route.ts",
      "bioverse-client/app/api/supabase/split-shipment-glp1/route.ts",
      "bioverse-client/app/(patient-portal)/dosage-selection/[product]/[variant_index]/page.tsx",
      "bioverse-client/_deprecated/patient-intakes/[orderId]/page.tsx",
      "bioverse-client/app/(administration)/admin/stripe-api/stripe-api-actions.ts",
      "bioverse-client/app/utils/database/controller/patient-status-tags/patient-status-tags-api.ts",
      "bioverse-client/app/utils/actions/prescription-subscriptions/prescription-subscriptions-actions.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/utils/data-fetching/coordinator-thread-data-fetch.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/resend-script-confirmation.tsx",
      "bioverse-client/app/api/customerio/webhook/route.ts",
      "bioverse-client/app/api/tmc/send-script/route.ts",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/manage/[subscription_id]/page.tsx",
      "bioverse-client/app/utils/database/controller/questionnaires/questionnaire_sessions.ts",
      "bioverse-client/app/utils/database/controller/shipping_tracking_failed_audit/shipping-tracking-failed-audit.ts",
      "bioverse-client/app/utils/database/controller/prescription_subscriptions/prescription_subscriptions.ts",
      "bioverse-client/app/utils/actions/intake/order-util.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/containers/components/ReviewModal.tsx",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/containers/coordinator-main-view-container.tsx",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/script-view/coordiantor-hallandale-script-view.tsx",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/script-view/coordinator-empower-script-view.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/order-charts/components/StatusDropdown.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/utils/resend-scripts.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/ChangeOrderInformationDialog.tsx",
      "bioverse-client/app/components/provider-portal/order-table/utils/assign-provider-helper.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-templates/template-types/clinical-template-dropdown.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approve-and-prescribe-confirmation-details/dosage-change/dosage-change-component.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/SubscriptionDetails/components/components/components/VerifyShippingInformation.tsx",
      "bioverse-client/app/components/patient-portal/alternative-selection/weight-loss/cadence-selection/alt-cadence-selection.tsx",
      "bioverse-client/app/components/patient-portal/alternative-selection/weight-loss/option-selection/alt-option-selection.tsx",
      "bioverse-client/app/components/intake-v3/pages/select-supply-ap.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-supply-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-supply-v3-no-6.tsx",
      "bioverse-client/app/components/intake-v3/pages/select-supply-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-capsule-cadence-selection.tsx",
      "bioverse-client/app/components/intake-v3/pages/order-summary-v4.tsx",
      "bioverse-client/app/components/intake-v2/ed/confirmation/ed-confirmation.tsx",
      "bioverse-client/app/components/intake-v2/ed/ed-checkout/ed-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/pages/skincare-frequency.tsx",
      "bioverse-client/app/components/intake-v2/pages/select-supply.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-supply.tsx",
      "bioverse-client/app/api/revive/send-script/route.ts",
      "bioverse-client/app/api/hallandale/send-script/route.ts",
      "bioverse-client/app/api/supabase/payment-failure/route.ts",
      "bioverse-client/app/api/boothwyn/send-script/route.ts",
      "bioverse-client/app/api/dosespot/_event-type-cases/handlePrescriptionResult.ts",
      "bioverse-client/app/services/pharmacy-integration/util/utils.ts",
      "bioverse-client/app/services/pharmacy-integration/revive/revive-send-script-api.ts",
      "bioverse-client/app/services/pharmacy-integration/empower/provider-script-feedback.ts",
      "bioverse-client/app/services/pharmacy-integration/hallandale/hallandale-script-api.ts",
      "bioverse-client/app/services/pharmacy-integration/boothwyn/boothwyn-script-api.ts",
      "bioverse-client/app/services/pharmacy-integration/curexa/update-order.ts",
      "bioverse-client/app/services/pharmacy-integration/gogomeds/update-order.ts",
      "bioverse-client/app/services/pharmacy-integration/tmc/provider-script-feedback.ts",
      "bioverse-client/app/services/easypost/easypost-tracker.ts",
      "bioverse-client/_deprecated/clinical-intake-flow/order-table/utils/assign-provider-helper.ts",
      "bioverse-client/_deprecated/clinical-intake-flow/approval-buttons/ready-to-prescribe-button.tsx",
      "bioverse-client/app/services/pharmacy-integration/gogomeds/ggm-actions.ts",
      "bioverse-client/app/utils/database/controller/coordinator_activity_audit/coordinator_activity_audit-api.ts",
      "bioverse-client/app/utils/actions/coordinator/dashboard-scripts.ts",
      "bioverse-client/app/components/provider-portal/order-table/components/provider-dashboard-table.tsx",
      "bioverse-client/app/(administration)/admin/order-administration/_components/administrator-order-table.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/order-tab-row.tsx",
      "bioverse-client/app/api/empower/send-script/route.ts",
      "bioverse-client/app/services/pharmacy-integration/tmc/tmc-actions.ts",
      "bioverse-client/app/components/intake-v3/pages/wl-checkout-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-checkout-v3-ab.tsx",
      "bioverse-client/app/components/intake-v3/pages/new-checkout.tsx",
      "bioverse-client/app/components/intake-v2/ed/ed-checkout/ed-checkout-container.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-checkout.tsx",
      "bioverse-client/app/components/intake-v2/pages/checkout.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-checkout-apple-pay-test.tsx",
      "bioverse-client/app/components/intake-v2/pages/new-checkout.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-checkout-updated.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/custom-prescription-script/custom-prescription-script-utils.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/orders/orders-dbtype.d.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/controller/orders/process-manual-order.ts",
    "exports": [
      {
        "name": "processAndCreateManualOrder",
        "kind": "function",
        "signature": "export async function processAndCreateManualOrder(\n    orderInformation: ManualCreateOrderInformation,\n    profile_data: APProfileData,\n    product_href: PRODUCT_HREF,\n    variant_index: number,\n    cadence: SubscriptionCadency,\n    metadata: any,\n    needsProviderReview: boolean\n) {\n    const subscription = await getSubscriptionByProduct(\n        product_href,\n        profile_data.id\n    );\n\n    if (!subscription) {\n        throw new Error('Could not find subscription for user');\n    }\n\n    if (subscription.status !== 'active') {\n        throw new Error('Could not find active subscription for user');\n    }\n\n    const pvc = new ProductVariantController(\n        product_href as PRODUCT_HREF,\n        variant_index,\n        profile_data.state as USStates\n    );\n    const pvc_conversion = pvc.getConvertedVariantIndex();\n    const pharmacy = pvc_conversion.pharmacy;\n    const new_variant_index = pvc_conversion.variant_index!;\n\n    const new_price_id = await getPriceIdForProductVariant( \n        product_href,\n        new_variant_index,\n        process.env.NEXT_PUBLIC_ENVIRONMENT!\n    );\n\n    if (!new_price_id) {\n        throw new Error(\n            `Could not find new price id for ${product_href} ${new_variant_index}`\n        );\n    }\n\n    if (!pharmacy) {\n        throw new Error('Could not find pharmacy for product');\n    }\n\n    if (needsProviderReview) {\n        return await createManualOrderNeedsProviderReview(\n            orderInformation,\n            subscription,\n            profile_data,\n            product_href,\n            new_variant_index,\n            cadence,\n            pharmacy,\n            metadata,\n            new_price_id\n        );\n    } else {\n        return await createManualOrderDoesntNeedProviderReview(\n            orderInformation,\n            subscription,\n            profile_data,\n            product_href,\n            new_variant_index,\n            cadence,\n            pharmacy,\n            metadata,\n            new_price_id\n        );\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/orders/process-manual-order.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/ManualOrderCreationDialog.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/patient-status-tags/patient-status-tags-api.ts",
    "exports": [
      {
        "name": "createUserStatusTagWNote",
        "kind": "function",
        "signature": "export async function createUserStatusTagWNote(\n    status_tag: string,\n    order_id: string,\n    patient_id: string,\n    note: string,\n    author_id: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('patient_status_tags')\n        .insert({\n            patient_id,\n            order_id,\n            status_tag,\n            note,\n            last_modified_by: author_id,\n            environment: process.env.NEXT_PUBLIC_ENVIRONMENT!,\n        })\n        .select();\n\n    if (error) {\n        return { data: null, error: error };\n    }\n    return { data: data, error: error };\n}"
      },
      {
        "name": "createUserStatusTag",
        "kind": "function",
        "signature": "export async function createUserStatusTag(\n    status_tag: string,\n    order_id: string,\n    patient_id: string,\n    author_id: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('patient_status_tags')\n        .insert({\n            patient_id,\n            order_id,\n            status_tag,\n            last_modified_by: author_id,\n            environment: process.env.NEXT_PUBLIC_ENVIRONMENT!,\n        })\n        .select();\n\n    if (error) {\n        return { data: null, error: error };\n    }\n\n    return { data: data, error: error };\n}"
      },
      {
        "name": "setStatusTagMetadata",
        "kind": "function",
        "signature": "export async function setStatusTagMetadata(\n    tagId: number,\n    metadataField: string,\n    metadataValue: any\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('patient_status_tags')\n        .select('*')\n        .eq('id', tagId)\n        .single();\n\n    if (error || !data) {\n        console.error('error setting metatag status data', error);\n    }\n\n    const { data: updateData, error: updateError } = await supabase\n        .from('patient_status_tags')\n        .update({\n            metadata: { ...data.metadata, [metadataField]: metadataValue },\n        })\n        .eq('id', tagId);\n}"
      },
      {
        "name": "updateStatusTagToReview",
        "kind": "function",
        "signature": "export async function updateStatusTagToReview(\n    user_id: string,\n    order_id: string\n) {\n    await createUserStatusTagWAction(\n        StatusTag.Review,\n        order_id,\n        StatusTagAction.REPLACE,\n        user_id,\n        'Review order',\n        AUTO_STATUS_CHANGER_UUID,\n        [StatusTag.Review],\n        false\n    );\n}"
      },
      {
        "name": "createUserStatusTagWAction",
        "kind": "function",
        "signature": "export async function createUserStatusTagWAction(\n    status_tag: string,\n    order_id: string,\n    action: string,\n    patient_id: string,\n    note: string,\n    author_id: string,\n    status_tags: string[],\n    shouldConvertUserInput: boolean = false\n) {\n    const supabase = createSupabaseServiceClient();\n    var newStatusTag;\n    var new_status_tags;\n\n    if (\n        shouldConvertUserInput &&\n        [StatusTag.Review, StatusTag.Overdue].includes(\n            status_tag as StatusTag\n        ) &&\n        (await isRenewalOrder(order_id, 'any'))\n    ) {\n        const months = await getMonthsIntoRenewalOrderSubscription(order_id);\n\n        if (months === 0) {\n            newStatusTag = StatusTag.Review;\n            new_status_tags = [StatusTag.Review];\n        } else if (months === 1 || months === 2) {\n            newStatusTag =\n                status_tag === StatusTag.Review\n                    ? StatusTag.ReviewNoPrescribe\n                    : StatusTag.OverdueNoPrescribe;\n            new_status_tags = [newStatusTag];\n        } else if (months >= 3) {\n            newStatusTag = StatusTag.FinalReview;\n            new_status_tags = [StatusTag.FinalReview];\n        } else {\n            newStatusTag = StatusTag.Review;\n            new_status_tags = [StatusTag.Review];\n        }\n    } else {\n        newStatusTag = status_tag;\n        new_status_tags = status_tags;\n    }\n\n    if (status_tag === StatusTag.CustomerIOFollowUp) {\n        await triggerEvent(patient_id, MESSAGE_UNREAD);\n    }\n    if (status_tag === StatusTag.IDVerificationCustomerIOFollowUp) {\n        await triggerEvent(patient_id, ID_VERIFICATION_FOLLOWUP);\n    }\n\n    if (status_tag === StatusTag.IDDocs) {\n        await triggerEvent(patient_id, RudderstackEvent.NEW_MESSAGE);\n    }\n\n    const { data, error } = await supabase.from('patient_status_tags').insert({\n        patient_id,\n        order_id,\n        status_tag: newStatusTag,\n        action,\n        note,\n        last_modified_by: author_id,\n        status_tags: new_status_tags,\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT!,\n    });\n\n    if (error) {\n        console.log('createUserStatusTagWAction error: ', error);\n        return { data: null, error: error };\n    }\n    return { data: data, error: error };\n}"
      },
      {
        "name": "getUserStatusTags",
        "kind": "function",
        "signature": "export async function getUserStatusTags(\n    patient_id: string,\n    order_id: string\n): Promise<{ data: PatientStatusTagsSBR; error: any }> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('patient_status_tags')\n        .select('status_tag')\n        .eq('patient_id', patient_id)\n        .eq('order_id', order_id)\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .maybeSingle();\n\n    if (error || !data) {\n        return { data: {}, error: error };\n    }\n    return { data: data, error: error };\n}"
      },
      {
        "name": "getStatusTagForOrder",
        "kind": "function",
        "signature": "export async function getStatusTagForOrder(\n    order_id: string\n): Promise<{ data: PatientStatusTagsSBR; error: any }> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('patient_status_tags')\n        .select('status_tags')\n        .eq('order_id', order_id)\n        .order('created_at', { ascending: false })\n        .limit(1);\n\n    if (error) {\n        return { data: {}, error: error };\n    }\n    return { data: data[0], error: error };\n}"
      },
      {
        "name": "getUserStatusTag",
        "kind": "function",
        "signature": "export async function getUserStatusTag(\n    patient_id: string,\n    order_id: string\n): Promise<{ data: PatientStatusTagsSBR; error: any }> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('patient_status_tags')\n        .select('status_tag')\n        .eq('patient_id', patient_id)\n        .eq('order_id', order_id)\n        .order('created_at', { ascending: false })\n        .limit(1);\n\n    if (error) {\n        console.log('stag - error', error);\n        return { data: {}, error: error };\n    }\n    return { data: data[0], error: error };\n}"
      },
      {
        "name": "getUserStatusTagsWithNotes",
        "kind": "function",
        "signature": "export async function getUserStatusTagsWithNotes(\n    patient_id: string,\n    order_id: string\n): Promise<{ data: PatientStatusTagsWithNotesSBR; error: any }> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('patient_status_tags')\n        .select(\n            `id, status_tags, note, last_modified_by, created_at, \n            author:profiles!last_modified_by (\n                first_name,\n                last_name\n            )`\n        )\n        .eq('patient_id', patient_id)\n        .eq('order_id', order_id)\n        .order('created_at', { ascending: false })\n        .limit(1);\n\n    if (error) {\n        return { data: {} as PatientStatusTagsWithNotesSBR, error: error };\n    }\n    return { data: data[0] as PatientStatusTagsWithNotesSBR, error: error };\n}"
      },
      {
        "name": "getUserStatusTagNotes",
        "kind": "function",
        "signature": "export async function getUserStatusTagNotes(\n    patient_id: string\n): Promise<{ data: PatientStatusTagsSBR[]; error: any }> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc('get_user_status_tag_notesv2', {\n        patient_id_: patient_id,\n    });\n    if (error) {\n        return { data: [], error: error };\n    }\n\n    return { data: data, error: error };\n}"
      },
      {
        "name": "getEngineerStatusTagOrders",
        "kind": "function",
        "signature": "export async function getEngineerStatusTagOrders(): Promise<{\n    data: PatientOrderEngineerDetails[];\n    error: any;\n}> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_engineer_tag_orders_v2',\n        {}\n    );\n\n    if (error) {\n        return { data: [], error: error };\n    }\n    return { data: data, error: error };\n}"
      },
      {
        "name": "assignEngineerToStatusTag",
        "kind": "function",
        "signature": "export async function assignEngineerToStatusTag(\n    tagId: number,\n    assigned_uuid: string\n): Promise<{ result: Status }> {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('patient_status_tags')\n        .update({\n            metadata: {\n                assigned_engineer: assigned_uuid,\n            },\n        })\n        .eq('id', tagId);\n\n    if (error) {\n        console.error('assignEngineerToStatusTag : ', error);\n        return { result: Status.Error };\n    }\n\n    return { result: Status.Success };\n}"
      },
      {
        "name": "getAllOrdersForStatusTags",
        "kind": "function",
        "signature": "export async function getAllOrdersForStatusTags(\n    status_tags: StatusTag[]\n): Promise<PatientStatusTagsSBR[]> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_all_orders_for_status_tags',\n        { lookup_status_tags: status_tags }\n    );\n\n    if (error) {\n        console.error('Error getting all orders for status tags', status_tags);\n        return [];\n    }\n\n    if (!data || isEmpty(data)) {\n        return [];\n    }\n\n    return data;\n}"
      },
      {
        "name": "getAllOrdersForStatusTagsDaily",
        "kind": "function",
        "signature": "export async function getAllOrdersForStatusTagsDaily(\n    status_tags: StatusTag[]\n): Promise<PatientStatusTagsSBR[]> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_all_orders_for_status_tags_daily',\n        { lookup_status_tags: status_tags }\n    );\n\n    if (error) {\n        console.error('Error getting all orders for status tags', status_tags);\n        return [];\n    }\n\n    if (!data || isEmpty(data)) {\n        return [];\n    }\n\n    return data;\n}"
      },
      {
        "name": "getStatusTags",
        "kind": "function",
        "signature": "export async function getStatusTags(\n    limit: number,\n    status_tag: string,\n    licensed_state_array: string[] | null,\n    environment_override?: string\n) {\n    //get_latest_status_tags\n\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc('get_latest_status_tags', {\n        limit_value: limit,\n        status_tag_param: status_tag,\n        status_tag_environment: environment_override\n            ? environment_override\n            : process.env.NEXT_PUBLIC_ENVIRONMENT!,\n        licensed_states_for_provider: licensed_state_array,\n    });\n\n    if (error) {\n        console.error(\n            'getStatusTags error - data = limit: ',\n            limit,\n            ' status tag: ',\n            status_tag,\n            ' error message: ',\n            error.message\n        );\n        return { data: null, status: Status.Error };\n    }\n\n    return { data: data as StatusTagObject[], status: Status.Success };\n}"
      },
      {
        "name": "getStatusTagsInArray",
        "kind": "function",
        "signature": "export async function getStatusTagsInArray(\n    limit: number,\n    status_tags: StatusTag[],\n    licensed_state_array: string[] | null,\n    environment_override?: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_latest_status_tags_in_array',\n        {\n            limit_value: limit,\n            status_tag_params: status_tags,\n            licensed_states_for_provider: licensed_state_array,\n            status_tag_environment: environment_override\n                ? environment_override\n                : process.env.NEXT_PUBLIC_ENVIRONMENT!,\n        }\n    );\n\n    if (error) {\n        console.error('getStatusTagsInArray error: ', error);\n        return { data: null, status: Status.Error };\n    }\n\n    return { data: data as StatusTagObject, status: Status.Success };\n}"
      },
      {
        "name": "getCoordinatorTaskByStatusTagArray",
        "kind": "function",
        "signature": "export async function getCoordinatorTaskByStatusTagArray(\n    status_tags: StatusTag[],\n    licensed_state_array: string[] | null,\n    employee_id: string,\n    environment_override: boolean\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_coordinator_task_by_status_tag_array',\n        {\n            status_tag_params: status_tags,\n            licensed_states_for_provider: licensed_state_array ?? null,\n            status_tag_environment: environment_override\n                ? 'dev'\n                : process.env.NEXT_PUBLIC_ENVIRONMENT!,\n            employee_id: employee_id,\n        }\n    );\n\n    if (error) {\n        console.error('getCoordinatorTaskByStatusTagArray error: ', error);\n        return { data: null, status: Status.Error };\n    }\n    return { data: data as StatusTagObject, status: Status.Success };\n}"
      },
      {
        "name": "getRegisteredNurseStatusTags",
        "kind": "function",
        "signature": "export async function getRegisteredNurseStatusTags(\n    limit: number,\n    licensed_state_array: string[]\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_registered_nurse_status_tags',\n        {\n            limit_value: limit,\n            status_tag_environment: process.env.NEXT_PUBLIC_ENVIRONMENT!,\n            licensed_states_for_provider: licensed_state_array,\n        }\n    );\n\n    if (error) {\n        console.error(\n            'getRegisteredNurseStatusTags error - data = limit: ',\n            limit,\n            ' error message: ',\n            error.message\n        );\n        return { data: null, status: Status.Error };\n    }\n\n    return { data: data as StatusTagObject[], status: Status.Success };\n}"
      },
      {
        "name": "getStatusTagTaskCount",
        "kind": "function",
        "signature": "export async function getStatusTagTaskCount(status_tag: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc('count_latest_status_tags', {\n        status_tag_param: status_tag,\n        status_tag_environment: process.env.NEXT_PUBLIC_ENVIRONMENT!,\n    });\n\n    if (error) {\n        console.error(\n            'getStatusTags error - data: ',\n            ' status tag: ',\n            status_tag,\n            ' error message: ',\n            error.message\n        );\n        return { data: null, status: Status.Error };\n    }\n\n    return { data: data, status: Status.Success };\n}"
      },
      {
        "name": "getStatusTagArrayTaskCount",
        "kind": "function",
        "signature": "export async function getStatusTagArrayTaskCount(status_tags: StatusTag[]) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_latest_status_tag_array_count',\n        {\n            status_tag_param: status_tags,\n            status_tag_environment: process.env.NEXT_PUBLIC_ENVIRONMENT!,\n        }\n    );\n\n    if (error) {\n        console.error('getStatusTagArrayTaskCount error: ', error);\n    }\n\n    return data;\n}"
      },
      {
        "name": "forwardOrderToEngineering",
        "kind": "function",
        "signature": "export async function forwardOrderToEngineering(\n    order_id: string,\n    user_id: string | null = null,\n    note: string = StatusTagNotes.Engineer\n) {\n    let user_id_to_use = user_id;\n\n    if (!user_id) {\n        const orderIdParts = order_id.split('-');\n        const cleanOrderId = orderIdParts[0];\n\n        const { data: orderData, error: orderError } = await getOrderById(\n            cleanOrderId\n        );\n\n        if (orderError) {\n            console.error('forwardOrderToEngineering error: ', orderError);\n        }\n\n        user_id_to_use = orderData.customer_uid;\n    }\n\n    await createUserStatusTagWAction(\n        StatusTag.Engineer,\n        order_id,\n        StatusTagAction.REPLACE,\n        user_id_to_use ?? 'ffabc905-5508-4d54-98fb-1e2ef2b9e99a',\n        note,\n        'ffabc905-5508-4d54-98fb-1e2ef2b9e99a',\n        [StatusTag.Engineer]\n    );\n}"
      },
      {
        "name": "updateStatusTagToResolved",
        "kind": "function",
        "signature": "export async function updateStatusTagToResolved(\n    order_id: string,\n    user_id: string,\n    note: string = StatusTagNotes.AutomaticResolved\n) {\n    await createUserStatusTagWAction(\n        StatusTag.Resolved,\n        order_id,\n        StatusTagAction.REPLACE,\n        user_id ?? AUTO_STATUS_CHANGER_UUID,\n        note,\n        AUTO_STATUS_CHANGER_UUID,\n        [StatusTag.Resolved]\n    );\n}"
      },
      {
        "name": "updateStatusTagAssignedProvider",
        "kind": "function",
        "signature": "export async function updateStatusTagAssignedProvider(\n    providerId: string,\n    status_tag_id: number\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('patient_status_tags')\n        .update({ assigned_provider: providerId })\n        .eq('id', status_tag_id);\n\n    if (error) {\n        console.log(\n            'updateStatusTagAssignedProvider: provider ID: ',\n            providerId,\n            ' status tag id: ',\n            status_tag_id,\n            ' error message: ',\n            error.message\n        );\n        return { status: Status.Error };\n    }\n\n    return { status: Status.Success };\n}"
      },
      {
        "name": "updateUserOrderStatusTags",
        "kind": "function",
        "signature": "export async function updateUserOrderStatusTags(\n    patient_id: string,\n    conditions: string[],\n    status_tag: string,\n    note: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    try {\n        const { data, error } = await supabase.rpc(\n            'update_user_status_tag_to_new_tag',\n            {\n                patient_id_: patient_id,\n                status_tags_conditions: conditions,\n                status_tag_: status_tag,\n                note_: note,\n            }\n        );\n\n        if (error) {\n            console.error('updateUserOrderStatusTags error: ', error);\n        }\n\n        return data;\n    } catch (error) {\n        console.log('stag - error', error);\n        console.error(error);\n    }\n}"
      },
      {
        "name": "getStatusTagAssignmentCount",
        "kind": "function",
        "signature": "export async function getStatusTagAssignmentCount(\n    status_tag: StatusTag,\n    start_date: Date,\n    end_date: Date\n) {\n    const supabase = createSupabaseServiceClient();\n\n    try {\n        const { data, error } = await supabase.rpc(\n            'get_status_tag_assignment_count',\n            {\n                environment_: process.env.NEXT_PUBLIC_ENVIRONMENT,\n                status_tag_: status_tag,\n                start_date_: start_date,\n                end_date_: end_date,\n            }\n        );\n\n        if (error) {\n            console.error('getStatusTagAssignmentCount error: ', error);\n        }\n\n        return data;\n    } catch (error) {\n        console.log('stag - error', error);\n        console.error(error);\n    }\n}"
      },
      {
        "name": "getStatusTagArrayAssignmentCount",
        "kind": "function",
        "signature": "export async function getStatusTagArrayAssignmentCount(\n    status_tags: StatusTag[],\n    start_date: Date,\n    end_date: Date\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_status_tag_array_assignment_count',\n        {\n            environment_: process.env.NEXT_PUBLIC_ENVIRONMENT,\n            status_tags_: status_tags,\n            start_date_: start_date,\n            end_date_: end_date,\n        }\n    );\n\n    if (error) {\n        console.error('getStatusTagArrayAssignmentCount error: ', error);\n    }\n\n    return data;\n}"
      },
      {
        "name": "getNewIntakeCountFromDateRange",
        "kind": "function",
        "signature": "export async function getNewIntakeCountFromDateRange(\n    start_date: Date,\n    end_date: Date\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_new_intake_count_from_range',\n        {\n            start_date: start_date,\n            end_date: end_date,\n            status_tags_: ['Review'],\n        }\n    );\n\n    if (error) {\n        console.error('getNewIntakeCountFromDateRange error ', error);\n    }\n\n    return data;\n}"
      },
      {
        "name": "getNewIntakeCountWithIDDocsFromDateRange",
        "kind": "function",
        "signature": "export async function getNewIntakeCountWithIDDocsFromDateRange(\n    start_date: Date,\n    end_date: Date\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_new_intakes_with_id_docs_from_range',\n        {\n            start_date: start_date,\n            end_date: end_date,\n        }\n    );\n\n    if (error) {\n        console.error('getNewIntakeCountWithIDDocsFromDateRange error ', error);\n    }\n\n    return data;\n}"
      },
      {
        "name": "getNewRenewalCountFromDateRange",
        "kind": "function",
        "signature": "export async function getNewRenewalCountFromDateRange(\n    start_date: Date,\n    end_date: Date\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_new_renewal_count_from_range',\n        {\n            start_date: start_date,\n            end_date: end_date,\n            status_tags_: [\n                'Review',\n                'FinalReview',\n                'ReviewNoPrescribe',\n                'OverdueNoPrescribe',\n            ],\n        }\n    );\n\n    if (error) {\n        console.error('getNewRenewalCountFromDateRange error ', error);\n    }\n\n    return data;\n}"
      },
      {
        "name": "getNewMessageCountFromDateRange",
        "kind": "function",
        "signature": "export async function getNewMessageCountFromDateRange(\n    start_date: Date,\n    end_date: Date\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_new_message_count_from_range',\n        {\n            start_date: start_date,\n            end_date: end_date,\n            status_tags_: ['ProviderMessage'],\n        }\n    );\n\n    if (error) {\n        console.error('getNewRenewalCountFromDateRange error ', error);\n    }\n\n    return data;\n}"
      },
      {
        "name": "getIDDocsTaggedNewIntakesCountFromDateRange",
        "kind": "function",
        "signature": "export async function getIDDocsTaggedNewIntakesCountFromDateRange(\n    start_date: Date,\n    end_date: Date\n) {\n    const supabase = createSupabaseServiceClient();\n    const { data, error } = await supabase.rpc(\n        'get_new_intakes_without_id_docs_from_range',\n        {\n            start_date: start_date,\n            end_date: end_date,\n        }\n    );\n\n    if (error) {\n        console.error('getNewRenewalCountFromDateRange error ', error);\n    }\n\n    return data;\n}"
      },
      {
        "name": "getAverageStatusTagRemovalTime",
        "kind": "function",
        "signature": "export async function getAverageStatusTagRemovalTime(\n    start_date: Date,\n    end_date: Date,\n    status_tags: StatusTag[],\n    orderType?: OrderType\n) {\n    let intake_renewal_type;\n    switch (orderType) {\n        case OrderType.Order:\n            intake_renewal_type = 'intake';\n            break;\n        case OrderType.RenewalOrder:\n            intake_renewal_type = 'renewal';\n            break;\n        default:\n            intake_renewal_type = 'both';\n    }\n\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_average_status_tag_removal_time',\n        {\n            start_date: start_date,\n            end_date: end_date,\n            search_status_tags_: status_tags,\n            intake_renewal_type_: intake_renewal_type,\n        }\n    );\n\n    if (error) {\n        console.error('getNewRenewalCountFromDateRange error ', error);\n    }\n\n    return data;\n}"
      },
      {
        "name": "getIntakeWithIDCount",
        "kind": "function",
        "signature": "export async function getIntakeWithIDCount(startDate: Date, endDate: Date) {\n    const supabase = createSupabaseServiceClient();\n\n    const startOfDay = new Date(startDate);\n    startOfDay.setHours(0, 0, 0, 0);\n\n    const endOfDay = new Date(endDate);\n    endOfDay.setHours(23, 59, 59, 999);\n\n    const { count: withoutIDCount, error: noIDError } = await supabase\n        .from('patient_status_tags')\n        .select('*', { count: 'exact', head: true })\n        .gte('created_at', startOfDay.toISOString())\n        .lte('created_at', endOfDay.toISOString())\n        .eq('note', 'Patient submitted an order without verifying their id')\n        .eq('status_tag', 'ID/Docs')\n        .eq('environment', 'prod');\n\n    const { count: withIDIntakeCount, error } = await supabase\n        .from('patient_status_tags')\n        .select('*', { count: 'exact', head: true })\n        .gte('created_at', startOfDay.toISOString())\n        .lte('created_at', endOfDay.toISOString())\n        .eq('note', 'New Order to review')\n        .eq('status_tag', 'Review')\n        .eq('environment', 'prod');\n\n    return { with_ID_count: withIDIntakeCount, no_ID_count: withoutIDCount };\n}"
      },
      {
        "name": "getNextCoordinatorOrderForTaskQueue",
        "kind": "function",
        "signature": "export async function getNextCoordinatorOrderForTaskQueue() {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_next_coordinator_task_queue_item',\n        {\n            target_environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n        }\n    );\n\n    if (error) return { error: error, data: null };\n    return { data: data[0] as TaskOrderObject, error: null };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/patient-status-tags/patient-status-tags-api.ts",
      "bioverse-client/app/utils/functions/jobs/JobsFactory.ts",
      "bioverse-client/app/components/intake-v3/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/new-checkout-component.tsx",
      "bioverse-client/app/(testing_and_development)/ben-dev/page.tsx",
      "bioverse-client/app/(testing_and_development)/olivier-dev/utils.ts",
      "bioverse-client/app/(administration)/admin/stripe-api/stripe-api-actions.ts",
      "bioverse-client/app/utils/classes/Scripts/BaseScriptHandler.ts",
      "bioverse-client/app/utils/actions/alternatives/weight-loss/alternative-weight-loss-actions.ts",
      "bioverse-client/app/utils/actions/check-up/check-up-actions.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/IDAndSelfieCheckJobHandler.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/StripeInvoicePaidJobHandler.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/containers/components/EngineerModal.tsx",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/containers/components/ReviewModal.tsx",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/containers/coordinator-main-view-container.tsx",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/confirm-prescription-dialog.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/order-charts/components/StatusDropdown.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/empower/empower-window-v2.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/tmc/tmc-window.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approval-buttons.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/decline-dialog.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/quarterly-final-review-dialog.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approve-script-dialog.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/patient-information/approval-buttons/review-approval-buttons.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component-ab.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/ed/ed-checkout/ed-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/components/wl-checkout-component-fulltest.tsx",
      "bioverse-client/app/components/intake-v2/checkout/checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/api/customerio/webhook/route.ts",
      "bioverse-client/app/components/engineer-portal/components/dashboard/special-case-dropdown.tsx",
      "bioverse-client/app/components/engineer-portal/components/dashboard-table-item/eng-dashboard-table-record.tsx",
      "bioverse-client/app/utils/database/controller/job-scheduler/job-scheduler-actions.ts",
      "bioverse-client/app/utils/database/controller/orders/create-order.ts",
      "bioverse-client/app/utils/database/controller/orders/process-manual-order.ts",
      "bioverse-client/app/api/stripe/webhook/invoice-paid/route.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/containers/components/coordinator-task-action-info-bar.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/top-information-display/internal-note-alert.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/utils/intake-helpers.ts",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/utils/coordinator-task-data-fetch.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/internal-notes/internal-notes-tab.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/internal-notes-content.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/utils/data-fetch/intake-view-datafetch.ts",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/patient-information/internal-notes-accordion/internal-notes-accordion.tsx",
      "bioverse-client/app/utils/actions/engineer/dashboard-scripts.ts",
      "bioverse-client/app/components/engineer-portal/components/dashboard/assignment-dropdown.tsx",
      "bioverse-client/app/utils/actions/provider/dashboard-scripts.ts",
      "bioverse-client/app/api/provider-portal/tasks/route.ts",
      "bioverse-client/app/api/coordinator-portal/tasks/route.ts",
      "bioverse-client/app/components/admin/task-overview/task-overview-container.tsx",
      "bioverse-client/app/components/provider-portal/tasks/task-action-page/utils/task-action-data-fetch.ts",
      "bioverse-client/app/components/provider-portal/tasks/task-counter-view/functions/getAllTaskCount.ts",
      "bioverse-client/app/components/provider-portal/provider-tracking-window/components/tracking-window.tsx",
      "bioverse-client/app/components/coordinator-portal/tasks/task-action-page/utils/task-action-data-fetch.ts",
      "bioverse-client/app/utils/database/controller/renewal_orders/renewal_orders.ts",
      "bioverse-client/app/utils/database/controller/pharmacy_order_audit/pharmacy_order_audit.tsx",
      "bioverse-client/app/utils/classes/Pharmacy.ts",
      "bioverse-client/app/utils/classes/CommsScheduler/CommsSchedule.ts",
      "bioverse-client/app/utils/classes/Scripts/BoothwynScriptHandler.ts",
      "bioverse-client/app/utils/classes/Scripts/EmpowerScriptHandler.ts",
      "bioverse-client/app/utils/classes/Scripts/ReviveScriptHandler.ts",
      "bioverse-client/app/utils/classes/Scripts/HallandaleScriptHandler.ts",
      "bioverse-client/app/utils/actions/intake/order-util.ts",
      "bioverse-client/app/components/patient-portal/check-up-requested/almost-done/almost-done-screen-v2.tsx",
      "bioverse-client/app/components/patient-portal/check-up-requested/almost-done/almost-done-screen.tsx",
      "bioverse-client/app/api/renewal/autoship/route.ts",
      "bioverse-client/app/api/hallandale/send-script/route.ts",
      "bioverse-client/app/api/supabase/split-shipment-glp1/route.ts",
      "bioverse-client/app/api/easypost/route.tsx",
      "bioverse-client/app/api/stripe/subscription/create/route.ts",
      "bioverse-client/app/api/stripe/payment-intent/create/route.ts",
      "bioverse-client/app/(patient-portal)/dosage-selection/[product]/page.tsx",
      "bioverse-client/app/services/pharmacy-integration/util/utils.ts",
      "bioverse-client/app/services/pharmacy-integration/revive/revive-send-script-api.ts",
      "bioverse-client/app/services/pharmacy-integration/revive/revive-patient-api.ts",
      "bioverse-client/app/services/pharmacy-integration/hallandale/hallandale-script-api.ts",
      "bioverse-client/app/services/pharmacy-integration/boothwyn/boothwyn-script-api.ts",
      "bioverse-client/app/services/stripe/subscriptions.ts",
      "bioverse-client/app/services/stripe/paymentIntent.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approve-and-prescribe-confirmation-details/dosage-change/dosage-change-component.tsx",
      "bioverse-client/app/components/provider-portal/order-table/components/provider-dashboard-table.tsx",
      "bioverse-client/app/services/customerio/customerioApiFactory.ts",
      "bioverse-client/app/components/admin/application-control/intake-id-docs-counter.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/patient-status-tags/patient-status-tags.d.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/controller/patient_action_history/patient-action-history-types.ts",
    "exports": [
      {
        "name": "PatientHistoryTaskName",
        "kind": "variable",
        "signature": "PatientHistoryTaskName: Record<PatientActionTask, string> = {\n    [PatientActionTask.INTAKE_SUBMITTED]: 'PRESCRIPTION REQUESTED',\n    [PatientActionTask.CHECKIN_FORM_SUBMITTED]: 'CHECK-IN FORM SUBMITTED',\n    [PatientActionTask.DOSAGE_SELECTION_REQUESTED]:\n        'DOSAGE SELECTION REQUESTED',\n    [PatientActionTask.SHIPPING_ADDRESS_UPDATED]: 'SHIPPING ADDRESS UPDATED',\n    [PatientActionTask.PERSONAL_INFORMATION_UPDATED]:\n        'PERSONAL INFORMATION UPDATED',\n    [PatientActionTask.REFILL_DATE_CHANGED]: 'REFILL DATE CHANGED',\n    [PatientActionTask.SUBSCRIPTION_CANCELED_REQUESTED]:\n        'SUBSCRIPTION CANCELED REQUESTED',\n    [PatientActionTask.SENT_MESSAGE]: 'SENT MESSAGE',\n    [PatientActionTask.CARD_UPDATED]: 'CREDIT CARD UPDATED',\n    [PatientActionTask.SUBSCRIPTION_RESUMED]: 'SUBSCRIPTION RESUMED',\n    [PatientActionTask.PAYMENT_FAILED]: 'PAYMENT FAILED',\n    [PatientActionTask.CHECKIN_FORM_SENT]: 'CHECK-IN FORM SENT',\n    [PatientActionTask.REFUNDED_SUBSCRIPTION]:\n        'REFUNDED PAYMENT FOR SUBSCRIPTION',\n    [PatientActionTask.ORDER_VOIDED]: 'ORDER VOIDED',\n    [PatientActionTask.PAYMENT_SUCCESS]: 'PAYMENT SUCCESS',\n    [PatientActionTask.MANUAL_ORDER_CREATED]: 'MANUAL ORDER CREATED',\n    [PatientActionTask.INTAKE_APPROVED]: 'INTAKE APPROVED',\n    [PatientActionTask.FIRST_TIME_DOSAGE_SELECTION_REQUESTED]:\n        'FIRST TIME DOSAGE SELECTION',\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/patient_action_history/patient-action-history-types.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/patient-history-logs/patient-history-logs.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/patient_action_history/patient-action-history.ts",
    "exports": [
      {
        "name": "logPatientAction",
        "kind": "function",
        "signature": "export async function logPatientAction(\n    patient_id: string,\n    task_name: PatientActionTask,\n    notes: any,\n) {\n    const supabase = createSupabaseServiceClient();\n    await supabase\n        .from('patient_action_history')\n        .insert({ patient_id, task_name, notes });\n}"
      },
      {
        "name": "fetchHistoryLogsForPatient",
        "kind": "function",
        "signature": "export async function fetchHistoryLogsForPatient(\n    patient_id: string,\n): Promise<PatientActionHistory[]> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('patient_action_history')\n        .select('*')\n        .eq('patient_id', patient_id)\n        .order('created_at', { ascending: true });\n\n    if (error) {\n        console.error(error);\n        return [];\n    }\n\n    if (!data) {\n        return [];\n    }\n\n    return data as PatientActionHistory[];\n}"
      },
      {
        "name": "fetchPaymentFailureLogsForOrder",
        "kind": "function",
        "signature": "export async function fetchPaymentFailureLogsForOrder(\n    order_id: string,\n): Promise<PatientActionHistory[]> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('patient_action_history')\n        .select('*')\n        .eq('task_name', PatientActionTask.PAYMENT_FAILED)\n        .eq('notes ->> order_id', order_id)\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error(error);\n        return [];\n    }\n\n    if (!data) {\n        return [];\n    }\n\n    return data as PatientActionHistory[];\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(testing_and_development)/ben-dev/page.tsx",
      "bioverse-client/app/(administration)/admin/stripe-api/stripe-api-actions.ts",
      "bioverse-client/app/utils/database/controller/payment_failure_audit/payment_failure_audit-api.ts",
      "bioverse-client/app/utils/database/controller/patient_action_history/patient-action-history.ts",
      "bioverse-client/app/utils/database/controller/messaging/messages/messages.ts",
      "bioverse-client/app/utils/actions/intake/order-util.ts",
      "bioverse-client/app/utils/actions/check-up/check-up-actions.ts",
      "bioverse-client/app/utils/actions/stripe/stripe-webhook-actions.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/subscriptions/components/subscription-accordion.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/RenewalOrderTabRow.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/ManualOrderCreationDialog.tsx",
      "bioverse-client/app/components/patient-portal/account-information/personal-information/account-edit-drawer.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/ChangeRefillDate/confirm/ConfirmRefillData.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/CancelSubscription/feedback/CancelFeedbackQuestion.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/SubscriptionDetails/components/ChangePaymentMethodDrawer.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/SubscriptionDetails/components/components/components/VerifyShippingInformation.tsx",
      "bioverse-client/app/components/patient-portal/dosage-selection-first-time/components/FirstTimeAlmostDone.tsx",
      "bioverse-client/app/components/intake-v3/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component-ab.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/ed/ed-checkout/ed-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/api/customerio/webhook/route.ts",
      "bioverse-client/app/api/stripe/webhook/invoice-paid/route.ts",
      "bioverse-client/app/services/pharmacy-integration/util/utils.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/patient-history-logs/patient-history-logs.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/info/payment-failure-dialog.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/patient_combined_wl_answers_temp/patient_combined_wl_answers_temp_api.ts",
    "exports": [
      {
        "name": "insertNewWlAnswer",
        "kind": "function",
        "signature": "export async function insertNewWlAnswer(patient_id: string, wl_answers: any) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('patient_combined_wl_answers_temp')\n        .upsert([{ patient_id: patient_id, answers: wl_answers }], {\n            onConflict: 'patient_id',\n        });\n\n    if (error) {\n        console.error('WL ANSWER RECORDING ERROR', error);\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/patient_combined_wl_answers_temp/patient_combined_wl_answers_temp_api.ts",
      "bioverse-client/app/components/intake-v2/pages/combined-wl-demographic.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/patient_document_uploads/patient_document_uploads.ts",
    "exports": [
      {
        "name": "uploadPatientDocumentDB",
        "kind": "function",
        "signature": "export async function uploadPatientDocumentDB(\n    patient_id: string,\n    document_type: string,\n    file_url: string\n) {\n    const supabase = createSupabaseServerComponentClient();\n\n    try {\n        const { data, error } = await supabase\n            .from('patient_document_uploads')\n            .upsert(\n                { patient_id, document_type, file_url },\n                { onConflict: 'patient_id, document_type' }\n            );\n\n        if (error) {\n            console.error('Error updating patient document on DB:', error);\n            throw error;\n        }\n    } catch (error: any) {\n        console.error('Error in uploading document:', error);\n    }\n}"
      },
      {
        "name": "getDocumentUploads",
        "kind": "function",
        "signature": "export async function getDocumentUploads(\n    patient_id: string\n): Promise<DocumentUpload[] | null> {\n    const supabase = createSupabaseServerComponentClient();\n\n    // Perform the update\n    const { data, error } = await supabase\n        .from('patient_document_uploads')\n        .select('*')\n        .eq('patient_id', patient_id);\n\n    if (error) {\n        console.error('Error getting patient documents on DB:', error);\n\n        return null;\n    }\n\n    return data;\n}"
      },
      {
        "name": "getDocumentURL",
        "kind": "function",
        "signature": "export async function getDocumentURL(filePath: string) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { data: urlData, error } = await supabase.storage\n        .from('document_uploads')\n        .createSignedUrl(filePath, 60 * 60);\n\n    if (error) {\n        console.log('getDocumentUrl', error);\n        return { data: null, error: error };\n    } else return { data: urlData, error: error };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/patient_document_uploads/patient_document_uploads.ts",
      "bioverse-client/app/components/patient-portal/patient-portal-client/patient-upload-document.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/documents/documents-content.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/documents-content.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/patient_providers/patient-providers.ts",
    "exports": [
      {
        "name": "addProviderToPatientRelationship",
        "kind": "function",
        "signature": "export async function addProviderToPatientRelationship(\n    patientId: string,\n    providerId: string,\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { data: current, error: currentError } = await supabase\n        .from('patient_providers')\n        .select('provider_ids')\n        .eq('patient_id', patientId)\n        .maybeSingle();\n\n    if (currentError) {\n        console.log(\n            'Controller Error. tablename: patient_providers, method: addProviderToPatientRelationship, error: ',\n            currentError,\n        );\n        return;\n    }\n\n    if (!current) {\n        const { error: insertError } = await supabase\n            .from('patient_providers')\n            .insert({\n                patient_id: patientId,\n                provider_ids: [\n                    'e756658d-785d-46d5-85ab-22bf11256a59',\n                    providerId,\n                ],\n            });\n        if (insertError) {\n            console.log(\n                'Controller Error. tablename: patient_providers, method: addProviderToPatientRelationship, error: ',\n                insertError,\n            );\n        }\n        return;\n    }\n\n    if (!current.provider_ids.includes(providerId)) {\n        const updatedProviderIds = [...current.provider_ids, providerId];\n        const { error: updateError } = await supabase\n            .from('patient_providers')\n            .update({ provider_ids: updatedProviderIds })\n            .eq('patient_id', patientId);\n\n        if (updateError) {\n            console.log(\n                'Controller Error. tablename: patient_providers, method: addProviderToPatientRelationship, error: ',\n                updateError,\n            );\n        }\n    }\n}"
      },
      {
        "name": "addCustomerSupportToPatientOnSignup",
        "kind": "function",
        "signature": "export async function addCustomerSupportToPatientOnSignup(patient_id: string) {\n    if (!patient_id) {\n        console.error('Failed to add CS to patient_providers');\n        return;\n    }\n\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase.from('patient_providers').insert([\n        {\n            patient_id,\n            provider_ids: [process.env.NEXT_PUBLIC_CUSTOMER_SUPPORT_USER_ID],\n        },\n    ]);\n\n    if (error) {\n        console.error('Failed to add CS to patient_providers');\n        console.error(error, error.message);\n    }\n    return;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/patient_providers/patient-providers.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/intake-response-column/approval-buttons.tsx",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/confirm-prescription-dialog.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approval-buttons.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/decline-dialog.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approve-script-dialog.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/patient-information/approval-buttons/review-approval-buttons.tsx",
      "bioverse-client/app/components/intake-v3/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component-ab.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/ed/ed-checkout/ed-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/components/wl-checkout-component-fulltest.tsx",
      "bioverse-client/app/components/intake-v2/checkout/checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/wl-checkout-component.tsx",
      "bioverse-client/_deprecated/clinical-intake-flow/approval-buttons/provider-approval-buttons.tsx",
      "bioverse-client/app/auth/callback/route.ts",
      "bioverse-client/app/components/intake-v3/registration/intake-signup-form/intake-signup-form-v3.tsx",
      "bioverse-client/app/components/intake-v3/wl-graph/wl-login-verification-screen.tsx",
      "bioverse-client/app/components/intake-v3/wl-graph/wl-registration-pre-graph-dialog.tsx",
      "bioverse-client/app/components/intake-v2/registration/intake-signup-form/intake-signup-form.tsx",
      "bioverse-client/app/components/login/forms/v2/sign-up-form-v2.tsx",
      "bioverse-client/app/components/login/forms/signUpForm.tsx",
      "bioverse-client/app/components/login/login-drawer/drawer-specific-forms/sign-up-form-drawer.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/patient_weight_audit/patient-weight-audit-api.ts",
    "exports": [
      {
        "name": "createPatientWeightAudit",
        "kind": "function",
        "signature": "export async function createPatientWeightAudit(\n    audit_data: PatientWeightAuditCreate\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('patient_weight_audit')\n        .insert(audit_data);\n\n    if (error) {\n        console.error('createPatientWeightAudit', audit_data, error);\n    }\n\n    return;\n}"
      },
      {
        "name": "createCurrentPatientWeightAudit",
        "kind": "function",
        "signature": "export async function createCurrentPatientWeightAudit(\n    weight: number,\n    source: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const user_id = (await readUserSession()).data.session?.user.id;\n\n    const { error } = await supabase.from('patient_weight_audit').insert({\n        patient_id: user_id,\n        weight: weight,\n        source: source,\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT!,\n    });\n\n    if (error) {\n        console.error(\n            'createPatientWeightAudit',\n            'user_id: ',\n            user_id,\n            'weight: ',\n            weight,\n            'source: ',\n            source,\n            'error: ',\n            error\n        );\n    }\n\n    return;\n}"
      },
      {
        "name": "getWeightAuditsForPatient",
        "kind": "function",
        "signature": "export async function getWeightAuditsForPatient(\n    patient_id: string\n): Promise<PatientWeightAuditSBR[] | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('patient_weight_audit')\n        .select('*')\n        .eq('patient_id', patient_id);\n\n    if (error) {\n        console.error('getWeightAuditsForPatient', patient_id, error);\n        return null;\n    }\n\n    return data as PatientWeightAuditSBR[];\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/patient_weight_audit/patient-weight-audit-api.ts",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/bmi-v3.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/bmi.tsx",
      "bioverse-client/_deprecated/check_up_apr_29/checkup-question-logic-functions.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/patient_weight_audit/patient-weight-audit-database-type.d.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/controller/payment_error_audit/payment_error_audit.ts",
    "exports": [
      {
        "name": "postPaymentError",
        "kind": "function",
        "signature": "export async function postPaymentError(patient_id: string, error_details: any) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.from('payment_error_audit').insert({\n        error_details: error_details,\n        patient_id: patient_id,\n    });\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/payment_error_audit/payment_error_audit.ts",
      "bioverse-client/app/components/intake-v3/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component-ab.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/ed/ed-checkout/ed-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/components/wl-checkout-component-fulltest.tsx",
      "bioverse-client/app/components/intake-v2/checkout/checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/wl-checkout-component.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/payment_failure_audit/payment_failure_audit-api.ts",
    "exports": [
      {
        "name": "createPaymentFailureAudit",
        "kind": "function",
        "signature": "export async function createPaymentFailureAudit(\n    patient_id: string,\n    order_id: string,\n    product_href: string,\n    payment_method_id: string,\n    reason: string,\n): Promise<{\n    success: boolean;\n    message: string;\n}> {\n    /**\n     * Parameter validation\n     */\n    const params = { patient_id, order_id, payment_method_id, reason };\n    for (const [key, value] of Object.entries(params)) {\n        if (value === null || value === undefined) {\n            return {\n                success: false,\n                message: `${key} is undefined/null`,\n            };\n        }\n    }\n\n    const supabase = createSupabaseServiceClient();\n\n    const data = await getFailureAuditsByOrderId(order_id);\n\n    // First time failures trigger customerio event\n    if (!data || data.length === 0) {\n        await triggerEvent(patient_id, PAYMENT_FAILED, {\n            order_id,\n            order_type: OrderType.Order,\n        });\n    }\n\n    const { error } = await supabase.from('payment_failure_audit').insert({\n        patient_id: patient_id,\n        order_id: order_id,\n        payment_method_id: payment_method_id,\n        metadata: {\n            reason: reason,\n        },\n    });\n\n    await logPatientAction(patient_id, PatientActionTask.PAYMENT_FAILED, {\n        product_href,\n        order_id,\n        source: 'first_time_order',\n    });\n\n    /**\n     * Log error to console if encountered.\n     */\n    if (error) {\n        console.error(\n            'createPaymentFailureAudit',\n            'json data: ',\n            {\n                patient_id: patient_id,\n                order_id: order_id,\n                payment_method_id: payment_method_id,\n                metadata: {\n                    reason: reason,\n                },\n            },\n            error,\n            error.message,\n        );\n        return {\n            success: false,\n            message: `supabase-error: ${error.message}`,\n        };\n    }\n\n    return { success: true, message: '' };\n}"
      },
      {
        "name": "createPaymentFailureAuditForRenewalOrder",
        "kind": "function",
        "signature": "export async function createPaymentFailureAuditForRenewalOrder(\n    patient_id: string,\n    renewalOrder: RenewalOrder,\n    payment_method_id: string,\n    invoice_id: string,\n    reason: string,\n): Promise<{\n    success: boolean;\n    message: string;\n}> {\n    /**\n     * Parameter validation\n     */\n    const params = { patient_id, renewalOrder, payment_method_id, reason };\n    for (const [key, value] of Object.entries(params)) {\n        if (value === null || value === undefined) {\n            return {\n                success: false,\n                message: `${key} is undefined/null`,\n            };\n        }\n    }\n\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase.from('payment_failure_audit').insert({\n        patient_id: patient_id,\n        order_id: renewalOrder.original_order_id,\n        renewal_order_id: renewalOrder.renewal_order_id,\n        payment_method_id: payment_method_id,\n        metadata: {\n            reason: reason,\n            invoice_id,\n        },\n    });\n\n    /**\n     * Log error to console if encountered.\n     */\n    if (error) {\n        console.error(\n            'createPaymentFailureAudit',\n            'json data: ',\n            {\n                patient_id: patient_id,\n                renewal_order_id: renewalOrder.renewal_order_id,\n                payment_method_id: payment_method_id,\n                metadata: {\n                    reason: reason,\n                    invoice_id,\n                },\n            },\n            error,\n            error.message,\n        );\n        return {\n            success: false,\n            message: `supabase-error: ${error.message}`,\n        };\n    }\n\n    return { success: true, message: '' };\n}"
      },
      {
        "name": "getFailureAuditById",
        "kind": "function",
        "signature": "export async function getFailureAuditById(\n    id: string,\n): Promise<PaymentFailureAuditSBR | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('payment_failure_audit')\n        .select('*')\n        .eq('id', id)\n        .limit(1)\n        .single();\n\n    if (error) {\n        console.error('getFailureAuditById', `id: ${id}`, error, error.message);\n        return null;\n    }\n\n    return data as PaymentFailureAuditSBR;\n}"
      },
      {
        "name": "getLatestFailureAuditByOrderId",
        "kind": "function",
        "signature": "export async function getLatestFailureAuditByOrderId(\n    order_id: string,\n): Promise<PaymentFailureAuditSBR | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('payment_failure_audit')\n        .select('*')\n        .eq('order_id', order_id)\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            'getLatestFailureAuditByOrderId',\n            `order_id: ${order_id}`,\n            error,\n            error.message,\n        );\n        return null;\n    }\n\n    return data as PaymentFailureAuditSBR;\n}"
      },
      {
        "name": "getFailureAuditsByOrderId",
        "kind": "function",
        "signature": "export async function getFailureAuditsByOrderId(\n    order_id: string,\n): Promise<PaymentFailureAuditSBR[]> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('payment_failure_audit')\n        .select('*')\n        .eq('order_id', order_id);\n\n    if (error) {\n        console.error(\n            'getFailureAuditsByOrderId',\n            `order_id: ${order_id}`,\n            error,\n            error.message,\n        );\n        return [];\n    }\n\n    return data as PaymentFailureAuditSBR[];\n}"
      },
      {
        "name": "getLatestFailureAuditByPatientId",
        "kind": "function",
        "signature": "export async function getLatestFailureAuditByPatientId(\n    patient_id: string,\n): Promise<PaymentFailureAuditSBR | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('payment_failure_audit')\n        .select('*')\n        .eq('patient_id', patient_id)\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            'getLatestFailureAuditByPatientId',\n            `patient_id: ${patient_id}`,\n            error,\n            error.message,\n        );\n        return null;\n    }\n\n    return data as PaymentFailureAuditSBR;\n}"
      },
      {
        "name": "getFailureAuditsByPatientId",
        "kind": "function",
        "signature": "export async function getFailureAuditsByPatientId(\n    patient_id: string,\n): Promise<PaymentFailureAuditSBR[] | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('payment_failure_audit')\n        .select('*')\n        .eq('order_id', patient_id);\n\n    if (error) {\n        console.error(\n            'getFailureAuditsByPatientId',\n            `patient_id: ${patient_id}`,\n            error,\n            error.message,\n        );\n        return null;\n    }\n\n    return data as PaymentFailureAuditSBR[];\n}"
      },
      {
        "name": "getLatestFailureAuditByPaymentMethodId",
        "kind": "function",
        "signature": "export async function getLatestFailureAuditByPaymentMethodId(\n    payment_method_id: string,\n): Promise<PaymentFailureAuditSBR | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('payment_failure_audit')\n        .select('*')\n        .eq('payment_method_id', payment_method_id)\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            'getLatestFailureAuditByPaymentMethodId',\n            `payment_method_id: ${payment_method_id}`,\n            error,\n            error.message,\n        );\n        return null;\n    }\n\n    return data as PaymentFailureAuditSBR;\n}"
      },
      {
        "name": "getFailureAuditsByPaymentMethodId",
        "kind": "function",
        "signature": "export async function getFailureAuditsByPaymentMethodId(\n    payment_method_id: string,\n): Promise<PaymentFailureAuditSBR[] | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('payment_failure_audit')\n        .select('*')\n        .eq('payment_method_id', payment_method_id);\n\n    if (error) {\n        console.error(\n            'getFailureAuditsByPaymentMethodId',\n            `payment_method_id: ${payment_method_id}`,\n            error,\n            error.message,\n        );\n        return null;\n    }\n\n    return data as PaymentFailureAuditSBR[];\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(administration)/admin/stripe-api/stripe-api-actions.ts",
      "bioverse-client/app/utils/database/controller/payment_failure_audit/payment_failure_audit-api.ts",
      "bioverse-client/app/api/stripe/subscription/create/route.ts",
      "bioverse-client/app/services/stripe/subscriptions.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/payment_failure_audit/payment_failure_audit.d.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/controller/payment_failure_tracker/payment_failure_tracker-api.ts",
    "exports": [
      {
        "name": "createPaymentFailureTrackerForRenewals",
        "kind": "function",
        "signature": "export async function createPaymentFailureTrackerForRenewals(\n    renewalOrder: RenewalOrder,\n    invoice_id: string,\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('payment_failure_tracker')\n        .insert({\n            order_id: renewalOrder.original_order_id,\n            renewal_order_id: renewalOrder.renewal_order_id,\n            last_attempted_payment: new Date(Date.now()),\n            status: PaymentFailureStatus.Retrying,\n            patient_id: renewalOrder.customer_uuid,\n            invoice_id,\n            environment: renewalOrder.environment,\n        });\n}"
      },
      {
        "name": "shouldCreateTrackerForRenewals",
        "kind": "function",
        "signature": "export async function shouldCreateTrackerForRenewals(\n    renewalOrder: RenewalOrder,\n    invoice_id: string,\n) {\n    const tracker = await getPaymentFailureTrackerForRenewalOrder(\n        renewalOrder.renewal_order_id,\n    );\n\n    if (!tracker) {\n        await createPaymentFailureTrackerForRenewals(renewalOrder, invoice_id);\n        return true;\n    }\n\n    if (tracker.status !== PaymentFailureStatus.Retrying) {\n        await updateTrackerStatusById(\n            tracker.id,\n            PaymentFailureStatus.Retrying,\n        );\n        return true;\n    }\n\n    return false;\n}"
      },
      {
        "name": "getPaymentFailureTrackerForOrder",
        "kind": "function",
        "signature": "export async function getPaymentFailureTrackerForOrder(\n    order_id: string,\n): Promise<PaymentFailureTrackerSBR | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('payment_failure_tracker')\n        .select('*')\n        .eq('order_id', order_id)\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            'getPaymentFailureTrcakerForOrder',\n            'order_id: ',\n            order_id,\n            error,\n            error.message,\n        );\n        return null;\n    }\n\n    return data as PaymentFailureTrackerSBR;\n}"
      },
      {
        "name": "getPaymentFailureTrackerForRenewalOrder",
        "kind": "function",
        "signature": "export async function getPaymentFailureTrackerForRenewalOrder(\n    renewal_order_id: string,\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('payment_failure_tracker')\n        .select('*')\n        .eq('renewal_order_id', renewal_order_id)\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            'getPaymentFailureTrcakerForOrder',\n            'order_id: ',\n            renewal_order_id,\n            error,\n            error.message,\n        );\n        return null;\n    }\n\n    if (isEmpty(data)) {\n        return null;\n    }\n\n    return data as PaymentFailureTrackerSBR;\n}"
      },
      {
        "name": "updateTrackerStatus",
        "kind": "function",
        "signature": "export async function updateTrackerStatus(\n    order_id: string,\n    new_status: 'retrying' | 'resolved' | 'expired',\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('payment_failure_tracker')\n        .update({ status: new_status })\n        .eq('order_id', order_id)\n        .select();\n\n    if (error) {\n        console.error(\n            'updateTrackerStatus',\n            `order_id: ${order_id}`,\n            `new_status: ${new_status}`,\n        );\n        return null;\n    }\n\n    return data;\n}"
      },
      {
        "name": "updateTrackerStatusById",
        "kind": "function",
        "signature": "export async function updateTrackerStatusById(\n    tracker_id: number,\n    new_status: PaymentFailureStatus,\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('payment_failure_tracker')\n        .update({ status: new_status })\n        .eq('id', tracker_id)\n        .select();\n\n    if (error) {\n        console.error(\n            'updateTrackerStatus',\n            `tracker_id: ${tracker_id}`,\n            `new_status: ${new_status}`,\n        );\n        return null;\n    }\n\n    return data;\n}"
      },
      {
        "name": "stopAllPaymentFailureRetriesForOriginalOrderId",
        "kind": "function",
        "signature": "export async function stopAllPaymentFailureRetriesForOriginalOrderId(\n    order_id: number,\n) {\n    const supabase = createSupabaseServiceClient();\n\n    await supabase\n        .from('payment_failure_tracker')\n        .update({ status: PaymentFailureStatus.Resolved })\n        .eq('order_id', order_id)\n        .eq('status', PaymentFailureStatus.Retrying);\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/payment_failure_tracker/payment_failure_tracker-api.ts",
      "bioverse-client/app/api/stripe/webhook/invoice-paid/route.ts",
      "bioverse-client/app/api/supabase/payment-failure/route.ts",
      "bioverse-client/app/(administration)/admin/stripe-api/stripe-api-actions.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/payment_failure_tracker/payment_failure_tracker.d.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/controller/payment_failure_tracker/payment_failure_tracker_enums.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/controller/payment_failures/payment-failures.ts",
    "exports": [
      {
        "name": "createNewPaymentFailure",
        "kind": "function",
        "signature": "export async function createNewPaymentFailure(\n    orderId: number,\n    customerId: string,\n    stripeMetadata: any,\n    reason: string,\n) {\n    const supabase = await createSupabaseServiceClient();\n\n    const { error } = await supabase.from('payment_failures').insert({\n        created_at: new Date(),\n        orderId: orderId,\n        customer_uid: customerId,\n        stripe_metadata: stripeMetadata,\n        reason: reason,\n    });\n\n    if (error) {\n        console.log(\n            'Controller Error, tablename: payment_failures, method_name: createNewPaymentFailure, error: ',\n            error,\n        );\n    }\n}"
      },
      {
        "name": "retryPaymentFailureOnOrder",
        "kind": "function",
        "signature": "export async function retryPaymentFailureOnOrder(\n    orderId: number | string,\n    orderType: OrderType,\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const function_name =\n        orderType === OrderType.Order\n            ? 'retry_payment_on_failed_order'\n            : 'retry_payment_on_failed_renewal_order';\n\n    const args =\n        orderType === OrderType.Order\n            ? { order_id_: orderId }\n            : { renewal_order_id_: orderId };\n\n    try {\n        const result = await supabase.rpc(function_name, args);\n\n        return Status.Success;\n    } catch (error) {\n        console.error('retry payment error: ', error);\n        return Status.Error;\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/payment_failures/payment-failures.ts",
      "bioverse-client/app/api/stripe/subscription/create/route.ts",
      "bioverse-client/app/api/stripe/payment-intent/create/route.ts",
      "bioverse-client/app/services/stripe/subscriptions.ts",
      "bioverse-client/app/services/stripe/paymentIntent.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/RetryPaymentDialog.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/pharmacy-order-failures/pharmacy-order-failures.ts",
    "exports": [
      {
        "name": "SaveJsonUsedToFailureTable",
        "kind": "function",
        "signature": "export async function SaveJsonUsedToFailureTable(\n    jsonUsed: any,\n    orderId: string,\n    providerId: string | null,\n    reason: string,\n    response: any,\n    pharmacy: string | null,\n    source: string,\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { error } = await supabase.from('pharmacy-order-failures').insert({\n        request_json_data: jsonUsed,\n        response_json_data: JSON.stringify(response),\n        orderId: orderId,\n        providerId: providerId,\n        reason: reason,\n        pharmacy: pharmacy,\n        source,\n    });\n\n    if (error) {\n        console.log(\n            'Error in Database Controller, filenam: pharmacy-order-failures.ts, method: SaveJsonUsedToFailureTable, error details: ',\n            error,\n        );\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/pharmacy-order-failures/pharmacy-order-failures.ts",
      "bioverse-client/app/api/revive/send-script/route.ts",
      "bioverse-client/app/api/empower/send-script/route.ts",
      "bioverse-client/app/api/hallandale/send-script/route.ts",
      "bioverse-client/app/api/boothwyn/send-script/route.ts",
      "bioverse-client/app/api/dosespot/_event-type-cases/handlePrescriptionResult.ts",
      "bioverse-client/app/api/tmc/send-script/route.ts",
      "bioverse-client/app/services/pharmacy-integration/belmar/update-order.ts",
      "bioverse-client/app/services/pharmacy-integration/revive/update-order.ts",
      "bioverse-client/app/services/pharmacy-integration/empower/update-order.ts",
      "bioverse-client/app/services/pharmacy-integration/empower/send-script.ts",
      "bioverse-client/app/services/pharmacy-integration/hallandale/update-order.ts",
      "bioverse-client/app/services/pharmacy-integration/boothwyn/update-order-boothwyn.ts",
      "bioverse-client/app/services/pharmacy-integration/curexa/curexa-actions.ts",
      "bioverse-client/app/services/pharmacy-integration/gogomeds/ggm-actions.ts",
      "bioverse-client/app/services/pharmacy-integration/tmc/tmc-actions.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/pharmacy_order_audit/pharmacy_order_audit.tsx",
    "exports": [
      {
        "name": "insertPharmacyOrderAudit",
        "kind": "function",
        "signature": "export async function insertPharmacyOrderAudit(\n    json_payload: any,\n    pharmacy: string,\n    order_number: string,\n    provider_id: string | null,\n    source: string,\n    response?: any,\n) {\n    const supabase = createSupabaseServerComponentClient();\n\n    let parsedPayload: any = json_payload;\n    if (typeof json_payload === 'string') {\n        parsedPayload = JSON.parse(json_payload);\n    } else {\n        parsedPayload = json_payload;\n    }\n\n    const { error } = await supabase.from('pharmacy_order_audit').insert({\n        json_payload: json_payload,\n        pharmacy: pharmacy,\n        order_number: order_number,\n        provider_id: provider_id,\n        response: response ?? null,\n        source,\n    });\n\n    if (error) {\n        console.error(\n            'Controller Error: Tablename: pharmacy_order_audit, method: insertPharmacyOrderAudit, error: ',\n            error.message,\n        );\n    }\n}"
      },
      {
        "name": "hasSentOrderRecentlyHallandale",
        "kind": "function",
        "signature": "export async function hasSentOrderRecentlyHallandale(\n    order_id: string,\n    orderType: OrderType,\n) {\n    const supabase = createSupabaseServiceClient();\n\n    if (orderType === OrderType.Order) {\n        return false;\n    }\n\n    if (orderType === OrderType.RenewalOrder) {\n        const extracted = extractRenewalOrderId(order_id);\n\n        const originalOrderId = extracted[0];\n        const renewalNumber = extracted[1];\n\n        const threeDaysAgo = new Date();\n        threeDaysAgo.setDate(threeDaysAgo.getDate() - 1);\n\n        const { data, error } = await supabase\n            .from('pharmacy_order_audit')\n            .select('*')\n            .in('order_number', [\n                order_id,\n                renewalNumber === 1\n                    ? originalOrderId\n                    : `${originalOrderId}-${renewalNumber - 1}`,\n            ])\n            .gte('created_at', threeDaysAgo.toISOString());\n\n        if (error) {\n            console.error(\n                'Error checking if order sent recently - hallandale',\n                order_id,\n            );\n            await forwardOrderToEngineering(\n                order_id,\n                null,\n                'Failed to check if order sent recently to hallandale',\n            );\n            return true;\n        }\n\n        if (data?.length === 0) {\n            return false;\n        }\n        return true;\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/pharmacy_order_audit/pharmacy_order_audit.tsx",
      "bioverse-client/app/api/revive/send-script/route.ts",
      "bioverse-client/app/api/empower/send-script/route.ts",
      "bioverse-client/app/api/hallandale/send-script/route.ts",
      "bioverse-client/app/api/boothwyn/send-script/route.ts",
      "bioverse-client/app/api/tmc/send-script/route.ts",
      "bioverse-client/app/services/pharmacy-integration/empower/send-script.ts",
      "bioverse-client/app/services/pharmacy-integration/curexa/curexa-actions.ts",
      "bioverse-client/app/services/pharmacy-integration/gogomeds/ggm-actions.ts",
      "bioverse-client/app/services/pharmacy-integration/tmc/tmc-actions.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/prescription_script_audit/prescription_script_audit.tsx",
    "exports": [
      {
        "name": "saveScriptForFutureUse",
        "kind": "function",
        "signature": "export async function saveScriptForFutureUse(\n    json_script: any,\n    order_id: string,\n    pharmacy: string,\n    source: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    let parsedScript;\n    try {\n        parsedScript = JSON.parse(json_script);\n    } catch (e) {\n        // If parsing fails, it means json_script is already a JSON object\n        parsedScript = json_script;\n    }\n\n    const { error } = await supabase.from('prescription_script_audit').insert({\n        order_id: order_id,\n        erx_script: parsedScript,\n        pharmacy: pharmacy,\n        source,\n    });\n}"
      },
      {
        "name": "getScriptUsingOrderID",
        "kind": "function",
        "signature": "export async function getScriptUsingOrderID(order_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: script_data, error } = await supabase\n        .from('prescription_script_audit')\n        .select('order_id, erx_script, pharmacy')\n        .eq('order_id', order_id)\n        .single();\n\n    if (error) {\n        return null;\n    }\n\n    return script_data;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/prescription_script_audit/prescription_script_audit.tsx",
      "bioverse-client/app/utils/classes/Pharmacy.ts",
      "bioverse-client/app/utils/classes/Scripts/BaseScriptHandler.ts",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/confirm-prescription-dialog.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/empower/empower-window.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/empower/empower-window-v2.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/tmc/tmc-window.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approve-script-dialog.tsx",
      "bioverse-client/app/api/dosespot/_event-type-cases/handlePrescriptionResult.ts",
      "bioverse-client/app/services/pharmacy-integration/curexa/curexa-actions.ts",
      "bioverse-client/_deprecated/clinical-intake-flow/empower-interface/empower-interface.tsx",
      "bioverse-client/_deprecated/clinical-intake-flow/tmc-interface/tmc-interface.tsx",
      "bioverse-client/app/api/stripe/webhook/invoice-paid-dev/route.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/prescription_subscriptions/prescription_subscription_enums.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/controller/prescription_subscriptions/prescription_subscriptions.ts",
    "exports": [
      {
        "name": "isCustomersFirstSubscription",
        "kind": "function",
        "signature": "export async function isCustomersFirstSubscription(\n    user_id: string,\n    product_href: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('prescription_subscriptions')\n        .select('*')\n        .eq('product_href', product_href)\n        .eq('patient_id', user_id);\n\n    if (error) {\n        return true;\n    }\n\n    if (!data || data.length === 0) {\n        return true;\n    }\n\n    return false;\n}"
      },
      {
        "name": "updateSubscription",
        "kind": "function",
        "signature": "export async function updateSubscription(\n    subscription_id: number,\n    update_payload: Partial<PrescriptionSubscription>\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('prescription_subscriptions')\n        .update(update_payload)\n        .eq('id', subscription_id);\n\n    if (error) {\n        console.log(\n            'failure in updating subscription with Last Used Script.',\n            error\n        );\n    }\n\n    return Status.Success;\n}"
      },
      {
        "name": "shouldApplyDiscountToFirstTimeOrder",
        "kind": "function",
        "signature": "export async function shouldApplyDiscountToFirstTimeOrder(\n    user_id: string,\n    product_href: string\n) {\n    const isFirstSubscription = await isCustomersFirstSubscription(\n        user_id,\n        product_href\n    );\n\n    return isFirstSubscription;\n}"
      },
      {
        "name": "createSubscriptionWithOrderData",
        "kind": "function",
        "signature": "export async function createSubscriptionWithOrderData(\n    orderData: Order,\n    providerId: string,\n    stripe_subscription_id: string,\n    failure?: boolean\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: newlyCreatedSubscription, error: subscriptionCreationError } =\n        await supabase\n            .from('prescription_subscriptions')\n            .insert([\n                {\n                    patient_id: orderData.customer_uid,\n                    provider_id: providerId,\n                    last_updated: new Date(),\n                    product_href: orderData.product_href,\n                    next_refill_date: null,\n                    variant_text: orderData.variant_text,\n                    subscription_type: orderData.subscription_type,\n                    order_id: orderData.orderId,\n                    stripe_subscription_id: stripe_subscription_id,\n                    assigned_pharmacy: orderData.assigned_pharmacy,\n                    renewal_count: 0,\n                    status: 'active',\n                    environment: orderData.environment,\n                    recent_variants: [orderData.variant_index],\n                    ...(failure ? { status: 'payment-failed' } : {}),\n                },\n            ])\n            .select();\n\n    if (subscriptionCreationError) {\n        console.log(\n            'prescription-subscriptions.ts - subscription creation error. Message: ' +\n                subscriptionCreationError.message\n        );\n        console.error(subscriptionCreationError);\n        return { error: 'creation failed' };\n    }\n\n    await updateOrderSubscriptionID(\n        orderData.orderId,\n        newlyCreatedSubscription![0].id\n    );\n\n    return newlyCreatedSubscription![0].id;\n}"
      },
      {
        "name": "updateSubscriptionLastUsedJSON",
        "kind": "function",
        "signature": "export async function updateSubscriptionLastUsedJSON(\n    order_id: string,\n    pharmacy: string,\n    json: any\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('prescription_subscriptions')\n        .update({ last_used_script: json, assigned_pharmacy: pharmacy })\n        .eq('order_id', order_id);\n\n    if (error) {\n        console.log(\n            'failure in updating subscription with Last Used Script.',\n            error\n        );\n    }\n\n    return Status.Success;\n}"
      },
      {
        "name": "getAllSubscriptionsForPatient",
        "kind": "function",
        "signature": "export async function getAllSubscriptionsForPatient(patient_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: subscriptions, error: error } = await supabase\n        .from('prescription_subscriptions')\n        .select(\n            `*, product:products!product_href(\n            name\n        ), order:orders!order_id(\n            discount_id\n        )`\n        )\n        .eq('patient_id', patient_id);\n    if (error) {\n        console.log('Prescription Subscription Error in fetching, ', error);\n        return { data: null, error: error };\n    }\n    return { data: subscriptions, error: null };\n}"
      },
      {
        "name": "getSubscriptionWithStripeSubscriptionId",
        "kind": "function",
        "signature": "export async function getSubscriptionWithStripeSubscriptionId(\n    stripe_subscription_id: string\n): Promise<{ subscription: PrescriptionSubscription | null }> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: subscription, error: error } = await supabase\n        .from('prescription_subscriptions')\n        .select('*')\n        .eq('stripe_subscription_id', stripe_subscription_id)\n        .maybeSingle();\n\n    if (error) {\n        console.log(\n            'prescription-subscriptions.ts - getSubscriptionWithStripeSubscriptionId, Message: ' +\n                error.message\n        );\n        return { subscription: null };\n    }\n\n    if (!subscription) {\n        return { subscription: null };\n    }\n\n    return { subscription };\n}"
      },
      {
        "name": "createPrescriptionSubscription",
        "kind": "function",
        "signature": "export async function createPrescriptionSubscription(\n    subscription_payload: Partial<PrescriptionSubscription>\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('prescription_subscriptions')\n        .insert(subscription_payload)\n        .select();\n\n    if (error) {\n        console.error(\n            'Error creating prescription subscription with payload',\n            subscription_payload\n        );\n        return null;\n    }\n\n    if (data[0]) {\n        return data[0] as PrescriptionSubscription;\n    }\n\n    return null;\n}"
      },
      {
        "name": "updateRenewalCount",
        "kind": "function",
        "signature": "export async function updateRenewalCount(\n    subscription_id: string,\n    new_renewal_count_value: number\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('prescription_subscriptions')\n        .update({ renewal_count: new_renewal_count_value })\n        .eq('id', subscription_id);\n\n    await updateRefillCount(subscription_id);\n}"
      },
      {
        "name": "updateLastRenewalDate",
        "kind": "function",
        "signature": "export async function updateLastRenewalDate(subscription_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('prescription_subscriptions')\n        .update({ last_renewal_date: new Date() })\n        .eq('id', subscription_id);\n\n    await updateRefillCount(subscription_id);\n}"
      },
      {
        "name": "getCancelationDetails",
        "kind": "function",
        "signature": "export async function getCancelationDetails(subscription_id: number): Promise<{\n    patient_id: string;\n    name: string;\n}> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .rpc('get_cancelation_details', { subscription_id_: subscription_id })\n        .single();\n\n    if (error) {\n        console.error('Failed to get cancelation details for', subscription_id);\n        return { patient_id: '', name: '' };\n    }\n    return data as {\n        patient_id: string;\n        name: string;\n    };\n}"
      },
      {
        "name": "setRefillCount",
        "kind": "function",
        "signature": "export async function setRefillCount(\n    subscription_id: string,\n    product_href: string,\n    cadence: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const refill_value = getRefillCount(product_href, cadence);\n    const { error } = await supabase\n        .from('prescription_subscriptions')\n        .update({ refills_remaining: refill_value })\n        .eq('id', subscription_id);\n\n    if (error) {\n        console.log('refill count assignment error. details: ', error);\n    }\n}"
      },
      {
        "name": "getPaymentFailedSubscriptionWithID",
        "kind": "function",
        "signature": "export async function getPaymentFailedSubscriptionWithID(\n    subscription_id: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: subscription, error: error } = await supabase\n        .from('prescription_subscriptions')\n        .select('*')\n        .eq('stripe_subscription_id', subscription_id)\n        .eq('status', 'payment-failed')\n        .maybeSingle();\n\n    if (error) {\n        console.log(\n            'prescription-subscriptions.ts - getSubscriptionWithStripeSubscriptionId, Message: ' +\n                error.message\n        );\n        return null;\n    }\n\n    return { subscription: subscription };\n}"
      },
      {
        "name": "incrementSinceLastCheckup",
        "kind": "function",
        "signature": "export async function incrementSinceLastCheckup(subscription_id: number) {\n    const supabase = createSupabaseServiceClient();\n    await supabase.rpc('increment_since_last_checkup', { subscription_id });\n}"
      },
      {
        "name": "getStripeSubscriptionIdFromSubscription",
        "kind": "function",
        "signature": "export async function getStripeSubscriptionIdFromSubscription(\n    subscription_id: string | number\n): Promise<string | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('prescription_subscriptions')\n        .select('stripe_subscription_id')\n        .eq('id', subscription_id)\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            'prescription-subscriptions.ts - getStripeSubscriptionIdFromSubscription, Message: ' +\n                error.message\n        );\n    }\n\n    if (!data?.stripe_subscription_id) {\n        return null;\n    }\n    return data.stripe_subscription_id;\n}"
      },
      {
        "name": "isActiveSubscription",
        "kind": "function",
        "signature": "export async function isActiveSubscription(order_id: string): Promise<string> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('prescription_subscriptions')\n        .select('status')\n        .eq('order_id', order_id)\n        .maybeSingle();\n\n    if (error) {\n        console.error('Error getting order pill status', error);\n        return 'error';\n    }\n\n    return data?.status;\n}"
      },
      {
        "name": "getSubscriptionStatusFlagsFromOriginalOrderId",
        "kind": "function",
        "signature": "export async function getSubscriptionStatusFlagsFromOriginalOrderId(\n    order_id: string\n): Promise<string[]> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('prescription_subscriptions')\n        .select('status_flags')\n        .eq('order_id', order_id)\n        .maybeSingle();\n\n    if (error) {\n        console.error('Error getting order pill status', error);\n        return [];\n    }\n\n    return data?.status_flags;\n}"
      },
      {
        "name": "getSubscriptionByProduct",
        "kind": "function",
        "signature": "export async function getSubscriptionByProduct(\n    product_href: string,\n    customer_id: string\n): Promise<PrescriptionSubscription | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('prescription_subscriptions')\n        .select('*')\n        .eq('product_href', product_href)\n        .eq('patient_id', customer_id)\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            'Error doesCustomerHaveSubscriptionWithProduct',\n            error,\n            product_href,\n            customer_id\n        );\n        return null;\n    }\n\n    return data;\n}"
      },
      {
        "name": "getSubscriptionById",
        "kind": "function",
        "signature": "export async function getSubscriptionById(subscription_id: number) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('prescription_subscriptions')\n        .select('*')\n        .eq('id', subscription_id)\n        .maybeSingle();\n\n    if (error || !data) {\n        console.error('Error getting subscription by id', error);\n        return null;\n    }\n    return data;\n}"
      },
      {
        "name": "updateRecentVariants",
        "kind": "function",
        "signature": "export async function updateRecentVariants(\n    subscription_id: number,\n    new_variant_id: number\n) {\n    const { data, status } = await getSubscriptionDetails(subscription_id);\n\n    if (status === Status.Failure) {\n        console.error(\n            'Error updating recent variants. Failed to get sub details',\n            subscription_id,\n            new_variant_id\n        );\n        return;\n    }\n\n    const newRecentVariants = [\n        new_variant_id,\n        ...data.recent_variants.slice(0, 2),\n    ];\n\n    await updatePrescriptionSubscription(subscription_id, {\n        recent_variants: newRecentVariants,\n    });\n}"
      },
      {
        "name": "getLastUsedVariantForSubscription",
        "kind": "function",
        "signature": "export async function getLastUsedVariantForSubscription(\n    subscription_id: number\n): Promise<number> {\n    const { data, status } = await getSubscriptionDetails(subscription_id);\n\n    if (status === Status.Failure) {\n        console.error(\n            'Error updating recent variants. Failed to get sub details',\n            subscription_id\n        );\n        return -1;\n    }\n\n    if (data.recent_variants) {\n        return data.recent_variants[0];\n    }\n    return -1;\n}"
      },
      {
        "name": "handleCheckUpSubscriptionExtension",
        "kind": "function",
        "signature": "export async function handleCheckUpSubscriptionExtension(\n    subscriptionData: PrescriptionSubscription\n) {\n    const stripeSubscription = await getStripeSubscription(\n        subscriptionData.stripe_subscription_id\n    );\n\n    const currentTime = Math.floor(Date.now() / 1000); // Convert current time to seconds (Stripe uses Unix timestamps)\n    const renewalTime = stripeSubscription.current_period_end;\n\n    // Check if the renewal is within 4 days (4 * 24 * 60 * 60 seconds)\n    const fourDaysInSeconds = 4 * 24 * 60 * 60;\n\n    if (renewalTime <= currentTime + fourDaysInSeconds) {\n        await extendSubscriptionRenewalBy5Days(\n            subscriptionData.stripe_subscription_id\n        );\n    }\n}"
      },
      {
        "name": "wipeStatusFlags",
        "kind": "function",
        "signature": "export async function wipeStatusFlags(subscription_id: number) {\n    const supabase = createSupabaseServiceClient();\n    const { error: prescriptionError2 } = await supabase\n        .from('prescription_subscriptions')\n        .update({\n            status_flags: [], //just replace the entire array\n        })\n        .eq('id', subscription_id);\n    if (prescriptionError2) {\n        console.error(\n            'Error updating prescription last_checkup 69420',\n            subscription_id,\n            prescriptionError2\n        );\n    }\n}"
      },
      {
        "name": "addOrRemoveStatusFlags",
        "kind": "function",
        "signature": "export async function addOrRemoveStatusFlags(\n    subscription_id: number,\n    addOrRemove: 'add' | 'remove',\n    statusFlag: SubscriptionStatusFlags\n) {\n    const subscription = await getPrescriptionSubscription(subscription_id);\n\n    if (!subscription) {\n        return Status.Failure;\n    }\n\n    const supabase = createSupabaseServiceClient();\n\n    const { data: currentData, error: fetchError } = await supabase\n        .from('prescription_subscriptions')\n        .select('status_flags')\n        .eq('id', subscription_id)\n        .single();\n\n    if (fetchError) {\n        console.error(fetchError);\n        return Status.Failure;\n    }\n\n    let updatedFlags;\n\n    if (addOrRemove === 'remove') {\n        updatedFlags =\n            currentData.status_flags?.filter(\n                (tag: string) => tag !== statusFlag\n            ) || [];\n    }\n\n    if (addOrRemove === 'add') {\n        !currentData.status_flags || currentData.status_flags.length === 0\n            ? (updatedFlags = [statusFlag])\n            : currentData.status_flags.includes(statusFlag)\n            ? (updatedFlags = currentData.status_flags)\n            : (updatedFlags = [...currentData.status_flags, statusFlag]);\n    }\n\n    const { error: prescriptionError } = await supabase\n        .from('prescription_subscriptions')\n        .update({\n            status_flags: updatedFlags,\n        })\n        .eq('id', subscription_id);\n\n    if (prescriptionError) {\n        console.error(prescriptionError);\n        return Status.Failure;\n    }\n\n    return Status.Success;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/prescription_subscriptions/prescription_subscriptions.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/subscriptions/components/subscription-accordion.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/subscriptions/components/change-product-dialog/ChangeSubscriptionInformationDialog.tsx",
      "bioverse-client/app/api/revive/send-script/route.ts",
      "bioverse-client/app/api/empower/send-script/route.ts",
      "bioverse-client/app/api/hallandale/send-script/route.ts",
      "bioverse-client/app/api/boothwyn/send-script/route.ts",
      "bioverse-client/app/api/tmc/send-script/route.ts",
      "bioverse-client/app/services/pharmacy-integration/empower/send-script.ts",
      "bioverse-client/app/services/pharmacy-integration/curexa/curexa-actions.ts",
      "bioverse-client/app/services/pharmacy-integration/gogomeds/ggm-actions.ts",
      "bioverse-client/app/services/pharmacy-integration/tmc/tmc-actions.ts",
      "bioverse-client/app/services/stripe/subscriptions.ts",
      "bioverse-client/app/api/stripe/subscription/create/route.ts",
      "bioverse-client/app/utils/actions/subscriptions/subscription-actions.ts",
      "bioverse-client/app/api/stripe/webhook/invoice-paid-dev/route.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/subscriptions/subscription-content.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/subscriptions-content.tsx",
      "bioverse-client/app/(testing_and_development)/olivier-dev/utils.ts",
      "bioverse-client/app/api/stripe/webhook/invoice-paid/route.ts",
      "bioverse-client/app/utils/actions/prescription-subscriptions/prescription-subscriptions-actions.ts",
      "bioverse-client/app/api/easypost/route.tsx",
      "bioverse-client/app/(administration)/admin/stripe-api/stripe-api-actions.ts",
      "bioverse-client/app/utils/functions/annual-glp1/annual-glp1-controller.ts",
      "bioverse-client/app/utils/functions/split-shipment-glp1/split-shipment-glp1-controller.ts",
      "bioverse-client/app/utils/actions/intake/order-util.ts",
      "bioverse-client/app/utils/database/controller/orders/create-manual-order.ts",
      "bioverse-client/app/utils/database/controller/orders/process-manual-order.ts",
      "bioverse-client/app/components/patient-portal/check-up/question/checkup-question-logic.ts",
      "bioverse-client/app/api/renewal/autoship/route.ts",
      "bioverse-client/app/(patient-portal)/check-up/[product_href]/utils.ts",
      "bioverse-client/app/(patient-portal)/check-up/[product_href]/page.tsx",
      "bioverse-client/_deprecated/check_up_apr_29/checkup-question-logic-functions.ts",
      "bioverse-client/app/utils/actions/check-up/check-up-actions.ts",
      "bioverse-client/app/components/patient-portal/subscriptions/components/SubscriptionList/utils/SubscriptionItem-functions.ts",
      "bioverse-client/app/services/pharmacy-integration/empower/provider-script-feedback.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/StripeInvoicePaidJobHandler.ts",
      "bioverse-client/app/services/pharmacy-integration/util/utils.ts",
      "bioverse-client/app/(testing_and_development)/ben-dev/page.tsx",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/RenewalValidationJobHandler.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/product_variants/product_variants.ts",
    "exports": [
      {
        "name": "getProductVariantList",
        "kind": "function",
        "signature": "export async function getProductVariantList() {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_product_variants_href_list'\n    );\n\n    return data;\n}"
      },
      {
        "name": "getPriceVariantTableData",
        "kind": "function",
        "signature": "export async function getPriceVariantTableData(productHref: string): Promise<{\n    data: ProductVariantRecord[] | null;\n    error: PostgrestError | null;\n}> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: priceData, error: priceDataError } = await supabase\n        .from('product_variants')\n        .select('*')\n        .eq('product_href', productHref)\n        .order('variant_index', { ascending: true });\n\n    if (priceDataError) {\n        console.error('Error fetching data for prescription:', priceDataError);\n        return { data: null, error: priceDataError };\n    }\n\n    return { data: priceData as ProductVariantRecord[], error: null };\n}"
      },
      {
        "name": "getActiveVariantsForProduct",
        "kind": "function",
        "signature": "export async function getActiveVariantsForProduct(\n    productHref: string\n): Promise<{\n    data: ProductVariantRecord[] | null;\n    error: PostgrestError | null;\n}> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: priceData, error: priceDataError } = await supabase\n        .from('product_variants')\n        .select('*')\n        .eq('product_href', productHref)\n        .eq('active', true)\n        .order('variant_index', { ascending: true });\n\n    if (priceDataError) {\n        console.error('Error fetching data for prescription:', priceDataError);\n        return { data: null, error: priceDataError };\n    }\n\n    return { data: priceData as ProductVariantRecord[], error: null };\n}"
      },
      {
        "name": "getMonthlyAndQuarterlyPriceVariantData",
        "kind": "function",
        "signature": "export async function getMonthlyAndQuarterlyPriceVariantData(\n    product_href: string\n): Promise<{\n    monthlyPrice: Partial<ProductVariantRecord> | null;\n    quarterlyPrice: Partial<ProductVariantRecord> | null;\n}> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: monthlyFetch, error: monthlyFetchError } = await supabase\n        .from('product_variants')\n        .select('price_data, variant_index, stripe_price_ids')\n        .eq('product_href', product_href)\n        .eq('cadence', 'monthly')\n        .limit(1)\n        .single();\n\n    const { data: quarterlyFetch, error: quarterlyFetchError } = await supabase\n        .from('product_variants')\n        .select('price_data, variant_index, stripe_price_ids')\n        .eq('product_href', product_href)\n        .eq('cadence', 'quarterly')\n        .limit(1)\n        .single();\n\n    return {\n        monthlyPrice: monthlyFetch,\n        quarterlyPrice: quarterlyFetch,\n    };\n}"
      },
      {
        "name": "getPriceDataRecordWithVariant",
        "kind": "function",
        "signature": "export async function getPriceDataRecordWithVariant(\n    product_href: string,\n    variant_index: number | string\n): Promise<Partial<ProductVariantRecord> | null> {\n    const supabase = createSupabaseServiceClient();\n\n    if (variant_index == -1) {\n        console.log(\n            `Variant Index is -1 in getPriceDataRecordWithVariant, returning null, product_href: ${product_href}, variant_index: ${variant_index}`\n        );\n        return null;\n    }\n\n    console.log(\n        'Checkign Variant Index on Get PriceDataRecordWithVariant',\n        product_href,\n        variant_index\n    );\n\n    const { data, error } = await supabase\n        .from('product_variants')\n        .select(\n            `variant, vial, cadence, price_data, variant_index, vial_dosages, dosages, pharmacy, stripe_price_ids`\n        )\n        .eq('product_href', product_href)\n        .eq('variant_index', variant_index)\n        .single();\n\n    if (error) {\n        console.error('Error getting price for variant', error);\n        return null;\n    }\n\n    return data;\n}"
      },
      {
        "name": "getProductVariantStripePriceIDsWithCadence",
        "kind": "function",
        "signature": "export async function getProductVariantStripePriceIDsWithCadence(\n    product_href: string,\n    cadence: 'one_time' | 'monthly' | 'quarterly' | 'bimonthly' | 'pentamonthly'\n): Promise<{ [key: string]: string } | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('product_variants')\n        .select('stripe_price_ids')\n        .eq('product_href', product_href)\n        .eq('cadence', cadence)\n        .limit(1)\n        .single();\n\n    if (error) {\n        console.error('Error getting stripe price', product_href, cadence);\n        return null;\n    }\n\n    return data.stripe_price_ids;\n}"
      },
      {
        "name": "getProductVariantStripePriceIDsWithVariantIndex",
        "kind": "function",
        "signature": "export async function getProductVariantStripePriceIDsWithVariantIndex(\n    product_href: string,\n    variant_index: number\n): Promise<{ [key: string]: string } | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('product_variants')\n        .select('stripe_price_ids')\n        .eq('product_href', product_href)\n        .eq('variant_index', variant_index)\n        .single();\n\n    if (error) {\n        console.error(\n            'Error getting stripe price',\n            product_href,\n            variant_index\n        );\n        return null;\n    }\n\n    return data.stripe_price_ids;\n}"
      },
      {
        "name": "getGLP1PriceVariantTableData",
        "kind": "function",
        "signature": "export async function getGLP1PriceVariantTableData(): Promise<\n    Partial<ProductVariantRecord>[] | null\n> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: priceData, error: priceDataError } = await supabase\n        .from('product_variants')\n        .select('stripe_price_ids, product_href, variant_index')\n        .in('product_href', ['semaglutide', 'tirzepatide'])\n        .order('product_href', { ascending: true })\n        .order('variant_index', { ascending: true });\n\n    if (priceDataError) {\n        console.error('Error fetching data for prescription:', priceDataError);\n    }\n\n    return priceData;\n}"
      },
      {
        "name": "getDosagesForProductVariant",
        "kind": "function",
        "signature": "export async function getDosagesForProductVariant(\n    product_href: string,\n    variant_index: number\n): Promise<string | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('product_variants')\n        .select('dosages')\n        .eq('product_href', product_href)\n        .eq('variant_index', variant_index)\n        .single();\n\n    if (error) {\n        console.error('Error getting vial dosages', error);\n        return null;\n    }\n\n    return data.dosages;\n}"
      },
      {
        "name": "getVialUnitsPerMgForMonth",
        "kind": "function",
        "signature": "export async function getVialUnitsPerMgForMonth(\n    product_href: string,\n    variant_index: number,\n    month: number\n): Promise<number | null> {\n\n    console.log(\"inside getVialUnitsPerMgForMonth\", product_href, variant_index, month);\n    //add a check, just in case the variant index of the order is not the same as the variant index post pvc variant index\n\n    const productVariantRow = await getPriceDataRecordWithVariant(product_href, variant_index);\n    if (!productVariantRow) {\n        console.error('No product variant row found', product_href, variant_index);\n        return null;\n    }\n\n    if (productVariantRow.pharmacy === PHARMACY.REVIVE) {\n\n        const vialsThatComeWithTheOffer = REVIVE_PRODUCT_VARIANT_MAP[product_href as PRODUCT_HREF][variant_index];\n        if (!vialsThatComeWithTheOffer) {\n            console.error('No vials that come with the offer', product_href, variant_index); return null;\n        }\n\n        let vialIdList = []; //collect all unix vial ids for the vials that come with the offer\n        for (const vial of vialsThatComeWithTheOffer) {\n            const vialId = vial.product_identification.product_identifier;\n            vialIdList.push(vialId);\n        }\n\n        //loop through all the vial ids with the REVIVE_UNITS_PER_MG_MAP and see if they all have the same units per mg\n        let unitsPerMgForAllVials = null;\n        for (const vialId of vialIdList) {\n            const unitsPerMg = REVIVE_UNITS_PER_MG_MAP[product_href as PRODUCT_HREF][vialId as keyof typeof REVIVE_UNITS_PER_MG_MAP[PRODUCT_HREF]];\n            if (unitsPerMgForAllVials === null) {\n                unitsPerMgForAllVials = unitsPerMg;\n            } else if (unitsPerMg !== unitsPerMgForAllVials) {\n                //figure out which vial should be allocated to that month. \n                console.error('Units per mg is not the same for all the vials', product_href, variant_index);\n                return null; //if the units per mg is not the same for all the vials, that's when it gets fun\n            }\n        }\n\n        return unitsPerMgForAllVials || null; //if the units per mg is the same for all the vials, we're safe to use that\n\n    }\n\n    if (productVariantRow.pharmacy === PHARMACY.BOOTHWYN) {\n\n        const vialsThatComeWithTheOffer = BOOTHWYN_VARIANT_MAP[product_href as PRODUCT_HREF][variant_index];\n        if (!vialsThatComeWithTheOffer) {\n            console.error('No vials that come with the offer', product_href, variant_index); return null;\n        }\n\n        let vialIdList = []; //collect all unix vial ids for the vials that come with the offer\n        for (const vial of vialsThatComeWithTheOffer) {\n            const vialId = vial.sku;\n            vialIdList.push(vialId);\n        }\n\n        //loop through all the vial ids with the REVIVE_UNITS_PER_MG_MAP and see if they all have the same units per mg\n        let unitsPerMgForAllVials = null;\n        for (const vialId of vialIdList) {\n            const unitsPerMg = BOOTHWYN_UNITS_PER_MG_MAP[product_href as PRODUCT_HREF][vialId as keyof typeof BOOTHWYN_UNITS_PER_MG_MAP[PRODUCT_HREF]];\n            if (!unitsPerMg) { console.error('Need a units/mg ratio mapping for this boothwyn vial', vialId); }\n\n            if (unitsPerMgForAllVials === null) {\n                unitsPerMgForAllVials = unitsPerMg;\n            } else if (unitsPerMg !== unitsPerMgForAllVials) {\n                //figure out which vial should be allocated to that month. \n                return null; //if the units per mg is not the same for all the vials, that's when it gets fun\n            }\n        }\n\n        return unitsPerMgForAllVials || null; \n    }\n\n    if (productVariantRow.pharmacy === PHARMACY.EMPOWER) {\n\n        const empowerCatalogObject = getEmpowerCatalogObject(product_href as PRODUCT_HREF, variant_index);\n        if (!empowerCatalogObject) {\n            console.error('No empower catalog object found', product_href, variant_index); return null;\n        }\n\n        let vialIdList = empowerCatalogObject.array.map((vial: any) => vial.catalogItemCode);    \n        if (!vialIdList) {\n            console.error('No vials that come with the offer', product_href, variant_index); return null;\n        }\n\n        //loop through all the vial ids with the REVIVE_UNITS_PER_MG_MAP and see if they all have the same units per mg\n        let unitsPerMgForAllVials = null;\n        for (const vialId of vialIdList) {\n            const unitsPerMg = EMPOWER_UNITS_PER_MG_MAP[product_href as PRODUCT_HREF][vialId as keyof typeof EMPOWER_UNITS_PER_MG_MAP[PRODUCT_HREF]];\n            console.log(\"unitsPerMg\", unitsPerMg);\n            if (unitsPerMgForAllVials === null) {\n                unitsPerMgForAllVials = unitsPerMg;\n            } else if (unitsPerMg !== unitsPerMgForAllVials) {\n                //figure out which vial should be allocated to that month. \n                console.error('Units per mg is not the same for all the vials', product_href, variant_index);\n                return null; //if the units per mg is not the same for all the vials, that's when it gets fun\n            }\n        }\n\n        return unitsPerMgForAllVials || null; //if the units per mg is the same for all the vials, we're safe to use that\n\n    }\n\n    if (productVariantRow.pharmacy === PHARMACY.HALLANDALE) {\n\n        const hallandaleCatalogObject = getHallandaleCatalogObject(product_href as PRODUCT_HREF, variant_index);\n        if (!hallandaleCatalogObject) {\n            console.error('No hallandale catalog object found', product_href, variant_index); return null;\n        }\n\n        let vialIdList = hallandaleCatalogObject.array.map((vial: any) => vial.catalogItemCode);\n        if (!vialIdList) {\n            console.error('No vials that come with the offer', product_href, variant_index); return null;\n        }\n        vialIdList = vialIdList.filter((vialId: string) => vialId !== 'GLP-INJECTION-KIT');\n\n        let unitsPerMgForAllVials = null;\n        for (const vialId of vialIdList) {\n            const unitsPerMg = HALLANDALE_UNITS_PER_MG_MAP[product_href as PRODUCT_HREF][vialId as keyof typeof HALLANDALE_UNITS_PER_MG_MAP[PRODUCT_HREF]];\n            if (unitsPerMgForAllVials === null) {\n                unitsPerMgForAllVials = unitsPerMg;\n            } else if (unitsPerMg !== unitsPerMgForAllVials) {\n                //figure out which vial should be allocated to that month. \n                console.error('Units per mg is not the same for all the vials', product_href, variant_index);\n                return null; //if the units per mg is not the same for all the vials, that's when it gets fun\n            }\n        }\n\n        return unitsPerMgForAllVials || null; //if the units per mg is the same for all the vials, we're safe to use that\n        \n    }\n\n    console.error('Pharmacy not mapped for adjust dosing', product_href, variant_index);\n    console.log(\"productVariantRow\", productVariantRow);\n    return null;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/product_variants/product_variants.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/ManualOrderCreationDialog.tsx",
      "bioverse-client/app/utils/database/controller/orders/orders-api.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/ChangeOrderInformationDialog.tsx",
      "bioverse-client/app/components/navigation/components/sticky-banner/sticky-banner.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/SubscriptionList/utils/SubscriptionItem-functions.ts",
      "bioverse-client/app/components/patient-portal/order-history/orderItem.tsx",
      "bioverse-client/app/components/intake-v3/topnav/banner.tsx",
      "bioverse-client/app/components/intake-v2/topnav/banner.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/new-checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v2/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/demographic-collection-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3-abtest/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/combined-wl-demographic/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/ed-checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/demographic-wl/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/product-overview/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/demographic-information/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/demographic-wl-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3-zbp/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/demographic-collection/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/skincare-frequency/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/new-checkout/page.tsx",
      "bioverse-client/_deprecated/navigation/sticky-banner/sticky-banner.tsx",
      "bioverse-client/app/components/productPages/productPurchaseMenu/v2/purchase-menu.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/select-supply-ap/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/select-supply/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/select-supply-v3/page.tsx",
      "bioverse-client/app/(testing_and_development)/olivier-dev/utils.ts",
      "bioverse-client/app/(administration)/admin/stripe-api/stripe-api-actions.ts",
      "bioverse-client/app/utils/database/controller/renewal_orders/renewal_orders.ts",
      "bioverse-client/app/utils/classes/Dashboard.ts",
      "bioverse-client/app/utils/classes/Scripts/BoothwynScriptHandler.ts",
      "bioverse-client/app/utils/classes/Scripts/EmpowerScriptHandler.ts",
      "bioverse-client/app/utils/classes/Scripts/ReviveScriptHandler.ts",
      "bioverse-client/app/utils/classes/Scripts/HallandaleScriptHandler.ts",
      "bioverse-client/app/utils/actions/intake/wl-supply.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/RenewalValidationJobHandler.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/StripeInvoicePaidJobHandler.ts",
      "bioverse-client/app/(employee)/(provider-portal)/provider/active-renewal-options/page.tsx",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/script-view/coordiantor-hallandale-script-view.tsx",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/script-view/coordinator-empower-script-view.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/CoordinatorConfirmDosage.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/orders-components/order-accordion.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/orders-components/renewal-order-accordion.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/utils/intake-helpers.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/quarterly-final-review-dialog.tsx",
      "bioverse-client/app/components/patient-portal/check-up-requested/refill-preference/utils/refill-preference-screen-data-fetch.tsx",
      "bioverse-client/app/api/stripe/webhook/invoice-paid/route.ts",
      "bioverse-client/app/api/stripe/subscription/create/route.ts",
      "bioverse-client/app/api/stripe/payment-intent/create/route.ts",
      "bioverse-client/app/(patient-portal)/dosage-selection/[product]/[variant_index]/page.tsx",
      "bioverse-client/app/(patient-portal)/dosage/first-time/[order_id]/[variant_index]/page.tsx",
      "bioverse-client/app/(patient-portal)/dosage/first-time/[order_id]/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/order-summary-v3-zbp/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/order-summary-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/order-summary-v4/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/order-summary-v3-ap/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/general-order-summary/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/general-order-summary-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/order-summary/page.tsx",
      "bioverse-client/app/services/stripe/paymentIntent.ts",
      "bioverse-client/app/(testing_and_development)/ben-dev/page.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/subscriptions/components/change-product-dialog/ChangeSubscriptionInformationDialog.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/components/adjust-dosing-button/v2-components/AdjustDosingDialog.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/products/products.ts",
    "exports": [
      {
        "name": "getActiveCollectionsData",
        "kind": "function",
        "signature": "export async function getActiveCollectionsData() {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('products')\n        .select(\n            'name, category, price, description_short, image_ref, href, type, filter_metadata,review_image_ref'\n        )\n        .eq('active', true);\n\n    if (error) {\n        console.error(\n            'Collections Page ran into an issue fetching data. Details: ',\n            error.message\n        );\n        return { data: null, error: error.message };\n    }\n\n    return { data: data, error: null };\n}"
      },
      {
        "name": "getImageRefUsingProductHref",
        "kind": "function",
        "signature": "export async function getImageRefUsingProductHref(product_href: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('products')\n        .select('image_ref')\n        .eq('href', product_href)\n        .single();\n\n    if (error) {\n        console.error(error, error.message);\n        return { data: null, error: error };\n    }\n\n    return { data: data.image_ref, error: null };\n}"
      },
      {
        "name": "getCollectionsData",
        "kind": "function",
        "signature": "export async function getCollectionsData() {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('products')\n        .select(\n            'name, category, price, description_short, image_ref, href, type, filter_metadata,review_image_ref'\n        );\n\n    if (error) {\n        console.error(\n            'Collections Page ran into an issue fetching data. Details: ',\n            error.message\n        );\n        return { data: null, error: error.message };\n    }\n\n    return { data: data, error: null };\n}"
      },
      {
        "name": "getProductName",
        "kind": "function",
        "signature": "export async function getProductName(product_href: string) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('products')\n        .select('name')\n        .eq('href', product_href)\n        .single();\n\n    if (error) {\n        return { name: null, error: error.message };\n    }\n\n    return { name: data.name, error: null };\n}"
      },
      {
        "name": "getProductVariant",
        "kind": "function",
        "signature": "export async function getProductVariant(product_href: string) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('products')\n        .select('variants')\n        .eq('href', product_href)\n        .single();\n\n    if (error) {\n        return { variant: null, error: error.message };\n    }\n\n    return { variant: data.variants, error: null };\n}"
      },
      {
        "name": "getQuestionnaireVersionsForProduct",
        "kind": "function",
        "signature": "export async function getQuestionnaireVersionsForProduct(\n    product_href: PRODUCT_HREF\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('products')\n        .select(\n            'current_question_set_version, checkup_questionnaire_set_version'\n        )\n        .eq('href', product_href)\n        .single();\n\n    if (error) {\n        console.error(\n            'Failed getQuestionnaireVersionsForProduct for',\n            product_href,\n            error\n        );\n        return null;\n    }\n\n    return data as ProductQuestionnaireVersion;\n}"
      },
      {
        "name": "getProductMetadata",
        "kind": "function",
        "signature": "export async function getProductMetadata(productHref: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('products')\n        .select('metadata')\n        .eq('href', productHref)\n        .limit(1)\n        .single();\n\n    if (error) {\n        console.log('getProductMetadata', error);\n    }\n\n    return data?.metadata;\n}"
      },
      {
        "name": "getVariantIndexByPriceIdV2",
        "kind": "function",
        "signature": "export async function getVariantIndexByPriceIdV2(\n    product_href: PRODUCT_HREF,\n    priceId: string\n): Promise<{\n    variant_index: string;\n    cadence: string;\n}> {\n    /**\n     *\n     * We have some situations where more than one row in product_variants table have the same priceID.\n     * So the function would look for a product_variants row with the given priceID and it would encounter 2 rows and not know\n     * which one to choose to return the variant_index. We will just return the ones that we want to keep by hard coding.\n     * If any checkIsMatching errors get thrown, we can just one by one move users off of the deprecated product variant rows.\n     * Eventually we want to delete the product_variants records that are duplicative\n     *\n     */\n    if (\n        product_href === PRODUCT_HREF.SEMAGLUTIDE &&\n        priceId === 'price_1Phu0tDyFtOu3ZuTiQTyy9kT'\n    ) {\n        //this price ID is shared between variant indexes 1 and 5 in product_variants table. 5 is the one we want people to be on\n        return {\n            variant_index: '5',\n            cadence: 'monthly',\n        };\n    }\n\n    if (\n        product_href === PRODUCT_HREF.SEMAGLUTIDE &&\n        priceId === 'price_1QYPryDyFtOu3ZuTM7ODsRoa'\n    ) {\n        //this priceID is the same for variant indices 15 and 17 in the product_variants table. 15 the one we still offer\n        return {\n            variant_index: '15',\n            cadence: 'biannually',\n        };\n    }\n\n    if (\n        product_href === PRODUCT_HREF.SEMAGLUTIDE &&\n        priceId === 'price_1PMHr4DyFtOu3ZuTwLzYF221'\n    ) {\n        //this priceID is the same for variant indices 3 and 13 in product_variants table. 13 is the one we want people to be on\n        return {\n            variant_index: '13',\n            cadence: 'monthly',\n        };\n    }\n\n    if (\n        product_href === PRODUCT_HREF.TIRZEPATIDE &&\n        priceId === 'price_1QhwigDyFtOu3ZuTU04jMNgV'\n    ) {\n        //product_variants has a different priceID which is incorrect for variant index 9\n        //if that incorrect priceID is passed in, we want to return the correct variant index\n        return {\n            variant_index: '9',\n            cadence: 'quarterly',\n        };\n    }\n\n    if (\n        product_href === PRODUCT_HREF.TIRZEPATIDE &&\n        priceId === 'price_1PQZ3JDyFtOu3ZuTATlJcMKk'\n    ) {\n        //this priceID for 12 and 21 are the same in product_variants table. 21 is hallandale\n        return {\n            variant_index: '21',\n            cadence: 'quarterly',\n        };\n    }\n\n    const supabase = createSupabaseServiceClient();\n    const env = process.env.NEXT_PUBLIC_ENVIRONMENT as Environment; // Explicitly cast to 'dev' | 'prod'\n    const { data, error } = await supabase\n        .from('product_variants')\n        .select('stripe_price_ids,variant_index,cadence')\n        .eq('product_href', product_href)\n        .order('variant_index', { ascending: true });\n\n    if (error) {\n        console.error(\n            'Error while fetching product variant index. Details: ',\n            error.message\n        );\n        return {\n            variant_index: '-1',\n            cadence: 'ErrorFindingCadence',\n        };\n    }\n\n    const filteredVariants = data?.filter(\n        (variant) => variant?.stripe_price_ids?.[env] === priceId\n    );\n\n    if (!filteredVariants) {\n        console.error(\n            `Could not find a variant index for ${priceId} in environment ${env}, but found 0.`\n        );\n        return {\n            variant_index: '-1',\n            cadence: 'ErrorFindingCadence',\n        };\n    }\n\n    if (filteredVariants.length > 1) {\n        console.error(\n            `Found more than one ${product_href} variant indices for ${priceId} in environment ${env}.`\n        );\n        console.error(filteredVariants);\n        return {\n            variant_index: '-1',\n            cadence: 'ErrorFindingCadence',\n        };\n    }\n\n    const variant_index = filteredVariants[0]?.variant_index;\n    const cadence = filteredVariants[0]?.cadence;\n\n    if (variant_index) {\n        return {\n            variant_index: variant_index.toString(),\n            cadence: cadence,\n        };\n    } else {\n        console.log(\n            `variant index for ${priceId} not found in environment ${env}`\n        );\n        return {\n            variant_index: '-1',\n            cadence: 'ErrorFindingCadence',\n        };\n    }\n}"
      },
      {
        "name": "getCheckupQuestionnaireIdForProduct",
        "kind": "function",
        "signature": "export async function getCheckupQuestionnaireIdForProduct(\n    productHref: string\n): Promise<number | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('products')\n        .select('checkup_questionnaire_id')\n        .eq('href', productHref)\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            `Error while fetching checkup questionnaire id for product ${productHref}. Details: ${error.message}`\n        );\n        return null;\n    }\n\n    return data?.checkup_questionnaire_id;\n}"
      },
      {
        "name": "getPriceIdForProductVariant",
        "kind": "function",
        "signature": "export async function getPriceIdForProductVariant(\n    productHref: string,\n    variantIndex: number,\n    environment: string\n): Promise<string | null> {\n    const supabase = createSupabaseServiceClient();\n\n    console.log('productHref', productHref);\n    console.log('variantIndex', variantIndex);\n    console.log('environment', environment);\n\n    const { data, error } = await supabase\n        .from('product_variants')\n        .select('stripe_price_ids')\n        .eq('product_href', productHref)\n        .eq('variant_index', variantIndex)\n        .limit(1);\n\n    if (error) {\n        console.error(\n            `Price ID for product ${productHref} and variant index ${variantIndex} not found in environment ${environment}`\n        );\n        return null;\n    }\n\n    const productVariant = data[0];\n\n    console.log('productVariant', productVariant);\n    if (!productVariant) {\n        console.error(`Product ${productHref} not found`);\n        return null;\n    }\n\n    console.log(\n        'returning price id',\n        productVariant.stripe_price_ids[environment]\n    );\n    return productVariant.stripe_price_ids[environment];\n}"
      },
      {
        "name": "getSingleProductVariantCadence",
        "kind": "function",
        "signature": "export async function getSingleProductVariantCadence(\n    productHref: string,\n    variantIndex: number,\n    environment: string\n): Promise<string | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('product_variants')\n        .select('stripe_price_ids, cadence, variant_index')\n        .eq('product_href', productHref)\n        .eq('variant_index', variantIndex)\n        .limit(1);\n\n    if (error) {\n        console.error(\n            `Error while fetching product variant cadence. Details: ${error.message}`\n        );\n        return null;\n    }\n\n    return data[0]?.cadence;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/products/products.ts",
      "bioverse-client/app/components/collections/pageContents/collection-client-content.tsx",
      "bioverse-client/app/(content)/collections/page.tsx",
      "bioverse-client/app/components/intake-v3/checkout/order-summary-v3/order-summary-v3-ap.tsx",
      "bioverse-client/app/components/intake-v3/checkout/order-summary-v3/new-order-summary.tsx",
      "bioverse-client/app/components/intake-v3/checkout/order-summary-v3/order-summary-v3.tsx",
      "bioverse-client/app/components/intake-v3/checkout/order-summary-v3/wl-order-summary-ab.tsx",
      "bioverse-client/app/components/intake-v3/pages/order-summary-v4/SemaglutideOrderSummary.tsx",
      "bioverse-client/app/components/intake-v3/pages/order-summary-v4/MetforminOrderSummary.tsx",
      "bioverse-client/app/components/intake-v3/pages/pre-id-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/general-order-summary.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-calulating-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/pre-id-v3-ap.tsx",
      "bioverse-client/app/components/intake-v2/checkout/order-summary-v2/order-summary.tsx",
      "bioverse-client/app/components/intake-v2/checkout/order-summary/order-summary.tsx",
      "bioverse-client/app/components/intake-v2/checkout/order-summary/wl-order-summary.tsx",
      "bioverse-client/app/components/intake-v2/checkout/order-summary/new-order-summary.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-calulating.tsx",
      "bioverse-client/app/components/intake-v2/pages/pre-id.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-animated-intro.tsx",
      "bioverse-client/app/components/intake-v2/pages/general-order-summary.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-up-next-preview.tsx",
      "bioverse-client/app/components/intake-v2/pages/pre-id-b.tsx",
      "bioverse-client/app/(testing_and_development)/olivier-dev/utils.ts",
      "bioverse-client/app/utils/functions/formatting.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/custom-prescription-script/custom-prescription-script.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/quarterly-final-review-dialog/quarterly-final-review-dialog-content.tsx",
      "bioverse-client/app/components/patient-portal/dosage-selection-first-time/components/utils.ts",
      "bioverse-client/app/components/patient-portal/dosage-selection-first-time/components/FirstTimeDosingOption.tsx",
      "bioverse-client/app/components/patient-portal/check-up-requested/refill-preference/components/dosage-option.tsx",
      "bioverse-client/app/components/patient-portal/check-up-requested/refill-preference/components/dosage-option-v2.tsx",
      "bioverse-client/app/components/patient-portal/check-up-requested/almost-done/almost-done-screen-v2.tsx",
      "bioverse-client/app/components/patient-portal/check-up-requested/almost-done/almost-done-screen.tsx",
      "bioverse-client/app/components/patient-portal/alternative-selection/weight-loss/alternative-checkout/alt-checkout-summary.tsx",
      "bioverse-client/app/components/patient-portal/alternative-selection/weight-loss/option-selection/option-select-card/option-select-card.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/wl-goal-transition-v3.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/wl-goal-transition.tsx",
      "bioverse-client/app/api/easypost/route.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-graph/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-graph-v3/page.tsx",
      "bioverse-client/app/services/easypost/easypost-tracker.ts",
      "bioverse-client/app/(testing_and_development)/ben-dev/page.tsx",
      "bioverse-client/app/(administration)/admin/stripe-api/stripe-api-actions.ts",
      "bioverse-client/app/utils/database/controller/product_variants/product_variants.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/ChangeOrderInformationDialog.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/ManualOrderCreationDialog.tsx",
      "bioverse-client/app/components/intake-v2/pages/skincare-frequency.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/refill/[subscription_id]/confirm/page.tsx",
      "bioverse-client/app/(patient-portal)/check-up/[product_href]/question/[question_id]/page.tsx",
      "bioverse-client/app/components/intake-v2/ed/medication/medication-details-component.tsx",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/StripeInvoicePaidJobHandler.ts",
      "bioverse-client/app/api/stripe/webhook/invoice-paid/route.ts",
      "bioverse-client/app/services/pharmacy-integration/variant-swap/glp1-stripe-price-id.ts",
      "bioverse-client/app/(patient-portal)/check-up/[product_href]/page.tsx",
      "bioverse-client/app/utils/database/controller/orders/create-order.ts",
      "bioverse-client/app/utils/database/controller/orders/create-manual-order.ts",
      "bioverse-client/app/utils/database/controller/orders/process-manual-order.ts",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/script-view/coordiantor-hallandale-script-view.tsx",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/script-view/coordinator-empower-script-view.tsx",
      "bioverse-client/app/services/pharmacy-integration/util/utils.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/profiles/profiles-database-type.d.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/controller/profiles/profiles.ts",
    "exports": [
      {
        "name": "getIntakeProfileData",
        "kind": "function",
        "signature": "export async function getIntakeProfileData(id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: profilesData, error: profilesError } = await supabase\n        .from('profiles')\n        .select(\n            'first_name, last_name, sex_at_birth, phone_number, stripe_customer_id, intake_completed, text_opt_in, email'\n        )\n        .eq('id', id)\n        .single();\n\n    if (profilesError) {\n        console.log(\n            'Controller tablename: profiles, method: getIntakeProfileData, Error: ',\n            profilesError\n        );\n        return { data: null, error: profilesError };\n    }\n\n    return { data: profilesData, error: null };\n}"
      },
      {
        "name": "getProfileIDFromEmail",
        "kind": "function",
        "signature": "export async function getProfileIDFromEmail(email: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: profilesData, error: profilesError } = await supabase\n        .from('profiles')\n        .select('id')\n        .eq('email', email)\n        .limit(1)\n        .single();\n\n    if (profilesError) {\n        console.log(\n            'Controller tablename: profiles, method: getProfileIDFromEmail, Error: ',\n            profilesError\n        );\n        return { data: null, error: profilesError };\n    }\n\n    return profilesData.id;\n}"
      },
      {
        "name": "getUserFromEmail",
        "kind": "function",
        "signature": "export async function getUserFromEmail(email: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('profiles')\n        .select('*')\n        .eq('email', email)\n        .limit(1)\n        .single();\n\n    if (!data || error) {\n        console.error('could not fetch profile for', email);\n        return null;\n    }\n\n    return data;\n}"
      },
      {
        "name": "getFullIntakeProfileData",
        "kind": "function",
        "signature": "export async function getFullIntakeProfileData(id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: profilesData, error: profilesError } = await supabase\n        .from('profiles')\n        .select(\n            'first_name, last_name, date_of_birth, sex_at_birth, address_line1, address_line2, city, state, zip, phone_number, stripe_customer_id, intake_completed, text_opt_in'\n        )\n        .eq('id', id)\n        .single();\n\n    if (profilesError) {\n        console.log(\n            'Controller tablename: profiles, method: getIntakeProfileData, Error: ',\n            profilesError\n        );\n        return { data: null, error: profilesError };\n    }\n\n    return { data: profilesData, error: null };\n}"
      },
      {
        "name": "getProfileDataForProviderLookup",
        "kind": "function",
        "signature": "export async function getProfileDataForProviderLookup(id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: profilesData, error: profilesError } = await supabase\n        .from('profiles')\n        .select(\n            'id, first_name, last_name, date_of_birth, sex_at_birth, address_line1, address_line2, city, state, zip, phone_number, stripe_customer_id, intake_completed, text_opt_in, email, license_photo_url, selfie_photo_url'\n        )\n        .eq('id', id)\n        .single();\n\n    if (profilesError) {\n        console.log(\n            'Controller tablename: profiles, method: getIntakeProfileData, Error: ',\n            profilesError\n        );\n        return { data: null, error: profilesError };\n    }\n\n    return { data: profilesData as APProfileData, error: null };\n}"
      },
      {
        "name": "updateIntakeCompletedForPatient",
        "kind": "function",
        "signature": "export async function updateIntakeCompletedForPatient(customer_id: string) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { error } = await supabase\n        .from('profiles')\n        .update({ intake_completed: true, intake_completion_time: new Date() })\n        .eq('id', customer_id);\n}"
      },
      {
        "name": "getUserState",
        "kind": "function",
        "signature": "export async function getUserState(id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: profilesData, error: profilesError } = await supabase\n        .from('profiles')\n        .select('state')\n        .eq('id', id)\n        .limit(1)\n        .single();\n\n    if (profilesError) {\n        console.log(\n            'Controller tablename: profiles, method: getIntakeProfileData, Error: ',\n            profilesError\n        );\n        return { state: null, error: profilesError };\n    }\n\n    return { state: profilesData.state, error: null };\n}"
      },
      {
        "name": "getCurrentUserState",
        "kind": "function",
        "signature": "export async function getCurrentUserState() {\n    const supabase = createSupabaseServiceClient();\n\n    const id = (await readUserSession()).data.session?.user.id;\n\n    const { data: profilesData, error: profilesError } = await supabase\n        .from('profiles')\n        .select('state')\n        .eq('id', id)\n        .single();\n\n    if (profilesError) {\n        console.log(\n            'Controller tablename: profiles, method: getIntakeProfileData, Error: ',\n            profilesError\n        );\n        return { state: null, error: profilesError };\n    }\n\n    return { state: profilesData.state, error: null };\n}"
      },
      {
        "name": "getCurrentUserSexAtBirth",
        "kind": "function",
        "signature": "export async function getCurrentUserSexAtBirth() {\n    const supabase = createSupabaseServiceClient();\n\n    const id = (await readUserSession()).data.session?.user.id;\n\n    const { data: profilesData, error: profilesError } = await supabase\n        .from('profiles')\n        .select('sex_at_birth')\n        .eq('id', id)\n        .single();\n\n    if (profilesError) {\n        console.log(\n            'Controller tablename: profiles, method: getIntakeProfileData, Error: ',\n            profilesError\n        );\n        return { sex_at_birth: null, error: profilesError };\n    }\n\n    return { sex_at_birth: profilesData.sex_at_birth, error: null };\n}"
      },
      {
        "name": "getUserName",
        "kind": "function",
        "signature": "export async function getUserName(id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: profilesData, error: profilesError } = await supabase\n        .from('profiles')\n        .select('first_name,last_name')\n        .eq('id', id)\n        .single();\n\n    if (profilesError) {\n        console.log(\n            'Controller tablename: profiles, method: getIntakeProfileData, Error: ',\n            profilesError\n        );\n        return { first_name: null, last_name: null, error: profilesError };\n    }\n\n    return {\n        first_name: profilesData.first_name,\n        last_name: profilesData.last_name,\n        error: null,\n    };\n}"
      },
      {
        "name": "updateUserState",
        "kind": "function",
        "signature": "export async function updateUserState(id: string, state_of_residence: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: profilesData, error: profilesError } = await supabase\n        .from('profiles')\n        .update({ state: state_of_residence })\n        .eq('id', id);\n\n    if (profilesError) {\n        console.log(\n            'Controller tablename: profiles, method: getIntakeProfileData, Error: ',\n            profilesError\n        );\n        return { error: profilesError };\n    }\n\n    // Update state in orders\n    const shippingInformation: ShippingInformation = {\n        address_line1: '',\n        address_line2: '',\n        city: '',\n        zip: '',\n        state: state_of_residence,\n    };\n\n    return { error: null };\n}"
      },
      {
        "name": "updateCurrentUserSexAtBirth",
        "kind": "function",
        "signature": "export async function updateCurrentUserSexAtBirth(sex_at_birth: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const id = (await readUserSession()).data.session?.user.id;\n\n    const { error: profilesError } = await supabase\n        .from('profiles')\n        .update({ sex_at_birth: sex_at_birth })\n        .eq('id', id);\n\n    if (profilesError) {\n        console.log(\n            'Controller tablename: profiles, method: getIntakeProfileData, Error: ',\n            profilesError\n        );\n        return { error: profilesError };\n    }\n\n    return { error: null };\n}"
      },
      {
        "name": "getUserDateOfBirth",
        "kind": "function",
        "signature": "export async function getUserDateOfBirth(id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: profilesData, error: profilesError } = await supabase\n        .from('profiles')\n        .select('date_of_birth')\n        .eq('id', id)\n        .single();\n\n    if (profilesError) {\n        console.log(\n            'Controller tablename: profiles, method: getIntakeProfileData, Error: ',\n            profilesError\n        );\n        return { dob: null, error: profilesError };\n    }\n\n    return { dob: profilesData.date_of_birth, error: null };\n}"
      },
      {
        "name": "updateUserDateOfBirth",
        "kind": "function",
        "signature": "export async function updateUserDateOfBirth(id: string, dob: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const date = new Date(dob);\n    const isoString = date.toISOString();\n\n    const { error: profilesError } = await supabase\n        .from('profiles')\n        .update({ date_of_birth: isoString })\n        .eq('id', id);\n\n    if (profilesError) {\n        console.log(\n            'Controller tablename: profiles, method: getIntakeProfileData, Error: ',\n            profilesError\n        );\n        return { error: profilesError };\n    }\n\n    return { error: null };\n}"
      },
      {
        "name": "getUserIdFromDoseSpotId",
        "kind": "function",
        "signature": "export async function getUserIdFromDoseSpotId(\n    doseSpotId: string\n): Promise<{ id: string | null; error: any | null }> {\n    //This method is accessed in a database controller from server.\n    const supabase = createSupabaseServiceClient();\n\n    const { data: userIdData, error: userIdFetchError } = await supabase\n        .from('profiles')\n        .select('id')\n        .eq('dose_spot_id', doseSpotId)\n        .single();\n\n    if (userIdFetchError) {\n        console.log(\n            'Controller tablename: profiles, method: getUserIdFromDoseSpotId, Error: ',\n            userIdFetchError\n        );\n        return { id: null, error: userIdFetchError };\n    }\n\n    return { id: userIdData.id, error: null };\n}"
      },
      {
        "name": "getPatientHeightColumnValue",
        "kind": "function",
        "signature": "export async function getPatientHeightColumnValue(patient_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('profiles')\n        .select('height')\n        .eq('id', patient_id)\n        .limit(1)\n        .single();\n\n    if (error) {\n        return null;\n    }\n\n    return data.height;\n}"
      },
      {
        "name": "updateStripeCustomerId",
        "kind": "function",
        "signature": "export async function updateStripeCustomerId(stripeId: string, uuid: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: updateData, error: updateError } = await supabase\n        .from('profiles')\n        .update({ stripe_customer_id: stripeId })\n        .eq('id', uuid);\n\n    if (updateError) {\n        console.log(updateError.message);\n        return 'error';\n    } else {\n        return 'success';\n    }\n}"
      },
      {
        "name": "getCustomerStripeId",
        "kind": "function",
        "signature": "export async function getCustomerStripeId(uuid: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('profiles')\n        .select('stripe_customer_id')\n        .eq('id', uuid)\n        .single();\n\n    if (error) {\n        console.log(\n            'Controller tablename: profiles, method: getCustomerStripeId, Error: ',\n            error\n        );\n        return { data: null, error: error };\n    } else {\n        return { data: data, error: null };\n    }\n}"
      },
      {
        "name": "getUserProfile",
        "kind": "function",
        "signature": "export async function getUserProfile(uuid: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('profiles')\n        .select('*')\n        .eq('id', uuid)\n        .single();\n\n    if (error) {\n        console.log(\n            'Controller tablename: profiles, method: getCustomerStripeId, Error: ',\n            error\n        );\n        return null;\n    } else {\n        return data as ProfilesSBR;\n    }\n}"
      },
      {
        "name": "getCustomerIdWithStripeId",
        "kind": "function",
        "signature": "export async function getCustomerIdWithStripeId(stripe_customer_id: string) {\n    //Method accessed by api route\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('profiles')\n        .select('id')\n        .eq('stripe_customer_id', stripe_customer_id)\n        .maybeSingle();\n\n    if (error || !data || !data.id) {\n        console.log(\n            'Controller tablename: profiles, method: getCustomerStripeId, Error: ',\n            error\n        );\n        return { user_id: null, error: error };\n    } else {\n        return { user_id: data.id, error: null };\n    }\n}"
      },
      {
        "name": "getCustomerDemographicInformationById",
        "kind": "function",
        "signature": "export async function getCustomerDemographicInformationById(uuid: string) {\n    //method accessed inside API route for Curexa / GGM\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('profiles')\n        .select(\n            `\n            id,\n            first_name, \n            last_name, \n            date_of_birth, \n            sex_at_birth, \n            address_line1, \n            address_line2,\n            city,\n            state,\n            zip,\n            phone_number,\n            email\n            `\n        )\n        .eq('id', uuid)\n        .maybeSingle();\n\n    if (error) {\n        console.log(\n            'Controller tablename: profiles, method: getCustomerDemographicInformationById, Error: ',\n            error\n        );\n        return { data: null, error: error };\n    } else {\n        return { data: data, error: null };\n    }\n}"
      },
      {
        "name": "getCustomerFirstNameById",
        "kind": "function",
        "signature": "export async function getCustomerFirstNameById(uuid: string) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase\n        .from('profiles')\n        .select('first_name')\n        .eq('id', uuid)\n        .maybeSingle();\n\n    if (!data || error) {\n        console.log(\n            'Controller tablename: profiles, method: getCustomerFirstNameById, Error: ',\n            error\n        );\n        return { first_name: null, error: error };\n    } else {\n        return { first_name: data?.first_name, error: null };\n    }\n}"
      },
      {
        "name": "getAccountProfileData",
        "kind": "function",
        "signature": "export async function getAccountProfileData(uuid: string) {\n    const supabase = createSupabaseServerComponentClient();\n    const { data, error } = await supabase\n        .from('profiles')\n        .select(\n            'first_name, last_name, license_photo_url, selfie_photo_url, address_line1, address_line2, city, state, zip, phone_number, sex_at_birth, date_of_birth'\n        )\n        .eq('id', uuid)\n        .single();\n\n    if (error) {\n        console.log(\n            'Controller tablename: profiles, method: getAccountProfileData, Error: ',\n            error\n        );\n    } else {\n        return data;\n    }\n}"
      },
      {
        "name": "updateProfileData",
        "kind": "function",
        "signature": "export async function updateProfileData(\n    data: AccountNameEmailPhoneData,\n    uuid: string\n) {\n    const supabase = createSupabaseServerComponentClient();\n    // Create an object to hold the fields to update\n\n    const { data: updateData, error: updateError } = await supabase\n        .from('profiles')\n        .update(data)\n        .eq('id', uuid);\n\n    if (updateError) {\n        console.log(\n            'Controller tablename: profiles, method: updateProfileData, Error: ',\n            updateError\n        );\n        return 'error';\n    } else {\n        return 'success';\n    }\n}"
      },
      {
        "name": "updateShippingInformation",
        "kind": "function",
        "signature": "export async function updateShippingInformation(\n    data: ShippingInformation,\n    uuid: string | undefined\n) {\n    if (!uuid) {\n        console.error(\n            'Could not update shipping information - no user id found'\n        );\n        return 'error';\n    }\n    const supabase = createSupabaseServerComponentClient();\n    const { data: updateData, error: updateError } = await supabase\n        .from('profiles')\n        .update({\n            address_line1: data.address_line1,\n            address_line2: data.address_line2,\n            city: data.city,\n            state: data.state,\n            zip: data.zip,\n            personal_data_recently_changed: true,\n        })\n        .eq('id', uuid);\n\n    if (updateError) {\n        console.log(\n            'Controller tablename: profiles, method: updateShippingInformation, Error: ',\n            updateError\n        );\n        return 'error';\n    }\n\n    let order_id: number;\n\n    if (data.product_href === 'weight-loss') {\n        const existing_order_data =\n            await getIncompleteGlobalWLOrderPostHrefSwap(uuid);\n        order_id = existing_order_data?.id ?? 0;\n    } else {\n        const { data: existing_order_data, error: existing_order_check_error } =\n            await checkForExistingOrderV2(uuid, data.product_href || '');\n\n        order_id = existing_order_data?.id;\n    }\n\n    if (order_id && order_id !== 0) {\n        const { data: orderUpdateData, error: orderUpdateError } =\n            await supabase\n                .from('orders')\n                .update({\n                    address_line1: data.address_line1,\n                    address_line2: data.address_line2,\n                    city: data.city,\n                    state: data.state,\n                    zip: data.zip,\n                })\n                .eq('id', order_id);\n\n        if (orderUpdateError) {\n            console.log(\n                'Controller tablename: orders, method: updateShippingInformation, Error: ',\n                orderUpdateError\n            );\n            return 'error';\n        }\n    }\n    return 'success';\n}"
      },
      {
        "name": "updateUserProfileData",
        "kind": "function",
        "signature": "export async function updateUserProfileData(form: ProfileData, id: string) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    //Submit Form information to supabase and update the user profile with specific profile data.\n    const { data, error } = await supabase\n        .from('profiles')\n        .update({\n            updated_at: new Date(),\n            first_name: form.first_name,\n            last_name: form.last_name,\n            ...(form.sex_at_birth ? { sex_at_birth: form.sex_at_birth } : {}),\n            phone_number: form.phone_number,\n            personal_data_recently_changed: true,\n            text_opt_in: form.text_opt_in,\n        })\n        .eq('id', id);\n\n    if (error) {\n        console.error(error);\n        return false;\n    }\n    return true;\n}"
      },
      {
        "name": "updateUserProfileWithPhotoURL",
        "kind": "function",
        "signature": "export async function updateUserProfileWithPhotoURL(\n    userId: string,\n    licensePhotoUrl?: string,\n    selfiePhotoUrl?: string\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    // Create an object to hold the updates\n    const updates: licenseSelfieUpdateObject = {};\n\n    // Add licensePhotoUrl to updates if it exists\n    if (licensePhotoUrl) {\n        updates.license_photo_url = licensePhotoUrl;\n    }\n\n    // Add selfiePhotoUrl to updates if it exists\n    if (selfiePhotoUrl) {\n        updates.selfie_photo_url = selfiePhotoUrl;\n    }\n\n    // Check if there's anything to update\n    if (Object.keys(updates).length === 0) {\n        console.log('No updates to apply.');\n        return;\n    }\n\n    // Perform the update\n    const { data, error } = await supabase\n        .from('profiles')\n        .update(updates)\n        .eq('id', userId);\n\n    if (error) {\n        console.error('Error updating profile:', error);\n        throw error;\n    }\n\n    console.log('Profile updated successfully!', data);\n}"
      },
      {
        "name": "getProfilesCreatedAfterDate",
        "kind": "function",
        "signature": "export async function getProfilesCreatedAfterDate(afterDate: Date) {\n    //method used in Admin portal\n    const supabase = createSupabaseServiceClient();\n\n    const { data: users, error } = await supabase\n        .from('profiles')\n        .select('*')\n        .not('email', 'ilike', '%@test.com')\n        .not('email', 'ilike', '%.test');\n\n    if (error) {\n        console.error(error);\n        return [];\n    }\n\n    const filteredUsers = users.filter(\n        (user) => new Date(user.created_at) > afterDate\n    );\n\n    return filteredUsers;\n}"
      },
      {
        "name": "getProfilesCreatedAfterDateWithFirstName",
        "kind": "function",
        "signature": "export async function getProfilesCreatedAfterDateWithFirstName(\n    afterDate: Date\n) {\n    //method used in admin portal\n    const supabase = createSupabaseServiceClient();\n\n    const { data: users, error } = await supabase\n        .from('profiles')\n        .select('*')\n        .neq('first_name', null)\n        .not('email', 'ilike', '%@test.com')\n        .not('email', 'ilike', '%.test');\n\n    if (error) {\n        console.error(error);\n        return [];\n    }\n\n    const filteredUsers = users.filter(\n        (user) => new Date(user.created_at) > afterDate\n    );\n\n    return filteredUsers;\n}"
      },
      {
        "name": "getSideProfileData",
        "kind": "function",
        "signature": "export async function getSideProfileData(uid: string) {\n    const supabase = await createSupabaseServerComponentClient();\n    const { data, error } = await supabase\n        .from('profiles')\n        .select(\n            'first_name, selfie_photo_url, sex_at_birth, right_side_profile_url,left_side_profile_url'\n        )\n        .eq('id', uid)\n        .single();\n\n    if (!error) {\n        return {\n            selfie: data.selfie_photo_url,\n            name: data.first_name,\n            gender: data.sex_at_birth,\n            rightSideFace: data.right_side_profile_url,\n            leftSideFace: data.left_side_profile_url,\n        };\n    } else {\n        return {\n            license: null,\n            selfie: null,\n            name: null,\n        };\n    }\n}"
      },
      {
        "name": "getIDVerificationData",
        "kind": "function",
        "signature": "export async function getIDVerificationData(uid: string) {\n    const supabase = await createSupabaseServerComponentClient();\n    const { data, error } = await supabase\n        .from('profiles')\n        .select('first_name, license_photo_url, selfie_photo_url, sex_at_birth')\n        .eq('id', uid)\n        .single();\n\n    if (!error) {\n        return {\n            license: data.license_photo_url,\n            selfie: data.selfie_photo_url,\n            name: data.first_name,\n            gender: data.sex_at_birth,\n        };\n    } else {\n        return {\n            license: null,\n            selfie: null,\n            name: null,\n        };\n    }\n}"
      },
      {
        "name": "getShippingInformationData",
        "kind": "function",
        "signature": "export async function getShippingInformationData(\n    user_id: string | undefined\n): Promise<ShippingInformation> {\n    if (!user_id || user_id === '') {\n        return {\n            address_line1: '',\n            address_line2: '',\n            city: '',\n            state: '',\n            zip: '',\n        };\n    }\n\n    const supabase = await createSupabaseServiceClient();\n    const { data, error } = await supabase\n        .from('profiles')\n        .select('address_line1, address_line2, city, state, zip')\n        .eq('id', user_id)\n        .single();\n\n    if (!error) {\n        return {\n            address_line1: data.address_line1,\n            address_line2: data.address_line2,\n            city: data.city,\n            state: data.state,\n            zip: data.zip,\n        };\n    }\n    return {\n        address_line1: '',\n        address_line2: '',\n        city: '',\n        state: '',\n        zip: '',\n    };\n}"
      },
      {
        "name": "getAllProfiles",
        "kind": "function",
        "signature": "export async function getAllProfiles() {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('profiles')\n        .select(\n            'id, first_name, last_name, intake_completion_time, phone_number, state, email, sex_at_birth, date_of_birth, created_at'\n        )\n        .neq('first_name', null)\n        .not('email', 'ilike', '%@test.com')\n        .not('email', 'ilike', '%.test')\n        .limit(100)\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        return { profiles: null, error: error };\n    }\n\n    return { profiles: data, error: null };\n}"
      },
      {
        "name": "searchProfilesUsingValue",
        "kind": "function",
        "signature": "export async function searchProfilesUsingValue(searchValue: string[]) {\n    const supabase = createSupabaseServiceClient();\n\n    // Start with the base query\n    let query = supabase\n        .from('profiles')\n        .select(\n            'id, first_name, last_name, intake_completion_time, phone_number, state, email, sex_at_birth, date_of_birth, created_at'\n        )\n        .neq('first_name', null)\n        .not('email', 'ilike', '%@test.com')\n        .not('email', 'ilike', '%.test')\n        .limit(100);\n\n    // Add an AND condition for each search value\n    searchValue.forEach((value) => {\n        // Escape special characters in the search value\n        const escapedValue = value.replace(/[%_]/g, '\\\\$&');\n\n        // For each search value, any of the fields can match (OR between fields, AND between values)\n        query = query.or(\n            `first_name.ilike.%${escapedValue}%,last_name.ilike.%${escapedValue}%,email.ilike.%${escapedValue}%`\n        );\n    });\n\n    // Add the final ordering\n    const { data, error } = await query.order('created_at', {\n        ascending: false,\n    });\n\n    if (error) {\n        return { profiles: null, error: error };\n    }\n\n    return { profiles: data, error: null };\n}"
      },
      {
        "name": "adminEditAccountInformation",
        "kind": "function",
        "signature": "export async function adminEditAccountInformation(\n    newProfileData: {\n        first_name: string;\n        last_name: string;\n        email: string;\n        phone_number: string;\n        date_of_birth: string;\n    },\n    user_id: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('profiles')\n        .update({\n            ...newProfileData,\n        })\n        .eq('id', user_id);\n\n    if (error) {\n        return { error: error };\n    }\n\n    return { error: null };\n}"
      },
      {
        "name": "adminEditOrderAddressInformation",
        "kind": "function",
        "signature": "export async function adminEditOrderAddressInformation(\n    newAddressData: {\n        address_line1: string;\n        address_line2: string;\n        city: string;\n        state: string;\n        zip: string;\n    },\n    orderData: any,\n    orderType: OrderType\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const originalOrderId =\n        orderType === OrderType.Order\n            ? orderData.id\n            : orderData.original_order_id;\n\n    const user_id =\n        orderType === OrderType.Order\n            ? orderData.customer_uid\n            : orderData.customer_uuid;\n\n    const { data, error } = await supabase\n        .from('orders')\n        .update({\n            ...newAddressData,\n        })\n        .eq('id', originalOrderId);\n\n    if (orderType === OrderType.Order) {\n        await identifyUser(orderData.customer_uid, {\n            stateAddress: newAddressData.state,\n        });\n    }\n\n    if (orderType === OrderType.RenewalOrder) {\n        const latestRenewalOrder =\n            await getLatestRenewalOrderForOriginalOrderId(originalOrderId);\n\n        if (!latestRenewalOrder) {\n            return;\n        }\n\n        const renewalDetails = getOrderStatusDetails(\n            latestRenewalOrder.order_status\n        );\n\n        await identifyUser(latestRenewalOrder.customer_uuid, {\n            stateAddress: newAddressData.state,\n        });\n\n        if (renewalDetails.isPrescribed) {\n            // setting prescription_json to null to force system to regenerate script for new address\n            await updateRenewalOrder(latestRenewalOrder.id, {\n                ...newAddressData,\n                prescription_json: null,\n            });\n        }\n\n        await updateRenewalOrder(latestRenewalOrder.id, { ...newAddressData });\n    }\n\n    await updateProfileData({ ...newAddressData }, user_id);\n\n    // Check if should update for latest renewal order\n    // const { data: renewalOrder, error: renewalOrdersError } = await supabase\n    //     .from('renewal_orders')\n    //     .select('id, order_status')\n    //     .eq('original_order_id', order_id)\n    //     .order('id', { ascending: false })\n    //     .limit(1)\n    //     .maybeSingle();\n\n    // if (renewalOrdersError) {\n    //     console.error(\n    //         'Error getting renewal orders for adminEditOrderAddressInformation',\n    //         order_id,\n    //     );\n    // }\n\n    // if (\n    //     renewalOrder?.order_status !==\n    //         RenewalOrderStatus.CheckupComplete_Prescribed_Unpaid &&\n    //     renewalOrder?.order_status !==\n    //         RenewalOrderStatus.CheckupComplete_Prescribed_Unpaid_1 &&\n    //     renewalOrder?.order_status !==\n    //         RenewalOrderStatus.CheckupComplete_Prescribed_Unpaid_2 &&\n    //     renewalOrder?.order_status !== RenewalOrderStatus.PharmacyProcessing\n    // ) {\n    //     await supabase\n    //         .from('renewal_orders')\n    //         .update({ ...newAddressData })\n    //         .eq('id', renewalOrder?.id);\n    // }\n}"
      },
      {
        "name": "updateCurrentProfileHeight",
        "kind": "function",
        "signature": "export async function updateCurrentProfileHeight(\n    height_in_inches: number,\n    user_id?: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const patient_id =\n        user_id ?? (await readUserSession()).data.session?.user.id;\n\n    const { error } = await supabase\n        .from('profiles')\n        .update({\n            height: height_in_inches,\n        })\n        .eq('id', patient_id);\n\n    if (error) {\n        console.error('updateCurrentProfileHeight', error);\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/macros/macros-api.ts",
      "bioverse-client/app/utils/database/controller/profiles/profiles.ts",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/demographic-collection-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/combined-wl-demographic/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/demographic-wl/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/product-overview/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/demographic-information/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/demographic-wl-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/demographic-collection/page.tsx",
      "bioverse-client/app/(testing_and_development)/olivier-dev/utils.ts",
      "bioverse-client/app/api/renewal/autoship/route.ts",
      "bioverse-client/app/(patient-portal)/dosage-selection/[product]/[variant_index]/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/new-checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v2/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3-abtest/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/ed-checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3-zbp/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/new-checkout/page.tsx",
      "bioverse-client/_deprecated/checkout-test/page.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/patient-container.tsx",
      "bioverse-client/_deprecated/all-patients/[patient_id]/page.tsx",
      "bioverse-client/app/components/intake-v3/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component-ab.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/ed/ed-checkout/ed-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/components/wl-checkout-component-fulltest.tsx",
      "bioverse-client/app/components/intake-v2/checkout/checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/RenewalValidationJobHandler.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/StripeInvoicePaidJobHandler.ts",
      "bioverse-client/app/utils/functions/state-auth/utils.ts",
      "bioverse-client/app/(employee)/(provider-portal)/provider/intakes/[orderId]/page.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/RenewalOrderTabRow.tsx",
      "bioverse-client/app/components/intake-v2/ed/confirmation/ed-confirmation.tsx",
      "bioverse-client/app/components/intake-v2/ed/components/additional-options.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/state-selection/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/state-selection-hers/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/state-selection-v3/page.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/checkbox-v3.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/identify-sex-v3.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/identify-sex.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/checkbox.tsx",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/containers/tab-container.tsx",
      "bioverse-client/app/components/intake-v3/pages/state-selection-v3.tsx",
      "bioverse-client/app/components/intake-v2/pages/state-selection-hers.tsx",
      "bioverse-client/app/components/intake-v2/pages/state-selection.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/what-is-your-sex-v3.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/what-is-your-sex.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/date-of-birth/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/date-of-birth-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/pre-date-of-birth-v3/page.tsx",
      "bioverse-client/app/components/intake-v3/pages/date-of-birth-pre-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/date-of-birth-v3.tsx",
      "bioverse-client/app/components/intake-v2/pages/date-of-birth.tsx",
      "bioverse-client/app/api/dosespot/_event-actions/dose-spot/order-matcher.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-creation-menu/creation-tab-content/bmi-creation.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/invoices-content.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/[subscription_id]/page.tsx",
      "bioverse-client/app/services/stripe/customer.ts",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-supply-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/select-supply-ap/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/select-supply-v3/page.tsx",
      "bioverse-client/app/services/bmg/bmg_functions.ts",
      "bioverse-client/app/api/stripe/webhook/invoice-paid/route.ts",
      "bioverse-client/app/services/pharmacy-integration/curexa/curexa-actions.ts",
      "bioverse-client/app/services/pharmacy-integration/gogomeds/ggm-actions.ts",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/cancel-flow/[subscription_id]/confirm/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/greeting/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/good-news-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-graph/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/greeting-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-graph-v3/page.tsx",
      "bioverse-client/app/(testing_and_development)/dev/mock/subscriptions/[user_id]/page.tsx",
      "bioverse-client/app/(testing_and_development)/dev/mock/order-history/[user_id]/page.tsx",
      "bioverse-client/app/utils/actions/message/message-user.ts",
      "bioverse-client/app/utils/actions/message/message-actions.ts",
      "bioverse-client/app/components/intake-v3/pages/order-summary-v4.tsx",
      "bioverse-client/app/(patient-portal)/portal/account-information/document-upload/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/account-information/id-verification/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/account-information/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/resume/[subscription_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/cancel-flow/[subscription_id]/feedback/[question_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/manage/[subscription_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/order-history/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/questions-v3/[question_id]/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/questions/[question_id]/page.tsx",
      "bioverse-client/_deprecated/chat_old_6.10/testing.tsx",
      "bioverse-client/app/components/patient-portal/account-information/personal-information/account-edit-drawer.tsx",
      "bioverse-client/app/components/intake-v3/pages/demographic-wl-v3.tsx",
      "bioverse-client/app/components/intake-v3/shipping-information/components/components/shipping-information-modal-body-check.tsx",
      "bioverse-client/app/components/intake-v2/shipping-information/components/components/shipping-information-modal-body-check.tsx",
      "bioverse-client/app/components/intake-v3/data-collection/data-collection-wl-input-v4.tsx",
      "bioverse-client/app/components/intake-v3/account/data-collection/data-collection-new.tsx",
      "bioverse-client/app/components/intake-v2/account/data-collection/data-collection-wl.tsx",
      "bioverse-client/app/components/intake-v2/account/data-collection/data-collection.tsx",
      "bioverse-client/app/components/intake-v2/account/data-collection/data-collection-new.tsx",
      "bioverse-client/app/components/intake-v2/account/data-collection/wl-data-collection.tsx",
      "bioverse-client/app/components/patient-portal/account-information/personal-information/photo-edit-drawer.tsx",
      "bioverse-client/app/(administration)/admin/check-progress/_components/number-display.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/skincare-upload/page.tsx",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/IDAndSelfieCheckJobHandler.ts",
      "bioverse-client/app/components/intake-v3/pages/id-verification-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/id-verification-noskip-v3.tsx",
      "bioverse-client/app/(patient-portal)/portal/layout.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/pre-id/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/id-verification-v3-noskip/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/id-verification-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/pre-id-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/pre-id-v3-ap/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/pre-id-v3-post-co/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/pre-id-b/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/id-verification-v3-post-co/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/id-verification/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/shipping-information-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/shipping-information/page.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/page-container.tsx",
      "bioverse-client/_deprecated/all-patients/page.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/info/info-edit-dialog.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/info/reboot-subscription-dialog.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/info/address-edit-dialog.tsx",
      "bioverse-client/app/utils/database/controller/clinical_notes/clinical_notes_v2.ts",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/bmi-v3.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-render/question-rendering-v3.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-render/pre-question-rendering-v3.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/bmi.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-render/question-rendering.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/provider_activity_audit/provider_activity_audit-api.ts",
    "exports": [
      {
        "name": "createNewProviderActivityAudit",
        "kind": "function",
        "signature": "export async function createNewProviderActivityAudit(\n    new_audit_data: ProviderActivityAuditCreateObject\n): Promise<void> {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('provider_activity_audit')\n        .insert(new_audit_data);\n\n    if (error) {\n        console.error(\n            'createNewProviderActivityAudit',\n            error,\n            `new audit data: ${new_audit_data}`\n        );\n    }\n}"
      },
      {
        "name": "getProviderCompletionCount",
        "kind": "function",
        "signature": "export async function getProviderCompletionCount() {\n    const supabase = createSupabaseServiceClient();\n\n    const userId = (await readUserSession()).data.session?.user.id!;\n\n    function getBeginningOfMonth(): string {\n        const now = new Date();\n        const beginningOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);\n        return beginningOfMonth.toISOString();\n    }\n    const beginningOfMonth = getBeginningOfMonth();\n\n    const { count, error } = await supabase\n        .from('provider_activity_audit')\n        .select('*', { count: 'exact', head: true })\n        .eq('provider_id', userId)\n        .in('action', ['prescribe_intake', 'deny_intake'])\n        .gt('created_at', beginningOfMonth);\n\n    if (error) {\n        console.error(error);\n    }\n\n    return count;\n}"
      },
      {
        "name": "getProviderIntakeRenewalCompletionCountBetweenDates",
        "kind": "function",
        "signature": "export async function getProviderIntakeRenewalCompletionCountBetweenDates(\n    providerId: string,\n    start_date: string,\n    end_date: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_provider_intake_renewal_completion_count_with_dates',\n        {\n            provider_id_arg: providerId,\n            start_date_: start_date,\n            end_date_: end_date,\n        }\n    );\n\n    if (error) {\n        console.error(error);\n        return null;\n    }\n\n    return data;\n}"
      },
      {
        "name": "getProviderEstimatedPaymentBetweenDatesV2Verbose",
        "kind": "function",
        "signature": "export async function getProviderEstimatedPaymentBetweenDatesV2Verbose(\n    providerId: string,\n    start_date: number,\n    end_date: number\n) {\n    const supabase = createSupabaseServiceClient();\n\n    //1. new order approval/denial\n    const { count: providerIntakesHandled1, error: intakesHandledError1 } =\n        await supabase\n            .from('provider_activity_audit')\n            .select('*', { count: 'exact', head: true })\n            .eq('provider_id', providerId)\n            .in('action', ['prescribe_intake', 'deny_intake'])\n            .is('renewal_order_id', null)\n            .gt('timestamp', start_date)\n            .lt('timestamp', end_date);\n\n    //2. Curexa intakes handled (separate from above because of dosespot)\n    const { count: providerIntakesHandled2, error: intakesHandledError2 } =\n        await supabase\n            .from('provider_activity_audit')\n            .select('*', { count: 'exact', head: true })\n            .eq('provider_id', providerId)\n            .in('action', ['approve_intake'])\n            .is('renewal_order_id', null)\n            .gt('timestamp', start_date)\n            .lt('timestamp', end_date);\n\n    //3. renewal order approval/denial\n    const { count: providerRenewalsHandled, error: renewalsHandledError } =\n        await supabase\n            .from('provider_activity_audit')\n            .select('*', { count: 'exact', head: true })\n            .eq('provider_id', providerId)\n            .in('action', ['prescribe_intake', 'deny_intake']) //make sure it's final-review?\n            .not('renewal_order_id', 'is', null)\n            .gt('timestamp', start_date)\n            .lt('timestamp', end_date);\n\n    //4. monthly checkins handled\n    const { count: providerCheckinsHandled1, error: checkinsHandledError1 } =\n        await supabase\n            .from('provider_activity_audit')\n            .select('*', { count: 'exact', head: true })\n            .eq('provider_id', providerId)\n            .in('action', ['tag_intake'])\n            .eq('metadata->>previous_status_tag', 'ReviewNoPrescribe')\n            .eq('metadata->>new_status_tag', 'Resolved')\n            .not('renewal_order_id', 'is', null)\n            .gt('timestamp', start_date)\n            .lt('timestamp', end_date);\n\n    //4. overdue monthly checkins handled\n    const { count: providerCheckinsHandled2, error: checkinsHandledError2 } =\n        await supabase\n            .from('provider_activity_audit')\n            .select('*', { count: 'exact', head: true })\n            .eq('provider_id', providerId)\n            .in('action', ['tag_intake'])\n            .eq('metadata->>previous_status_tag', 'OverdueNoPrescribe')\n            .eq('metadata->>new_status_tag', 'Resolved')\n            .gt('timestamp', start_date)\n            .lt('timestamp', end_date);\n\n    //5. Review status tags on renewal orders (monthly checkin)\n    const { count: providerCheckinsHandled3, error: checkinsHandledError3 } =\n        await supabase\n            .from('provider_activity_audit')\n            .select('*', { count: 'exact', head: true })\n            .eq('provider_id', providerId)\n            .in('action', ['tag_intake'])\n            .eq('metadata->>previous_status_tag', 'Review')\n            .eq('metadata->>new_status_tag', 'Resolved')\n            .gt('timestamp', start_date)\n            .lt('timestamp', end_date)\n            .not('renewal_order_id', 'is', null);\n\n    //6. Overdue monthly checkin x 2\n    const { count: providerCheckinsHandled4, error: checkinsHandledError4 } =\n        await supabase\n            .from('provider_activity_audit')\n            .select('*', { count: 'exact', head: true })\n            .eq('provider_id', providerId)\n            .in('action', ['tag_intake'])\n            .eq('metadata->>previous_status_tag', 'Overdue')\n            .eq('metadata->>new_status_tag', 'Resolved')\n            .not('renewal_order_id', 'is', null)\n            .gt('timestamp', start_date)\n            .lt('timestamp', end_date);\n\n    let providerIntakesHandled = 0;\n    if (providerIntakesHandled1) {\n        providerIntakesHandled += providerIntakesHandled1;\n    }\n    if (providerIntakesHandled2) {\n        providerIntakesHandled += providerIntakesHandled2;\n    }\n\n    let providerCheckinsHandled = 0;\n    if (providerCheckinsHandled1) {\n        providerCheckinsHandled += providerCheckinsHandled1;\n    }\n    if (providerCheckinsHandled2) {\n        providerCheckinsHandled += providerCheckinsHandled2;\n    }\n    if (providerCheckinsHandled3) {\n        providerCheckinsHandled += providerCheckinsHandled3;\n    }\n    if (providerCheckinsHandled4) {\n        providerCheckinsHandled += providerCheckinsHandled4;\n    }\n\n    //5. Look for all provider_activity_audit message sent where the previous status tag was ProviderMessage\n    const { count: providerMessagesAnswered, error: messagesAnsweredError } =\n        await supabase\n            .from('provider_activity_audit')\n            .select('*', { count: 'exact', head: true })\n            .eq('provider_id', providerId)\n            .in('action', ['message_intake'])\n            .eq('metadata->>current_status_tag', 'ProviderMessage')\n            .neq('metadata->>last_message_sender', providerId) //don't count sent messages where the provider is the last message sender\n            .gt('timestamp', start_date)\n            .lt('timestamp', end_date);\n\n    const payRates = PROVIDER_PAY_MAP[providerId] || {\n        intake: 0,\n        renewal: 0,\n        message: 0,\n    };\n\n    const intakesHandled = providerIntakesHandled\n        ? providerIntakesHandled * payRates.intake\n        : 0;\n    const renewalsHandled = providerRenewalsHandled\n        ? providerRenewalsHandled * payRates.renewal\n        : 0;\n    const checkinsHandled = providerCheckinsHandled\n        ? providerCheckinsHandled * payRates.renewal\n        : 0;\n    const messagesAnswered = providerMessagesAnswered\n        ? providerMessagesAnswered * payRates.message\n        : 0;\n\n    return {\n        intakesHandled,\n        renewalsHandled,\n        checkinsHandled,\n        messagesAnswered,\n        totalPayInPeriod:\n            intakesHandled +\n            messagesAnswered +\n            renewalsHandled +\n            checkinsHandled,\n    };\n}"
      },
      {
        "name": "getProviderActivityAuditCountsBetweenDates",
        "kind": "function",
        "signature": "export async function getProviderActivityAuditCountsBetweenDates(\n    providerId: string,\n    start_date: number,\n    end_date: number\n) {\n    const supabase = createSupabaseServiceClient();\n\n    //1. new order approval/denial\n    const { count: providerIntakesHandled, error: intakesHandledError } =\n        await supabase\n            .from('provider_activity_audit')\n            .select('*', { count: 'exact', head: true })\n            .eq('provider_id', providerId)\n            .in('action', ['prescribe_intake', 'deny_intake', 'approve_intake'])\n            .is('renewal_order_id', null)\n            .gt('timestamp', start_date)\n            .lt('timestamp', end_date);\n\n    //2. renewal order approval/denial\n    const { count: providerRenewalsHandled, error: renewalsHandledError } =\n        await supabase\n            .from('provider_activity_audit')\n            .select('*', { count: 'exact', head: true })\n            .eq('provider_id', providerId)\n            .in('action', ['prescribe_intake', 'deny_intake'])\n            .not('renewal_order_id', 'is', null)\n            .gt('timestamp', start_date)\n            .lt('timestamp', end_date);\n\n    //3. monthly checkins handled\n    const { count: providerCheckinsHandled1, error: checkinsHandledError1 } =\n        await supabase\n            .from('provider_activity_audit')\n            .select('*', { count: 'exact', head: true })\n            .eq('provider_id', providerId)\n            .in('action', ['tag_intake'])\n            .eq('metadata->>previous_status_tag', 'ReviewNoPrescribe')\n            .eq('metadata->>new_status_tag', 'Resolved')\n            .gt('timestamp', start_date)\n            .lt('timestamp', end_date);\n\n    //4. overdue monthly checkins handled\n    const { count: providerCheckinsHandled2, error: checkinsHandledError2 } =\n        await supabase\n            .from('provider_activity_audit')\n            .select('*', { count: 'exact', head: true })\n            .eq('provider_id', providerId)\n            .in('action', ['tag_intake'])\n            .eq('metadata->>previous_status_tag', 'OverdueNoPrescribe')\n            .eq('metadata->>new_status_tag', 'Resolved')\n            .gt('timestamp', start_date)\n            .lt('timestamp', end_date);\n\n    const { count: providerCheckinsHandled3, error: checkinsHandledError3 } =\n        await supabase\n            .from('provider_activity_audit')\n            .select('*', { count: 'exact', head: true })\n            .eq('provider_id', providerId)\n            .in('action', ['tag_intake'])\n            .eq('metadata->>previous_status_tag', 'Review')\n            .eq('metadata->>new_status_tag', 'Resolved')\n            .gt('timestamp', start_date)\n            .lt('timestamp', end_date)\n            .not('renewal_order_id', 'is', null);\n\n    const { count: providerCheckinsHandled4, error: checkinsHandledError4 } =\n        await supabase\n            .from('provider_activity_audit')\n            .select('*', { count: 'exact', head: true })\n            .eq('provider_id', providerId)\n            .in('action', ['tag_intake'])\n            .eq('metadata->>previous_status_tag', 'Overdue')\n            .eq('metadata->>new_status_tag', 'Resolved')\n            .gt('timestamp', start_date)\n            .lt('timestamp', end_date)\n            .not('renewal_order_id', 'is', null);\n\n    //handling the final checkin in a renewal period where the dosage selection link is sent: \n    const { count: providerCheckinsHandled5, error: checkinsHandledError5 } =\n        await supabase\n            .from('provider_activity_audit')\n            .select('*', { count: 'exact', head: true })\n            .eq('provider_id', providerId)\n            .in('action', ['tag_intake'])\n            .eq('metadata->>previous_status_tag', 'FinalReview')\n            .eq('metadata->>new_status_tag', 'Resolved')\n            .gt('timestamp', start_date)\n            .lt('timestamp', end_date)\n            .not('renewal_order_id', 'is', null);\n\n    let providerCheckinsHandled = 0;\n    if (providerCheckinsHandled1) {\n        providerCheckinsHandled += providerCheckinsHandled1;\n    }\n    if (providerCheckinsHandled2) {\n        providerCheckinsHandled += providerCheckinsHandled2;\n    }\n    if (providerCheckinsHandled3) {\n        providerCheckinsHandled += providerCheckinsHandled3;\n    }\n    if (providerCheckinsHandled4) {\n        providerCheckinsHandled += providerCheckinsHandled4;\n    }\n    if (providerCheckinsHandled5) {\n        providerCheckinsHandled += providerCheckinsHandled5;\n    }\n\n    //5. Look for all provider_activity_audit message sent where the previous status tag was ProviderMessage\n    const { count: providerMessagesAnswered, error: messagesAnsweredError } =\n        await supabase\n            .from('provider_activity_audit')\n            .select('*', { count: 'exact', head: true })\n            .eq('provider_id', providerId)\n            .in('action', ['message_intake'])\n            .in('metadata->>current_status_tag', [\n                'ProviderMessage',\n                'LeadProviderAwaitingResponse',\n                'ReadPatientMessage',\n                'UrgentRequiresProvider'\n            ])\n            .neq('metadata->>last_message_sender', providerId) //don't count sent messages where the provider is the last message sender\n            .gt('timestamp', start_date)\n            .lt('timestamp', end_date);\n\n    //6. Look at all situations where a provider tags an order as \"provider awaiting response\" - this will count \"clarification question messages\"\n    const { count: providerAwaitingResponse, error: awaitingResponseError } =\n        await supabase\n            .from('provider_activity_audit')\n            .select('*', { count: 'exact', head: true })\n            .eq('provider_id', providerId)\n            .in('action', ['tag_intake'])\n            .in('metadata->>previous_status_tag', [\n                'Review', \n                'ReviewNoPrescribe',\n                'FinalReview'\n            ])\n            .eq('metadata->>new_status_tag', 'Provider Awaiting Response')\n            .gt('timestamp', start_date)\n            .lt('timestamp', end_date);\n\n    let providerMessages = 0;\n    if (providerMessagesAnswered) {\n        providerMessages += providerMessagesAnswered;\n    }\n    if (providerAwaitingResponse) {\n        providerMessages += providerAwaitingResponse;\n    }\n\n    // console.log('providerIntakesHandled', providerIntakesHandled);\n    // console.log('providerRenewalsHandled', providerRenewalsHandled);\n    // console.log('providerCheckinsHandled', providerCheckinsHandled);\n    // console.log('providerMessages1: ', providerMessagesAnswered);\n    // console.log('providerMessages2: ', providerAwaitingResponse);\n    return {\n        providerIntakesHandled,\n        providerRenewalsHandled,\n        providerCheckinsHandled,\n        providerMessages,\n    };\n}"
      },
      {
        "name": "getProviderHistoryAuditDetails",
        "kind": "function",
        "signature": "export async function getProviderHistoryAuditDetails(provider_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_provider_history_with_profile',\n        {\n            input_provider_id: provider_id,\n        }\n    );\n\n    if (error) {\n        console.error(error);\n        return null;\n    }\n\n    return data;\n}"
      },
      {
        "name": "getRenewalCheckInCompletionCount",
        "kind": "function",
        "signature": "export async function getRenewalCheckInCompletionCount(\n    providerId: string,\n    start_date: string,\n    end_date: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_provider_check_in_completion_count_with_dates',\n        {\n            provider_id_: providerId,\n            start_date_: start_date,\n            end_date_: end_date,\n        }\n    );\n\n    if (error) {\n        console.error(error);\n        return null;\n    }\n\n    return data;\n}"
      },
      {
        "name": "endSession",
        "kind": "function",
        "signature": "export async function endSession(provider_id: string, endTime?: number) {\n    const supabase = createSupabaseServiceClient();\n\n    const endSessionAuditRecord = {\n        provider_id: provider_id,\n        action: 'end_session',\n        timestamp: endTime ? endTime : new Date().getTime(),\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n        ...(endTime\n            ? { metadata: { source: 'automatic' } }\n            : { metadata: { source: 'manual' } }),\n    };\n\n    const stream = await getProviderSessionRecord(provider_id);\n    if (!stream) {\n        return;\n    }\n\n    if (stream[0]?.action === 'end_session') {\n        return;\n    }\n\n    const { error } = await supabase\n        .from('provider_activity_audit')\n        .insert(endSessionAuditRecord);\n\n    if (error) {\n        console.error('End session error: ', error);\n    }\n}"
      },
      {
        "name": "getProviderIntakeProcessedCount",
        "kind": "function",
        "signature": "export async function getProviderIntakeProcessedCount(\n    start_date: Date,\n    end_date: Date\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc('get_intake_processed_count', {\n        start_date: start_date,\n        end_date: end_date,\n    });\n\n    if (error) {\n        console.error('getProviderIntakeProcessedCount error ', error);\n    }\n\n    return data;\n}"
      },
      {
        "name": "getProviderRenewalProcessedCount",
        "kind": "function",
        "signature": "export async function getProviderRenewalProcessedCount(\n    start_date: Date,\n    end_date: Date\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc('get_renewal_processed_count', {\n        start_date: start_date,\n        end_date: end_date,\n    });\n\n    if (error) {\n        console.error('getProviderRenewalProcessedCount error ', error);\n    }\n\n    return data;\n}"
      },
      {
        "name": "getProviderMessageProcessedCount",
        "kind": "function",
        "signature": "export async function getProviderMessageProcessedCount(\n    start_date: Date,\n    end_date: Date\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc('get_messages_processed_count', {\n        start_date: start_date,\n        end_date: end_date,\n    });\n\n    if (error) {\n        console.error('get_messages_processed_count error ', error);\n    }\n\n    return data;\n}"
      },
      {
        "name": "getAverageIntakeProcessingTime",
        "kind": "function",
        "signature": "export async function getAverageIntakeProcessingTime(\n    start_date: Date,\n    end_date: Date\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_average_intake_processing_time',\n        {\n            start_date: start_date,\n            end_date: end_date,\n        }\n    );\n\n    if (error) {\n        console.error('getAverageIntakeProcessingTime error ', error);\n    }\n\n    return data;\n}"
      },
      {
        "name": "getAverageRenewalProcessingTime",
        "kind": "function",
        "signature": "export async function getAverageRenewalProcessingTime(\n    start_date: Date,\n    end_date: Date\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_average_renewal_processing_time',\n        {\n            start_date: start_date,\n            end_date: end_date,\n        }\n    );\n\n    if (error) {\n        console.error('getAverageRenewalProcessingTime error ', error);\n    }\n\n    return data;\n}"
      },
      {
        "name": "createEmployeeLogoutAudit",
        "kind": "function",
        "signature": "export async function createEmployeeLogoutAudit(\n    employeeId: string,\n    customLogoutTime?: number,\n    metadata?: any,\n    employeeRole?: BV_AUTH_TYPE\n) {\n    let auditTable: string;\n    let idColumn: string;\n    if (\n        employeeRole === BV_AUTH_TYPE.PROVIDER ||\n        employeeRole === BV_AUTH_TYPE.LEAD_PROVIDER ||\n        employeeRole === BV_AUTH_TYPE.ADMIN ||\n        employeeRole === BV_AUTH_TYPE.REGISTERED_NURSE\n    ) {\n        auditTable = 'provider_activity_audit';\n        idColumn = 'provider_id';\n    } else {\n        auditTable = 'coordinator_activity_audit';\n        idColumn = 'coordinator_id';\n    }\n\n    if (employeeId === '6d920c41-4fa8-46c6-94f9-c97e6e3c5219') {\n        //Lara is an admin, but we want to log her to coordinator audit table\n        auditTable = 'coordinator_activity_audit';\n        idColumn = 'coordinator_id';\n    }\n\n    const supabase = createSupabaseServiceClient();\n\n    if (!customLogoutTime) {\n        //if no custom logout time is provided, we will create a new logout audit record right after the last action they took\n        let logOutTime = new Date().getTime();\n\n        const { data: recentAction, error: recentActionError } = await supabase\n            .from(auditTable)\n            .select('*')\n            .eq(idColumn, employeeId)\n            .order('timestamp', { ascending: false })\n            .limit(1)\n            .single();\n\n        if (recentActionError) {\n            console.error('Error fetching recent action:', recentActionError);\n        } else {\n            if (recentAction.action !== 'logged_out') {\n                logOutTime = recentAction.timestamp + 1; //make the logout time right after the last action they took\n            }\n        }\n\n        const employeeLoggedOutAuditRecord = {\n            [idColumn]: employeeId,\n            action: 'logged_out',\n            timestamp: logOutTime,\n            environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n            metadata: metadata,\n        };\n\n        const { error } = await supabase\n            .from(auditTable)\n            .insert(employeeLoggedOutAuditRecord);\n\n        return;\n    } else {\n        // console.log(\"creating a new logout audit record with custom logout time: \", customLogoutTime);\n\n        const employeeLoggedOutAuditRecord = {\n            [idColumn]: employeeId,\n            action: 'logged_out',\n            timestamp: customLogoutTime,\n            environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n            metadata: metadata,\n        };\n\n        const { error } = await supabase\n            .from(auditTable)\n            .insert(employeeLoggedOutAuditRecord);\n\n        return;\n    }\n}"
      },
      {
        "name": "createEmployeeLoginAudit",
        "kind": "function",
        "signature": "export async function createEmployeeLoginAudit(\n    employeeId: string,\n    employeeRole: BV_AUTH_TYPE\n) {\n    let auditTableToUpdate: string;\n    let idColumn: string;\n    if (\n        employeeRole === BV_AUTH_TYPE.PROVIDER ||\n        employeeRole === BV_AUTH_TYPE.LEAD_PROVIDER ||\n        employeeRole === BV_AUTH_TYPE.REGISTERED_NURSE ||\n        employeeRole === BV_AUTH_TYPE.ADMIN\n    ) {\n        auditTableToUpdate = 'provider_activity_audit';\n        idColumn = 'provider_id';\n    } else {\n        auditTableToUpdate = 'coordinator_activity_audit';\n        idColumn = 'coordinator_id';\n    }\n\n    if (employeeId === '6d920c41-4fa8-46c6-94f9-c97e6e3c5219') {\n        //Lara is an admin, but we want to log her to coordinator audit table\n        auditTableToUpdate = 'coordinator_activity_audit';\n        idColumn = 'coordinator_id';\n    }\n\n    const supabase = createSupabaseServiceClient();\n\n    const { data: recentAuthAction, error: recentActionError } = await supabase\n        .from(auditTableToUpdate)\n        .select('*')\n        .eq(idColumn, employeeId)\n        .in('action', ['logged_in', 'logged_out'])\n        .order('timestamp', { ascending: false })\n        .limit(1)\n        .single();\n\n    // console.log(\"recentAuthAction: \", recentAuthAction);\n\n    if (recentActionError) {\n        //if the error is that there are no records, the code will just skip down to creating the new login audit\n        console.error('Error fetching recent action:', recentActionError);\n    } else if (recentAuthAction && recentAuthAction.action === 'logged_in') {\n        //if their most recent auth action was logging in, we will create a logout audit for them right after the last action they took\n        const { data: recentAction, error: recentActionError } = await supabase\n            .from(auditTableToUpdate)\n            .select('*')\n            .eq(idColumn, employeeId)\n            .order('timestamp', { ascending: false })\n            .limit(1)\n            .single();\n\n        //could first check if the most recent action in general was taken was less than 10 minutes ago\n        //if it was, we could just return...we wouldn't create the login/logout audit,\n        //since their most recent auth action was logged_in, so they'll just continue that session!\n        // if (recentAction.timestamp > new Date().getTime() - 10 * 60 * 1000) {\n        //     return;\n        // }\n\n        await createEmployeeLogoutAudit(\n            employeeId,\n            recentAction.timestamp + 1,\n            { source: 'automatic' },\n            employeeRole\n        );\n    }\n\n    //create the new login audit record\n    const employeeLoggedInAuditRecord = {\n        [idColumn]: employeeId,\n        action: 'logged_in',\n        timestamp: new Date().getTime(),\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n    };\n\n    const { error } = await supabase\n        .from(auditTableToUpdate)\n        .insert(employeeLoggedInAuditRecord);\n\n    //log the error to Nathan's log\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/provider_activity_audit/provider_activity_audit-api.ts",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/confirm-prescription-dialog.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/order-charts/components/StatusDropdown.tsx",
      "bioverse-client/app/components/provider-portal/tasks/task-action-page/components/intake-view-task-container.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/belmar/belmar-prescribe-window.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/empower/empower-window-v2.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/hallandale/hallandale-prescribe-window.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/tmc/tmc-window.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/message/message-display.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/intake-view-main-container.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approve-and-prescribe-confirmation-details/dosage-change/dosage-change-component.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approval-buttons.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approve-script-dialog.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/provider-review-ui.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/patient-information/approval-buttons/review-approval-buttons.tsx",
      "bioverse-client/app/components/provider-portal/provider-tracking-window/components/tracking-window.tsx",
      "bioverse-client/app/components/provider-portal/tasks/task-action-page/utils/task-action-data-fetch.ts",
      "bioverse-client/app/utils/functions/provider-portal/time-tracker/provider-time-tracker-functions.ts",
      "bioverse-client/_deprecated/track-hours/provider-time-tracker-content-deprecated.tsx",
      "bioverse-client/app/components/provider-portal/history/provider-history.tsx",
      "bioverse-client/app/utils/database/controller/coordinator_activity_audit/coordinator_activity_audit-api.ts",
      "bioverse-client/app/utils/functions/coordinator-portal/time-tracker/coordinator-time-tracker-functions.ts",
      "bioverse-client/app/components/coordinator-portal/navbar/start-session-button/start-session-button.tsx",
      "bioverse-client/app/components/registered-nurse-portal/nav-bar/registered-nurse-nav-bar.tsx",
      "bioverse-client/app/hooks/useSessionTimeout.ts",
      "bioverse-client/app/layout.tsx",
      "bioverse-client/app/components/admin/task-overview/task-overview-container.tsx",
      "bioverse-client/app/components/coordinator-portal/navbar/coordinator-resources/coordinator-resources-button.tsx",
      "bioverse-client/app/components/provider-portal/nav-bar/start-session-button/start-session-button.tsx",
      "bioverse-client/app/components/provider-portal/nav-bar/provider-resources/provider-resources-button.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/provider_activity_audit/provider_activity_audit.d.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/controller/providers/providers-api.ts",
    "exports": [
      {
        "name": "getProviderLicensedStates",
        "kind": "function",
        "signature": "export async function getProviderLicensedStates(): Promise<USStates[] | null> {\n    const user_id = (await readUserSession()).data.session?.user.id;\n\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('providers')\n        .select('licensed_states')\n        .eq('id', user_id)\n        .single();\n\n    if (error) {\n        return null;\n    }\n\n    return data.licensed_states;\n}"
      },
      {
        "name": "getProviderLicensedStatesWithID",
        "kind": "function",
        "signature": "export async function getProviderLicensedStatesWithID(\n    provider_id: string\n): Promise<USStates[] | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('providers')\n        .select('licensed_states')\n        .eq('id', provider_id)\n        .single();\n\n    if (error) {\n        console.error('getProviderLicensedStatesWithID error ', error);\n        return [];\n    }\n\n    return data.licensed_states;\n}"
      },
      {
        "name": "getProviderDoseSpotIdWithId",
        "kind": "function",
        "signature": "export async function getProviderDoseSpotIdWithId(userId: string) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const { data: doseSpotId, error: doseSpotNotificationError } =\n        await supabase\n            .from('providers')\n            .select('dose_spot_clinician_id')\n            .eq('id', userId)\n            .single();\n\n    if (doseSpotNotificationError) {\n        return null;\n    }\n\n    return doseSpotId.dose_spot_clinician_id;\n}"
      },
      {
        "name": "getCurrentProviderDoseSpotId",
        "kind": "function",
        "signature": "export async function getCurrentProviderDoseSpotId() {\n    const supabase = await createSupabaseServerComponentClient();\n\n    const userId = await getCurrentUserId();\n\n    const { data: doseSpotId, error: doseSpotNotificationError } =\n        await supabase\n            .from('providers')\n            .select('dose_spot_clinician_id')\n            .eq('id', userId)\n            .single();\n\n    if (doseSpotNotificationError) {\n        return null;\n    }\n\n    return doseSpotId.dose_spot_clinician_id;\n}"
      },
      {
        "name": "getProviderFromId",
        "kind": "function",
        "signature": "export async function getProviderFromId(\n    user_id: string\n): Promise<Partial<ProvidersSBR> | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('providers')\n        .select('*')\n        .eq('id', user_id)\n        .limit(1)\n        .single();\n\n    if (error) {\n        console.error('getProviderFromId', error, `user_id: ${user_id}`);\n        return null;\n    }\n\n    return data as ProvidersSBR;\n}"
      },
      {
        "name": "getProviderList",
        "kind": "function",
        "signature": "export async function getProviderList(): Promise<ProviderOption[] | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('providers')\n        .select('id, name')\n        .in('role', ['provider', 'lead-provider']);\n\n    if (error) {\n        console.error('getProviderList', error);\n    }\n\n    return data;\n}"
      },
      {
        "name": "getProviderIntakeCounterAndStates",
        "kind": "function",
        "signature": "export async function getProviderIntakeCounterAndStates(\n    providerId: string\n): Promise<{\n    intake_counter: number | null;\n    licensed_states: USStates[] | null;\n    status: Status;\n}> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('providers')\n        .select('intake_counter, licensed_states')\n        .eq('id', providerId)\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            'getProviderIntakeCounterAndStates error - providerId: ',\n            providerId,\n            ' error message: ',\n            error.message\n        );\n        return {\n            intake_counter: null,\n            licensed_states: null,\n            status: Status.Error,\n        };\n    }\n\n    if (isEmpty(data)) {\n        return {\n            intake_counter: null,\n            licensed_states: null,\n            status: Status.Failure,\n        };\n    }\n\n    return {\n        intake_counter: data.intake_counter,\n        licensed_states: data.licensed_states,\n        status: Status.Success,\n    };\n}"
      },
      {
        "name": "updateProviderIntakeCounter",
        "kind": "function",
        "signature": "export async function updateProviderIntakeCounter(\n    providerId: string,\n    new_count: number\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('providers')\n        .update({ intake_counter: new_count })\n        .eq('id', providerId);\n\n    if (error) {\n        return { status: Status.Error };\n    }\n\n    return { status: Status.Success };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/providers/providers-api.ts",
      "bioverse-client/app/utils/actions/admin/dashboard-scripts.ts",
      "bioverse-client/app/utils/actions/provider/dashboard-scripts.ts",
      "bioverse-client/app/components/provider-portal/messages/components/provider-message-dashboard/provider-message-dashboard.tsx",
      "bioverse-client/app/components/provider-portal/order-table/utils/assigned-order-fetch-helper.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/utils/verify-intake-view-permission.ts",
      "bioverse-client/app/components/registered-nurse-portal/dashboard/utils/rn-dashboard-functions.ts",
      "bioverse-client/app/api/provider-portal/tasks/route.ts",
      "bioverse-client/_deprecated/clinical-intake-flow/order-table/utils/assigned-order-fetch-helper.ts",
      "bioverse-client/app/components/provider-portal/dose-spot-iframe/dose-spot-general-iframe-container.tsx",
      "bioverse-client/app/components/provider-portal/dose-spot-iframe/dose-spot-iframe-container.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/dosespot/dose-spot-general-iframe-container.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/dosespot/dose-spot-iframe-container.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/dosespot/dose-spot-buttons/patient-creation.tsx",
      "bioverse-client/_deprecated/clinical-intake-flow/approval-buttons/dose-spot-patient-creation-button.tsx",
      "bioverse-client/app/utils/actions/provider/provider-dosespot.ts",
      "bioverse-client/app/utils/database/controller/messaging/messages/messages.ts",
      "bioverse-client/app/components/provider-portal/tasks/task-action-page/components/task-action-info-bar.tsx",
      "bioverse-client/app/components/provider-portal/provider-tracking-window/components/tracking-window.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/tab-container.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/utils/post-prescribe-macro-selector/post-prescribe-macro-selector.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/decline-dialog.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/dashboard/page.tsx",
      "bioverse-client/app/components/coordinator-portal/provider-audit/components/provider-list/provider-list.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/providers/providers-type.d.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/controller/questionnaires/questionnaire.ts",
    "exports": [
      {
        "name": "getQADataByQuestionIdAndSessionId",
        "kind": "function",
        "signature": "export async function getQADataByQuestionIdAndSessionId(\n    question_id: number,\n    session_id: number\n): Promise<{\n    question: QUESTIONNAIRE_QUESTIONS_TYPE;\n    answer: QUESTIONNAIRE_ANSWERS_TYPE | undefined;\n} | null> {\n    const supabase = await createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('questionnaire_questions')\n        .select('*')\n        .eq('id', question_id)\n        .single();\n\n    if (error) {\n        console.error('Error getting question data', error);\n        return null;\n    }\n\n    const { data: answer_data, error: answer_error } = await supabase\n        .from('questionnaire_answers')\n        .select('*')\n        .eq('question_id', question_id)\n        .eq('session_id', session_id)\n        .maybeSingle();\n\n    if (answer_error) {\n        console.error('Error getting answer data', answer_error);\n    }\n\n    return { question: data, answer: answer_data ?? undefined };\n}"
      },
      {
        "name": "getQuestionnaireJunctionByQuestionnaireId",
        "kind": "function",
        "signature": "export async function getQuestionnaireJunctionByQuestionnaireId(\n    questionnaire_id: number\n): Promise<QUESTIONNAIRE_JUNCTION_TYPE[] | null> {\n    const supabase = await createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('questionnaire_junction')\n        .select('*')\n        .eq('questionnaire_id', questionnaire_id)\n        .order('priority', { ascending: true });\n\n    if (error) {\n        console.error('Error getting questionnaire data', error);\n        return null;\n    }\n\n    return data as QUESTIONNAIRE_JUNCTION_TYPE[];\n}"
      },
      {
        "name": "getQuestionsForProduct",
        "kind": "function",
        "signature": "export async function getQuestionsForProduct(product_href: string) {\n    const supabase = await createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc('get_questions_for_product', {\n        name: product_href,\n    });\n\n    if (error) {\n        console.error(error, error.message);\n        return null;\n    }\n\n    return data;\n}"
      },
      {
        "name": "getQuestionsForProduct_with_type",
        "kind": "function",
        "signature": "export async function getQuestionsForProduct_with_type(\n    product_href: string,\n    type: any\n) {\n    const supabase = await createSupabaseServiceClient();\n    const { data, error } = await supabase.rpc(\n        'get_questions_for_product_with_type',\n        {\n            name_: product_href,\n            type_: type,\n        }\n    );\n\n    if (error) {\n        console.error(error, error.message);\n        return null;\n    }\n\n    return data;\n}"
      },
      {
        "name": "getQuestionsForProduct_with_Version",
        "kind": "function",
        "signature": "export async function getQuestionsForProduct_with_Version(\n    product_href: string,\n    overrideVersion: number\n) {\n    const supabase = createSupabaseServiceClient();\n\n    if (overrideVersion === 0) {\n        // Fetch the current question set version\n        const { data: version_data, error: version_error } = await supabase\n            .from('products')\n            .select('current_question_set_version')\n            .eq('href', product_href)\n            .single();\n\n        if (version_error || !version_data) {\n            console.error(\n                'Error fetching version data:',\n                version_error || 'No data returned',\n                'Product Href:',\n                product_href\n            );\n            throw new Error('Failed to fetch version data');\n        }\n\n        overrideVersion = version_data.current_question_set_version;\n    }\n\n    if (!overrideVersion) {\n        console.error('Version is undefined or null', overrideVersion);\n        throw new Error('Invalid version number');\n    }\n\n    console.log('OVERRIDE VERSION', overrideVersion);\n\n    // Fetch the questions using the version\n    const { data, error } = await supabase.rpc(\n        'get_questions_for_product_with_version',\n        {\n            name_: product_href,\n            version_: overrideVersion,\n        }\n    );\n\n    console.log(data);\n\n    if (error || !data) {\n        console.error('Error fetching questions:', error || 'No data returned');\n        throw new Error('Failed to fetch questions');\n    }\n\n    console.dir(data);\n    return data;\n}"
      },
      {
        "name": "getQuestionInformation",
        "kind": "function",
        "signature": "export async function getQuestionInformation(\n    user_id: string,\n    product_href: string,\n    question_id: number\n) {\n    const supabase = await createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc('get_question_information', {\n        user_id_: user_id,\n        product_name_: product_href,\n        question_id_: question_id,\n    });\n    console.log('data', data);\n    if (error) {\n        console.error(error, error.message);\n        return null;\n    }\n\n    return data;\n}"
      },
      {
        "name": "getAllPreQuestions",
        "kind": "function",
        "signature": "export async function getAllPreQuestions(\n    product_href: PRODUCT_HREF,\n    vwo_test_id: AB_TESTS_IDS\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const version =\n        VWO_TEST_QUESTIONNAIRES_VERSION_MAPPINGS[product_href]?.[vwo_test_id];\n\n    if (!version) {\n        return null;\n    }\n\n    const { data, error } = await supabase.rpc(\n        'get_pre_questions_for_product_with_version',\n        {\n            name_: product_href,\n            version_: version,\n        }\n    );\n\n    if (error || !data) {\n        console.error(\n            'Error fetching pre questions:',\n            error || 'No data returned'\n        );\n        throw new Error('Failed to fetch pre questions');\n    }\n    return data;\n}"
      },
      {
        "name": "getPreQuestionsForProduct_with_Version",
        "kind": "function",
        "signature": "export async function getPreQuestionsForProduct_with_Version(\n    product_href: PRODUCT_HREF,\n    vwo_test_id: AB_TESTS_IDS\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const version =\n        VWO_TEST_QUESTIONNAIRES_VERSION_MAPPINGS[product_href]?.[vwo_test_id];\n\n    if (!version) {\n        return null;\n    }\n\n    // Fetch the questions using the version\n    const { data, error } = await supabase.rpc(\n        'get_questions_for_product_with_version',\n        {\n            name_: product_href,\n            version_: version,\n        }\n    );\n\n    if (error || !data) {\n        console.error('Error fetching questions:', error || 'No data returned');\n        throw new Error('Failed to fetch questions');\n    }\n    return data;\n}"
      },
      {
        "name": "getLatestAnswerForQuestion",
        "kind": "function",
        "signature": "export async function getLatestAnswerForQuestion(\n    user_id: string,\n    question_id: string\n): Promise<QuestionnaireAnswer | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_latest_answer_for_question'\n    );\n\n    if (error) {\n        console.error(\n            'Error getting latest answer for question',\n            user_id,\n            question_id\n        );\n        return null;\n    }\n\n    if (!data || data.length !== 1) {\n        console.error(\n            'Error occurred while getting the latest answer for question',\n            user_id,\n            question_id\n        );\n        return null;\n    }\n\n    return data[0] as QuestionnaireAnswer;\n}"
      },
      {
        "name": "getPreQuestionInformationWithVersion",
        "kind": "function",
        "signature": "export async function getPreQuestionInformationWithVersion(\n    product_href: PRODUCT_HREF,\n    question_id: number,\n    vwo_test_id: AB_TESTS_IDS\n) {\n    const version =\n        VWO_TEST_QUESTIONNAIRES_VERSION_MAPPINGS[product_href]?.[vwo_test_id];\n\n    if (!version) {\n        return null;\n    }\n\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_pre_question_information_with_version',\n        {\n            product_name_: product_href,\n            question_id_: question_id,\n            version_: version,\n        }\n    );\n\n    if (error) {\n        console.error('Error pulling question', error);\n        return null;\n    }\n\n    return { data, version };\n}"
      },
      {
        "name": "getQuestionInformation_with_version",
        "kind": "function",
        "signature": "export async function getQuestionInformation_with_version(\n    user_id: string,\n    product_name: string, // for checkup: questionnaire_name | for intake: product_href\n    question_id: number,\n    versionOverride: number,\n    isCheckup: boolean = false\n) {\n    try {\n        const supabase = createSupabaseServiceClient();\n\n        let product_href;\n\n        if (isCheckup) {\n            const actionItemInstance = new ActionItemFactory(product_name);\n            product_href = actionItemInstance.getProductHref();\n        } else {\n            product_href = product_name;\n        }\n\n        const { data: version_data, error: version_error } = await supabase\n            .from('products')\n            .select(\n                isCheckup\n                    ? 'checkup_questionnaire_set_version'\n                    : 'current_question_set_version'\n            )\n            .eq('href', product_href)\n            .single();\n\n        if (version_error) {\n            console.error(version_error, version_error.message);\n            return null;\n        }\n\n        if (versionOverride === 0) {\n            versionOverride = isCheckup\n                ? (version_data as { checkup_questionnaire_set_version: any })\n                      .checkup_questionnaire_set_version\n                : (version_data as { current_question_set_version: any })\n                      .current_question_set_version;\n        }\n\n        //**Mock of version 3 for testing new questionnaire */\n        // version = 3;\n        // Ensure version_data is of the expected type\n\n        const { data, error } = await supabase.rpc(\n            'get_question_information_with_version',\n            {\n                user_id_: user_id,\n                product_name_: product_name,\n                question_id_: question_id,\n                version_: versionOverride,\n            }\n        );\n\n        if (error) {\n            console.error(error, error.message);\n            return null;\n        }\n\n        return { data, version: versionOverride };\n    } catch (error) {\n        console.error('Error in QUESTION ID', error);\n        throw error;\n    }\n}"
      },
      {
        "name": "getQuestionInformation_with_type",
        "kind": "function",
        "signature": "export async function getQuestionInformation_with_type(\n    user_id: string,\n    product_href: string,\n    question_id: number,\n    type: any\n) {\n    const supabase = await createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_question_information_with_type',\n        {\n            user_id_: user_id,\n            product_name_: product_href,\n            question_id_: question_id,\n            type_: type,\n        }\n    );\n\n    if (error) {\n        console.error(error, error.message);\n        return null;\n    }\n\n    return data;\n}"
      },
      {
        "name": "writeQuestionnaireAnswer",
        "kind": "function",
        "signature": "export async function writeQuestionnaireAnswer(\n    user_id: string,\n    question_id: number,\n    answer: any,\n    version: number,\n    session_id?: number\n) {\n    const supabase = await createSupabaseServiceClient();\n    const { data, error } = await supabase\n        .from('questionnaire_answers')\n        .upsert(\n            {\n                user_id,\n                question_id,\n                answer,\n                answer_set_version: version,\n                session_id: session_id && session_id > 0 ? session_id : null,\n            },\n            // onConflict specifies which columns form a unique constraint\n            // If a record already exists with matching user_id, question_id, and session_id\n            // the existing record will be updated instead of creating a duplicate\n            {\n                onConflict: 'user_id, question_id, session_id',\n            }\n        )\n        .select();\n\n    if (data && data.length === 0) {\n        console.error(\n            'Error writing answer',\n            user_id,\n            question_id,\n            answer,\n            version,\n            error\n        );\n    }\n\n    if (error) {\n        console.error(error, error.message);\n        return null;\n    }\n    // console.log('questionnaire answer', data);\n\n    return data;\n}"
      },
      {
        "name": "getCheckupQuestionnaireResponse",
        "kind": "function",
        "signature": "export async function getCheckupQuestionnaireResponse(\n    user_id: string\n): Promise<CheckupQuestionnaire[]> {\n    const supabase = await createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_checkup_questionnaire_answers_for_provider',\n        { user_id_: user_id, product_name_: '' }\n    );\n\n    if (error) {\n        console.error(\n            'getCheckupQuestionnaireResponse error',\n            error,\n            error.message\n        );\n        return [];\n    }\n    return data;\n}"
      },
      {
        "name": "writeQuestionnaireAnswerWithVersion",
        "kind": "function",
        "signature": "export async function writeQuestionnaireAnswerWithVersion(\n    user_id: string,\n    question_id: number,\n    answer: any,\n    answer_set_version: string\n) {\n    const supabase = await createSupabaseServiceClient();\n    const { data, error } = await supabase.from('questionnaire_answers').upsert(\n        {\n            user_id,\n            question_id,\n            answer,\n            answer_set_version,\n        },\n        { onConflict: 'user_id, question_id,answer_set_version' }\n    );\n\n    if (error) {\n        console.error(error, error.message);\n        return null;\n    }\n    return data;\n}"
      },
      {
        "name": "writeMultipleQuestionnaireAnswersWithVersion",
        "kind": "function",
        "signature": "export async function writeMultipleQuestionnaireAnswersWithVersion(\n    answers: any[]\n) {\n    const supabase = createSupabaseServiceClient();\n\n    await supabase.from('questionnaire_answers').upsert(answers, {\n        onConflict: 'user_id, question_id,answer_set_version',\n    });\n}"
      },
      {
        "name": "getQuestionnaireResponseForProduct",
        "kind": "function",
        "signature": "export async function getQuestionnaireResponseForProduct(\n    user_id: string,\n    product: string,\n    orderId: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    if (orderId === '1714' || orderId === '1746') {\n        // For the users who completed the questionnaire during the transition period\n        const { data, error } = await supabase.rpc(\n            'get_questionnaire_answers_for_provider',\n            { user_id_: user_id, product_name_: 'semaglutide-deprecated' }\n        );\n        if (error) {\n            console.error(\n                'getQuestionnaireResponseForProduct error',\n                error,\n                error.message\n            );\n            return null;\n        }\n        return data;\n    }\n\n    if (orderId === '1870') {\n        // For the user who did the weightloss flow for metformin, just give them a weightloss questionnaire\n        const { data, error } = await supabase.rpc(\n            'get_questionnaire_answers_for_provider',\n            { user_id_: user_id, product_name_: 'semaglutide' }\n        );\n        if (error) {\n            console.error(\n                'getQuestionnaireResponseForProduct error',\n                error,\n                error.message\n            );\n            return null;\n        }\n        return data;\n    }\n\n    const { data, error } = await supabase.rpc(\n        'get_questionnaire_answers_for_provider',\n        { user_id_: user_id, product_name_: product }\n    );\n    if (error) {\n        console.error(\n            'getQuestionnaireResponseForProduct error',\n            error,\n            error.message\n        );\n        return null;\n    }\n    return data;\n}"
      },
      {
        "name": "getQuestionnaireResponseForProduct_with_version",
        "kind": "function",
        "signature": "export async function getQuestionnaireResponseForProduct_with_version(\n    user_id: string,\n    product: string,\n    version: number\n): Promise<IntakeQuestionnaire[]> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_questionnaire_answers_for_provider_with_version',\n        {\n            user_id_: user_id,\n            product_name_: product as string,\n            version_: version as number,\n        }\n    );\n\n    if (error) {\n        console.log(\n            'getQuestionnaireResponseForProduct error',\n            error,\n            error.message\n        );\n        return [];\n    }\n\n    let hasTooManyNullAnswers =\n        data.filter((answer: any) => answer.answer === null).length > 24;\n    // tech debt ^ need to refactor - WRITTEN IN SOP\n    if (product === PRODUCT_HREF.SEMAGLUTIDE && version === 7) {\n        hasTooManyNullAnswers = false; //tech debt <-- need to delete\n    }\n\n    if (hasTooManyNullAnswers) {\n        if (product === PRODUCT_HREF.SEMAGLUTIDE) {\n            const responses = await handleWrongQuestionSetVersionInOrder(\n                user_id,\n                product,\n                6\n            ); //check new semaglutide question set\n            const stillHasTooManyNullAnswers =\n                responses.filter((answer: any) => answer.answer === null)\n                    .length > 24;\n            if (stillHasTooManyNullAnswers) {\n                const responses = await handleWrongQuestionSetVersionInOrder(\n                    user_id,\n                    product,\n                    3\n                ); //check global wl question set\n                return responses;\n            }\n            return responses;\n        }\n\n        if (product === PRODUCT_HREF.TIRZEPATIDE) {\n            const responses = await handleWrongQuestionSetVersionInOrder(\n                user_id,\n                product,\n                5\n            ); //check new tirz question set\n            const stillHasTooManyNullAnswers =\n                responses.filter((answer: any) => answer.answer === null)\n                    .length > 24;\n            if (stillHasTooManyNullAnswers) {\n                const responses = await handleWrongQuestionSetVersionInOrder(\n                    user_id,\n                    product,\n                    3\n                ); //check global wl question set\n                return responses;\n            }\n            return responses;\n        }\n\n        if (product === PRODUCT_HREF.METFORMIN) {\n            const responses = await handleWrongQuestionSetVersionInOrder(\n                user_id,\n                product,\n                3\n            ); //check new global wl question set\n            return responses;\n        }\n\n        if (product === PRODUCT_HREF.WEIGHT_LOSS) {\n            const responses = await handleWrongQuestionSetVersionInOrder(\n                user_id,\n                product,\n                3 //if the default version of 2 yields no answers, check the newer global wl question set\n            );\n            return responses;\n        }\n        return [];\n    }\n\n    return data;\n}"
      },
      {
        "name": "handleWrongQuestionSetVersionInOrder",
        "kind": "function",
        "signature": "export async function handleWrongQuestionSetVersionInOrder(\n    user_id: string,\n    product: string,\n    version: number\n): Promise<IntakeQuestionnaire[]> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_questionnaire_answers_for_provider_with_version',\n        {\n            user_id_: user_id,\n            product_name_: product as string,\n            version_: version as number,\n        }\n    );\n    if (error) {\n        console.log(\n            'getQuestionnaireResponseForProduct error',\n            error,\n            error.message\n        );\n        return [];\n    }\n\n    return data;\n}"
      },
      {
        "name": "getRenewalQuestionAnswerForProductWithVersion",
        "kind": "function",
        "signature": "export async function getRenewalQuestionAnswerForProductWithVersion(\n    user_id: string,\n    product: string,\n    version: number\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_check_in_questionnaire_answers_for_provider_with_version',\n        {\n            user_id_: user_id,\n            product_name_: product,\n            version_: version,\n        }\n    );\n    if (error) {\n        console.error(\n            'getQuestionnaireResponseForProduct error',\n            error,\n            error.message\n        );\n        return [];\n    }\n\n    return data;\n}"
      },
      {
        "name": "getQuestionAnswerWithQuestionID",
        "kind": "function",
        "signature": "export async function getQuestionAnswerWithQuestionID(\n    /**\n     * @Edit UserID is now an optional parameter, and if it is undefined, I will redefine it to be the current user.\n     * Changed user_id inside of call to questionnaire_answers to use user_id_to_fetch from : which is conditionally the current user.\n     */\n    question_id: string | number,\n    user_id?: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const user_id_to_fetch_from = user_id\n        ? user_id\n        : (await readUserSession()).data.session?.user.id;\n\n    if (!user_id_to_fetch_from) {\n        console.log('no user_id');\n    }\n\n    const { data: answer, error } = await supabase\n        .from('questionnaire_answers')\n        .select('answer')\n        .eq('user_id', user_id_to_fetch_from)\n        .eq('question_id', question_id)\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        console.error(error, error?.message);\n        return { answer: null, error: error };\n    }\n\n    if (!answer) {\n        console.log('No answer');\n        return { answer: null, error: null };\n    }\n\n    return { answer: answer, error: null };\n}"
      },
      {
        "name": "getQuestionAnswerVersionWithQuestionID",
        "kind": "function",
        "signature": "export async function getQuestionAnswerVersionWithQuestionID(\n    /**\n     * @Edit UserID is now an optional parameter, and if it is undefined, I will redefine it to be the current user.\n     * Changed user_id inside of call to questionnaire_answers to use user_id_to_fetch from : which is conditionally the current user.\n     */\n    question_id: string,\n    user_id?: string\n): Promise<number | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const user_id_to_fetch_from = user_id\n        ? user_id\n        : (await readUserSession()).data.session?.user.id;\n\n    const { data, error } = await supabase\n        .from('questionnaire_answers')\n        .select('answer_set_version')\n        .eq('user_id', user_id_to_fetch_from)\n        .eq('question_id', question_id)\n        .order('answer_set_version', { ascending: false })\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        console.error(error, error?.message);\n        return null;\n    }\n\n    return data?.answer_set_version;\n}"
      },
      {
        "name": "getWLGoalAnswer",
        "kind": "function",
        "signature": "export async function getWLGoalAnswer(user_id: string, product_name: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const data = await getQuestionInformation_with_version(\n        user_id,\n        product_name,\n        167,\n        0\n    );\n\n    if (!data || !data.data || !data.data[0]) {\n        console.error('Error pulling WLGoalAnswer', user_id, product_name);\n        return { answer: { answer: 'no-answer' }, error: null };\n    }\n\n    return { answer: data.data[0], error: null };\n}"
      },
      {
        "name": "getCheckupResponses",
        "kind": "function",
        "signature": "export async function getCheckupResponses(\n    user_id: string,\n    product_href: string\n): Promise<CheckupResponse[]> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_checkup_response_for_product_v2',\n        { user_id_: user_id, product_name_: product_href }\n    );\n\n    if (error) {\n        console.error('Error getting checkup responses', error);\n        return [];\n    }\n\n    return data;\n}"
      },
      {
        "name": "getCheckupResponsesWithoutSession",
        "kind": "function",
        "signature": "export async function getCheckupResponsesWithoutSession(\n    user_id: string,\n    product_href: string\n): Promise<CheckupResponse[]> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_product_checkup_response_without_session',\n        { user_id_: user_id, product_name_: product_href }\n    );\n\n    if (error) {\n        console.error('Error getting checkup responses', error);\n        return [];\n    }\n\n    return data;\n}"
      },
      {
        "name": "getAllCheckupResponsesWithSession",
        "kind": "function",
        "signature": "export async function getAllCheckupResponsesWithSession(user_id: string) {\n    const supabase = createSupabaseServiceClient();\n    const action_items = await getAllActionsItemsForPatientWithSession(user_id);\n\n    const session_ids = action_items.map(\n        (item) => item.questionnaire_session_id!\n    );\n\n    if (session_ids.length === 0) {\n        return [];\n    }\n\n    const { data: rpcData, error } = await supabase.rpc(\n        'get_task_view_question_response_from_session_array',\n        { sessions: session_ids }\n    );\n\n    const sessionToRpcDataMap = new Map();\n    rpcData.forEach((item: any) => {\n        if (!sessionToRpcDataMap.has(item.session_id)) {\n            sessionToRpcDataMap.set(item.session_id, []);\n        }\n        sessionToRpcDataMap.get(item.session_id).push(item);\n    });\n\n    if (error) {\n        console.error('Error getting checkup responses', error);\n        return [];\n    }\n\n    function mapRpcDataToResponses(rpcDataItems: any[], actionItem: any) {\n        return rpcDataItems.map((item) => ({\n            question_id: item.question_id,\n            question: {\n                question: item.question.question,\n                options: item.question.options,\n                noneBox: item.question.noneBox,\n                other: item.question.other,\n            },\n            answer: {\n                answer: item.answer.answer,\n                question: item.answer.question,\n                formData: item.answer.formData,\n            },\n        }));\n    }\n\n    const taskViewQuestionDataArray = action_items.map((action_item) => {\n        // Get the RPC data for this action item's session\n        const responses = action_item.questionnaire_session_id\n            ? mapRpcDataToResponses(\n                  sessionToRpcDataMap.get(\n                      action_item.questionnaire_session_id\n                  ) || [],\n                  action_item\n              )\n            : [];\n\n        const convertActionItemType = (type: string) => {\n            const productName = type.split('-')[0];\n            const iteration = type.split('-')[2];\n            return `${\n                productName.charAt(0).toUpperCase() + productName.slice(1)\n            } Check-in #${iteration}`;\n        };\n\n        // Create the TaskViewQuestionData object\n        return {\n            product_name: convertActionItemType(action_item.type),\n            submission_time: action_item.submission_time,\n            responses: responses,\n        };\n    });\n\n    return taskViewQuestionDataArray as TaskViewQuestionData[];\n}"
      },
      {
        "name": "getGLP1Statuses",
        "kind": "function",
        "signature": "export async function getGLP1Statuses(user_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const orders = await getAllGLP1OrdersForProduct(user_id);\n    const renewalOrders = await getAllGLP1RenewalOrdersForProduct(user_id);\n    const subscriptions = await getAllGLP1SubscriptionsForProduct(user_id);\n\n    if (!orders || !renewalOrders || !subscriptions) {\n        return {\n            active_glp1_subscription: false,\n            previously_denied_subscription: false,\n            previously_canceled_subscription: false,\n        };\n    }\n\n    const active_glp1_subscription = subscriptions.some(\n        (subscription) =>\n            subscription.status === SubscriptionStatus.Active ||\n            subscription.status === SubscriptionStatus.Scheduled_Cancel\n    );\n\n    const previously_denied_subscription = [...orders, ...renewalOrders].some(\n        (order) =>\n            [\n                'Denied-Paid',\n                'Denied-Unpaid',\n                'Denied-NoCard',\n                'Denied-CardDown',\n            ].includes(order.order_status)\n    );\n\n    // This function returns true under the following conditions:\n    // 1. If there is only 1 GLP1 subscription found and it has the status of 'canceled'\n    // 2. If multiple GLP1 subscriptions are found, and at least one subscription has a status of 'canceled'\n    const previously_canceled_subscription =\n        (subscriptions.length === 1 &&\n            subscriptions[0].status === SubscriptionStatus.Canceled &&\n            isGLP1Product(subscriptions[0].product_href)) ||\n        (subscriptions.length > 1 &&\n            subscriptions.some(\n                (subscription) =>\n                    isGLP1Product(subscription.product_href) &&\n                    subscription.status === 'canceled'\n            ));\n\n    return {\n        active_glp1_subscription,\n        previously_denied_subscription,\n        previously_canceled_subscription,\n    };\n}"
      },
      {
        "name": "filterCheckupResponses",
        "kind": "function",
        "signature": "export async function filterCheckupResponses(\n    checkupResponses: CheckupResponse[]\n): Promise<CheckupResponse[]> {\n    // Group responses by product_name\n    const groupedResponses: { [key: string]: CheckupResponse[] } = {};\n\n    checkupResponses.forEach((response) => {\n        if (!groupedResponses[response.product_name]) {\n            groupedResponses[response.product_name] = [];\n        }\n        groupedResponses[response.product_name].push(response);\n    });\n\n    // Filter out groups where all answers are null\n    const filteredResponses: CheckupResponse[] = [];\n    for (const product_name in groupedResponses) {\n        const responses = groupedResponses[product_name];\n        const allAnswersNull = responses.every(\n            (response) => response.answer === null || !response.answer\n        );\n        if (!allAnswersNull) {\n            filteredResponses.push(...responses);\n        }\n    }\n\n    return filteredResponses;\n}"
      },
      {
        "name": "categorizeCheckupResponse",
        "kind": "function",
        "signature": "export async function categorizeCheckupResponse(\n    checkupResponses: CheckupResponse[],\n    baseName: string,\n    renewalSubmissionTimes: SubmissionTimes\n): Promise<CheckupResponseReturn[]> {\n    const grouped: GroupedResponses = {};\n\n    // product_name is semaglutide-checkup-0 here\n    checkupResponses.forEach((response) => {\n        if (!grouped[response.product_name]) {\n            grouped[response.product_name] = [];\n        }\n        grouped[response.product_name].push(response);\n    });\n\n    const submittedTimes: any = {};\n\n    // forms submittedTimes object that maps [semaglutide-checkup-0] to submission time\n    for (const [key, value] of Object.entries(renewalSubmissionTimes)) {\n        if (value) {\n            if (!key.includes('-')) {\n                continue;\n            }\n\n            submittedTimes[key] = value;\n        }\n    }\n\n    // Convert the grouped object into an array of objects\n    return Object.keys(grouped).map((product_name: any, index: number) => ({\n        checkup_name: product_name,\n        product_name: renderSelectTitle(baseName, index + 1),\n        responses: grouped[product_name],\n        submission_time: submittedTimes[product_name],\n        index: Number(product_name.charAt(product_name.length - 1)) + 1,\n    }));\n}"
      },
      {
        "name": "getMultipleQuestionInformationWithVersion",
        "kind": "function",
        "signature": "export async function getMultipleQuestionInformationWithVersion(\n    user_id: string,\n    product_href: string,\n    question_ids: number[]\n): Promise<QuestionInformation[]> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: version_data, error: version_error } = await supabase\n        .from('products')\n        .select('current_question_set_version')\n        .eq('href', product_href)\n        .single();\n\n    const version = version_data?.current_question_set_version;\n\n    const { data, error } = await supabase.rpc(\n        'get_multiple_question_information_with_version',\n        {\n            user_id_: user_id,\n            product_name_: product_href,\n            question_ids_: question_ids,\n            version_: version,\n        }\n    );\n\n    if (error) {\n        console.error(\n            'Error getting multiple questions',\n            user_id,\n            question_ids,\n            product_href\n        );\n        return [];\n    }\n\n    return data;\n}"
      },
      {
        "name": "getFirstQuestionAfterPreQuestions",
        "kind": "function",
        "signature": "export async function getFirstQuestionAfterPreQuestions(\n    product_href: PRODUCT_HREF,\n    version: number\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_first_question_after_pre_questions',\n        {\n            name_: product_href,\n            version_: version,\n        }\n    );\n\n    if (error || !data) {\n        console.error(error);\n        return null;\n    }\n\n    return data[0].question_id as number;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/questionnaires/questionnaire.ts",
      "bioverse-client/app/(patient-portal)/check-up/[product_href]/question/[question_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/check-up/[product_href]/page.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/ChangeRefillDate/confirm/ConfirmRefillData.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/ChangeRefillDate/feedback/RefillFeedback.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/CancelSubscription/refill/ChangeRefillOffer.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/CancelSubscription/feedback/CancelFeedbackQuestion.tsx",
      "bioverse-client/app/components/intake-v3/pages/up-next-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/up-next-v3-ap.tsx",
      "bioverse-client/app/components/intake-v3/pages/up-next-v3-wl.tsx",
      "bioverse-client/app/components/intake-v3/pages/question-id-v3.tsx",
      "bioverse-client/app/components/intake-v2/topnav/topnav-v2.tsx",
      "bioverse-client/app/components/intake-v2/topnav/topnav.tsx",
      "bioverse-client/app/components/intake-v2/pages/question-id.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-up-next-profile.tsx",
      "bioverse-client/app/components/intake-v2/pages/skincare-up-next-preview.tsx",
      "bioverse-client/app/components/intake-v2/pages/up-next-health.tsx",
      "bioverse-client/app/components/intake-v2/pages/up-next-id.tsx",
      "bioverse-client/app/components/intake-v2/pages/up-next-4-health.tsx",
      "bioverse-client/app/components/intake-v2/pages/skincare-up-next-id.tsx",
      "bioverse-client/app/components/intake-v2/pages/up-next-3-health.tsx",
      "bioverse-client/app/components/intake-v2/pages/up-next.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-preview-treatment.tsx",
      "bioverse-client/app/components/intake-v2/pages/skincare-up-next-health.tsx",
      "bioverse-client/app/components/intake-v2/pages/good-to-go.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/refill/[subscription_id]/feedback/[question_id]/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/pre-questions/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/questions-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/questions/page.tsx",
      "bioverse-client/_deprecated/check_up_apr_29/checkup-quesiton-swr-script.ts",
      "bioverse-client/app/components/intake-v3/pages/demographic-wl-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/pre-question-id-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/pre-question.tsx",
      "bioverse-client/app/components/patient-portal/check-up/question/CheckupQuestion.tsx",
      "bioverse-client/_deprecated/patient-intakes/[orderId]/page.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/intakes/components/intake-tab-row.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/utils/data-fetch/intake-view-datafetch.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/intakes/components/renewal-intake-tab-row.tsx",
      "bioverse-client/app/utils/actions/questionnaires/questionnaire-actions.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-templates/clinical-template-functions.ts",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/glp-1-side-effects.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/glp-how-long.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/glp-1-dosage-request.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/glp-weekly-dose.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/glp-1-side-effects.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/glp-how-long.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/glp-weekly-dose.tsx",
      "bioverse-client/app/components/intake-v2/questions/functions/questions-functions.ts",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v2/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3-abtest/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/bmi-summary/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-graph/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/whats-next/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-graph-v3/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-checkout-v3-zbp/page.tsx",
      "bioverse-client/_deprecated/checkout-test/page.tsx",
      "bioverse-client/app/components/intake-v3/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component-ab.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/wl-goal-transition-v3.tsx",
      "bioverse-client/app/components/intake-v2/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/wl-goal-transition.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/utils/intake-helpers.ts",
      "bioverse-client/app/(testing_and_development)/dev/devscripts.ts",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/utils/coordinator-task-data-fetch.ts",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-supply/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-supply-v2/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-supply-v3-no-6/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-supply-v3/page.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/questionnaires/questionnaire_sessions.ts",
    "exports": [
      {
        "name": "createQuestionnaireSessionForOrder",
        "kind": "function",
        "signature": "export async function createQuestionnaireSessionForOrder(\n    user_id: string,\n    order_id: number\n) {\n    console.log('creating questionnaire session for order', order_id);\n\n    try {\n        const supabase = createSupabaseServiceClient();\n\n        const { data, error } = await supabase\n            .from('questionnaire_sessions')\n            .insert({\n                user_id,\n                metadata: {\n                    source: 'order',\n                    order_id,\n                },\n            })\n            .select('id')\n            .single();\n\n        if (error) {\n            throw error;\n        }\n\n        const update_order_status = await updateOrder(order_id, {\n            questionnaire_session_id: data.id,\n        });\n\n        if (update_order_status === Status.Failure) {\n            throw new Error('Error updating order');\n        }\n\n        return data.id;\n    } catch (error) {\n        console.error('Error creating questionnaire session', error);\n        return null;\n    }\n}"
      },
      {
        "name": "createQuestionnaireSessionForCheckup",
        "kind": "function",
        "signature": "export async function createQuestionnaireSessionForCheckup(\n    user_id: string,\n    action_item_id: number\n) {\n    try {\n        const supabase = createSupabaseServiceClient();\n\n        const { data, error } = await supabase\n            .from('questionnaire_sessions')\n            .insert({\n                user_id,\n                metadata: {\n                    source: 'checkup',\n                    action_item_id,\n                },\n            })\n            .select('id')\n            .single();\n\n        if (error) {\n            throw error;\n        }\n\n        const update_order_status = await updateActionItem(action_item_id, {\n            questionnaire_session_id: data.id,\n        });\n\n        if (update_order_status === Status.Failure) {\n            throw new Error('Error updating order');\n        }\n\n        return data.id;\n    } catch (error) {\n        console.error('Error creating questionnaire session', error);\n        return null;\n    }\n}"
      },
      {
        "name": "updateSessionCompletion",
        "kind": "function",
        "signature": "export async function updateSessionCompletion(session_id: number) {\n    try {\n        const supabase = createSupabaseServiceClient();\n\n        const { error } = await supabase\n            .from('questionnaire_sessions')\n            .update({ completion_time: new Date().toISOString() })\n            .eq('id', session_id);\n\n        if (error) {\n            throw error;\n        }\n    } catch (error) {\n        console.error('Error updating session completion', error);\n        return;\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/questionnaires/questionnaire_sessions.ts",
      "bioverse-client/app/utils/database/controller/orders/orders-api.ts",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/questions-v3/page.tsx",
      "bioverse-client/app/utils/database/controller/action-items/action-items-actions.ts",
      "bioverse-client/app/(patient-portal)/check-up/[product_href]/page.tsx",
      "bioverse-client/app/components/patient-portal/check-up/question/checkup-question-logic.ts",
      "bioverse-client/app/components/intake-v3/pages/question-id-v3.tsx",
      "bioverse-client/_deprecated/check_up_apr_29/checkup-question-logic-functions.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/questionnaires/supabase_questionnaire_types.d.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/controller/renewal_order_audit/renewal_order_audit.ts",
    "exports": [
      {
        "name": "auditRenewalOrder",
        "kind": "function",
        "signature": "export async function auditRenewalOrder(\n    renewal_order_id: string,\n    error_json: any,\n    error_message: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase.from('renewal_order_audit').insert({\n        renewal_order_id,\n        error_json,\n        error_message,\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n    });\n\n    if (error) {\n        console.error(\n            'Error in Database Controller, filenam: renewal_order_audit.ts, method: auditRenewalOrder, error details: ',\n            error\n        );\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/renewal_order_audit/renewal_order_audit.ts",
      "bioverse-client/app/api/stripe/webhook/invoice-paid/route.ts",
      "bioverse-client/app/services/pharmacy-integration/empower/provider-script-feedback.ts",
      "bioverse-client/app/services/stripe/subscriptions.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/renewal_orders/renewal_orders.ts",
    "exports": [
      {
        "name": "createNewRenewalOrder",
        "kind": "function",
        "signature": "export default async function createNewRenewalOrder(\n    new_order_id: string,\n    order_data: any,\n    subscription_data: any,\n    prescription_json: any,\n    tracking_metadata: any,\n    shipping_data: any\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const renewal_order_values = {\n        renewal_order_id: new_order_id,\n        original_order_id: subscription_data.order_id,\n        customer_uuid: order_data.customer_uid,\n        prescription_json: prescription_json,\n        assigned_pharmacy: subscription_data.assigned_pharmacy,\n        external_tracking_metadata: tracking_metadata,\n        subscription_type: order_data.subscription_type,\n        product_href: order_data.product_href,\n        address_line1: shipping_data.address_line1,\n        address_line2: shipping_data.address_line2 ?? '',\n        city: shipping_data.city,\n        state: shipping_data.state,\n        zip: shipping_data.zip,\n        subscription_id: subscription_data.id,\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n        order_status: RenewalOrderStatus.PharmacyProcessing,\n    };\n\n    const { error } = await supabase\n        .from('renewal_orders')\n        .insert(renewal_order_values);\n\n    return;\n}"
      },
      {
        "name": "createRenewalOrderWithPayload",
        "kind": "function",
        "signature": "export async function createRenewalOrderWithPayload(\n    renewalOrderPayload: Partial<RenewalOrder>\n): Promise<RenewalOrder | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('renewal_orders')\n        .insert(renewalOrderPayload)\n        .select();\n\n    if (error) {\n        console.error(\n            'Error inserting new renewal order with payload',\n            renewalOrderPayload\n        );\n        return null;\n    }\n\n    return data[0] as RenewalOrder;\n}"
      },
      {
        "name": "getRenewalOrderBySubscriptionId",
        "kind": "function",
        "signature": "export async function getRenewalOrderBySubscriptionId(\n    subscription_id: number\n): Promise<RenewalOrder | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('renewal_orders')\n        .select('*')\n        .eq('subscription_id', subscription_id)\n        .order('id', { ascending: false })\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            'Error getting renewal order by subscription_id',\n            subscription_id\n        );\n        return null;\n    }\n\n    return data as RenewalOrder;\n}"
      },
      {
        "name": "getRenewalOrdersForTab",
        "kind": "function",
        "signature": "export async function getRenewalOrdersForTab(\n    customer_id: string\n): Promise<RenewalOrderTabs[]> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_renewal_orders_for_tab_v5',\n        {\n            _customer_id: customer_id,\n        }\n    );\n\n    if (error) {\n        console.error(\n            'Error getting renewal orders for tab',\n            error,\n            customer_id\n        );\n        return [];\n    }\n\n    return data as RenewalOrderTabs[];\n}"
      },
      {
        "name": "createUpcomingRenewalOrderWithRenewalOrderId",
        "kind": "function",
        "signature": "export async function createUpcomingRenewalOrderWithRenewalOrderId(\n    renewal_order_id: string\n) {\n    const latestRenewalOrder = await getRenewalOrder(renewal_order_id);\n\n    if (latestRenewalOrder) {\n        await createUpcomingRenewalOrder(latestRenewalOrder);\n    }\n}"
      },
      {
        "name": "createUpcomingRenewalOrder",
        "kind": "function",
        "signature": "export async function createUpcomingRenewalOrder(\n    oldRenewalOrder: RenewalOrder\n): Promise<RenewalOrder | null> {\n    const supabase = createSupabaseServiceClient();\n\n    // Build new renewal_order_id\n    const splitted_renewal_order_count = parseInt(\n        oldRenewalOrder.renewal_order_id.split('-').at(-1) || '0'\n    );\n\n    if (splitted_renewal_order_count === 0) {\n        console.error(\n            'Error ocurred creating new renewal order',\n            oldRenewalOrder\n        );\n    }\n\n    const new_renewal_order_id = `${oldRenewalOrder.original_order_id}-${\n        splitted_renewal_order_count + 1\n    }`;\n\n    const { data: originalOrder } = await getOrderById(\n        String(oldRenewalOrder.original_order_id)\n    );\n\n    const payload = {\n        product_href: oldRenewalOrder.product_href,\n        original_order_id: oldRenewalOrder.original_order_id,\n        renewal_order_id: new_renewal_order_id,\n        subscription_id: oldRenewalOrder.subscription_id,\n        customer_uuid: oldRenewalOrder.customer_uuid,\n        address_line1: originalOrder.address_line1,\n        address_line2: originalOrder.address_line2,\n        state: originalOrder.state,\n        zip: originalOrder.zip,\n        city: originalOrder.city,\n        subscription_type: oldRenewalOrder.subscription_type,\n        environment: originalOrder.environment,\n        assigned_pharmacy: oldRenewalOrder.assigned_pharmacy,\n        variant_index: oldRenewalOrder.variant_index,\n        ...(oldRenewalOrder.subscription_type ===\n            SubscriptionCadency.Quarterly && {\n            final_review_starts: getFinalReviewStartsDate(),\n        }),\n    };\n\n    const { data: createdRenewal, error } = await supabase\n        .from('renewal_orders')\n        .insert(payload)\n        .select();\n\n    if (error) {\n        console.error(error);\n        console.error('Error creating upcoming renewal order', error);\n        return null;\n    }\n    console.log('Successfully created new renewal order');\n\n    return createdRenewal[0];\n}"
      },
      {
        "name": "createFirstTimeRenewalOrder",
        "kind": "function",
        "signature": "export async function createFirstTimeRenewalOrder(\n    order_id: string,\n    setRenewalCount: boolean = true\n) {\n    const supabase = createSupabaseServiceClient();\n    const { data: orderData, error } = await getOrderById(order_id);\n\n    if (error) {\n        console.error(\n            'Error: Fetching order for creating first time renewal order',\n            order_id\n        );\n        await forwardOrderToEngineering(\n            order_id,\n            null,\n            'Fwd to Engineering: function createFirstTimeRenewalOrder, error: ' +\n                error.message\n        );\n        return null;\n    }\n\n    const payload = {\n        product_href: orderData.product_href,\n        original_order_id: orderData.id,\n        renewal_order_id: `${orderData.id}-1`,\n        subscription_id: orderData.subscription_id,\n        customer_uuid: orderData.customer_uid,\n        address_line1: orderData.address_line1,\n        address_line2: orderData.address_line2,\n        state: orderData.state,\n        zip: orderData.zip,\n        city: orderData.city,\n        subscription_type: orderData.subscription_type,\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT,\n        assigned_pharmacy: orderData.assigned_pharmacy,\n        variant_index: orderData.variant_index,\n        ...(orderData.subscription_type === SubscriptionCadency.Quarterly && {\n            final_review_starts: getFinalReviewStartsDate(),\n        }),\n    };\n\n    const { data: renewalOrder, error: renewalOrderError } = await supabase\n        .from('renewal_orders')\n        .insert(payload)\n        .select()\n        .single();\n\n    if (setRenewalCount) {\n        await supabase\n            .from('prescription_subscriptions')\n            .update({ renewal_count: 1 })\n            .eq('id', orderData.subscription_id);\n    }\n\n    return renewalOrder;\n}"
      },
      {
        "name": "dateDiffInMonths",
        "kind": "function",
        "signature": "export async function dateDiffInMonths(date1: Date, date2: Date) {\n    var diffMillis = Math.abs(date2.getTime() - date1.getTime());\n\n    var diffDays = diffMillis / (1000 * 60 * 60 * 24);\n\n    // Note: This is a simplification and may not perfectly align with real-world calendars\n    return Math.round(diffDays / 30.44);\n}"
      },
      {
        "name": "getRenewalOrdersForPatient",
        "kind": "function",
        "signature": "export async function getRenewalOrdersForPatient(\n    patient_id: string\n): Promise<OrderItem[]> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_renewal_orders_for_patient',\n        { customer_id: patient_id }\n    );\n\n    if (error) {\n        console.error('Error getting renewal orders for patient', error);\n        return [];\n    }\n\n    return data as OrderItem[];\n}"
      },
      {
        "name": "getLatestRenewalOrderByCustomerAndProduct",
        "kind": "function",
        "signature": "export async function getLatestRenewalOrderByCustomerAndProduct(\n    user_id: string,\n    product_href: string\n): Promise<RenewalOrder | null> {\n    const orderId = await getOrderIdByPatientIdAndProductHref(\n        user_id,\n        product_href\n    );\n\n    if (!orderId) {\n        console.log(\"no order id found for user's product\");\n        return null;\n    }\n\n    console.log('order id', orderId);\n    const renewalOrder = await getLatestRenewalOrderForOriginalOrderId(orderId);\n\n    return renewalOrder;\n}"
      },
      {
        "name": "getLatestRenewalOrderForOriginalOrderId",
        "kind": "function",
        "signature": "export async function getLatestRenewalOrderForOriginalOrderId(\n    original_order_id: string\n): Promise<RenewalOrder | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('renewal_orders')\n        .select('*')\n        .eq('original_order_id', original_order_id)\n        .order('id', { ascending: false })\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            'Error getting latest renewal orders for subscription',\n            original_order_id,\n            error\n        );\n        return null;\n    }\n\n    return data as RenewalOrder;\n}"
      },
      {
        "name": "getAllRenewalOrdersForOriginalOrderId",
        "kind": "function",
        "signature": "export async function getAllRenewalOrdersForOriginalOrderId(\n    original_order_id: string\n): Promise<RenewalOrder[]> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('renewal_orders')\n        .select('*')\n        .eq('original_order_id', original_order_id)\n        .order('id', { ascending: true });\n\n    if (error) {\n        console.error(\n            'Error getting latest renewal orders for subscription',\n            original_order_id,\n            error\n        );\n        return [];\n    }\n\n    return data as RenewalOrder[];\n}"
      },
      {
        "name": "getLatestRenewalOrderWithVariant",
        "kind": "function",
        "signature": "export async function getLatestRenewalOrderWithVariant(\n    original_order_id: string\n): Promise<RenewalOrder | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('renewal_orders')\n        .select('*')\n        .eq('original_order_id', original_order_id)\n        .not('variant_index', 'is', null) // Filter where variant_index is not null\n        .not('variant_index', 'eq', -1) // Filter where variant_index is not -1\n        .order('created_at', { ascending: false }) // Order by most recent\n        .limit(1); // We only need the latest order\n\n    if (error) {\n        console.error(\n            'Error getting latest renewal order with variant for original_order_id',\n            original_order_id,\n            error\n        );\n        return null;\n    }\n\n    // If no matching data found, return null\n    if (!data || data.length === 0) {\n        return null;\n    }\n\n    // Return the latest renewal order with a valid variant_index\n    return data[0] as RenewalOrder;\n}"
      },
      {
        "name": "getLatestRenewalOrderForSubscription",
        "kind": "function",
        "signature": "export async function getLatestRenewalOrderForSubscription(\n    subscription_id: number\n): Promise<RenewalOrder | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('renewal_orders')\n        .select('*')\n        .eq('subscription_id', subscription_id)\n        .order('id', { ascending: false })\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            'Error getting latest renewal orders for subscription',\n            subscription_id,\n            error\n        );\n        return null;\n    }\n\n    return data as RenewalOrder;\n}"
      },
      {
        "name": "getLatestRenewalOrderForSubscriptionThatWasSent",
        "kind": "function",
        "signature": "export async function getLatestRenewalOrderForSubscriptionThatWasSent(\n    subscription_id: number\n): Promise<RenewalOrder | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('renewal_orders')\n        .select('*')\n        .eq('subscription_id', subscription_id)\n        .eq('order_status', RenewalOrderStatus.PharmacyProcessing)\n        .order('id', { ascending: false })\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        console.error(\n            'Error getting latest renewal orders for subscription',\n            subscription_id,\n            error\n        );\n        return null;\n    }\n\n    return data as RenewalOrder;\n}"
      },
      {
        "name": "getLatestProcessedOrderGeneral",
        "kind": "function",
        "signature": "export async function getLatestProcessedOrderGeneral(\n    renewal_order_id: string | undefined\n) {\n    console.log('renewal', renewal_order_id);\n    if (!renewal_order_id) {\n        return { lastOrderSent: null, lastOrderSentType: OrderType.Order };\n    }\n\n    const [baseOrderId, renewalOrderLevel] =\n        extractRenewalOrderId(renewal_order_id);\n\n    console.log(renewalOrderLevel);\n\n    let lastOrderSent: BaseOrderInterface | RenewalOrder | null;\n    let lastOrderSentType: OrderType;\n\n    if (renewalOrderLevel === 1) {\n        lastOrderSent = await getBaseOrderById(baseOrderId);\n        lastOrderSentType = OrderType.Order;\n    }\n\n    lastOrderSent = await getLatestProcessedRenewalOrder(baseOrderId);\n    lastOrderSentType = lastOrderSent\n        ? OrderType.RenewalOrder\n        : OrderType.Order;\n\n    if (!lastOrderSent) {\n        lastOrderSent = await getBaseOrderById(baseOrderId);\n    }\n\n    return { lastOrderSent, lastOrderSentType };\n}"
      },
      {
        "name": "getLatestProcessedRenewalOrder",
        "kind": "function",
        "signature": "export async function getLatestProcessedRenewalOrder(\n    original_order_id: number\n): Promise<RenewalOrder> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_last_processed_renewal_order',\n        {\n            original_order_id_: original_order_id,\n        }\n    );\n\n    if (error) {\n        throw new Error(error.message);\n    }\n\n    if (!data) {\n        throw new Error(\"Couldn't find data\");\n    }\n\n    return data[0] as RenewalOrder;\n}"
      },
      {
        "name": "getLatestOrderForSubscriptionThatWasSent",
        "kind": "function",
        "signature": "export async function getLatestOrderForSubscriptionThatWasSent(\n    subscription_id: number\n) {\n    const latestRenewalOrder =\n        await getLatestRenewalOrderForSubscriptionThatWasSent(subscription_id);\n    if (latestRenewalOrder) {\n        return latestRenewalOrder;\n    }\n\n    const subscription = await getPrescriptionSubscription(subscription_id);\n    if (!subscription) {\n        return null;\n    }\n    const order = await getBaseOrderById(subscription.order_id);\n    if (order?.order_status !== OrderStatus.ApprovedCardDownFinalized) {\n        return null;\n    }\n    return order;\n}"
      },
      {
        "name": "updateRenewalOrderStatus",
        "kind": "function",
        "signature": "export async function updateRenewalOrderStatus(\n    renewal_order_id: number,\n    new_order_status: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('renewal_orders')\n        .update({ order_status: new_order_status })\n        .eq('id', renewal_order_id);\n\n    if (error) {\n        console.error(\n            'Error updating renewal order order_status',\n            error,\n            renewal_order_id\n        );\n    }\n}"
      },
      {
        "name": "updateRenewalOrderFromRenewalOrderId",
        "kind": "function",
        "signature": "export async function updateRenewalOrderFromRenewalOrderId(\n    renewal_order_id: string,\n    updated_payload: Partial<RenewalOrder>\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('renewal_orders')\n        .update(updated_payload)\n        .eq('renewal_order_id', renewal_order_id);\n\n    if (error) {\n        console.error(\n            'Error updating renewal order order_status',\n            error,\n            renewal_order_id\n        );\n    }\n}"
      },
      {
        "name": "updateRenewalOrder",
        "kind": "function",
        "signature": "export async function updateRenewalOrder(\n    id: number,\n    updated_payload: Partial<RenewalOrder>\n): Promise<Status> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('renewal_orders')\n        .update(updated_payload)\n        .eq('id', id);\n\n    if (error) {\n        console.error('Error updating renewal order order_status', error, id);\n        return Status.Failure;\n    }\n    return Status.Success;\n}"
      },
      {
        "name": "updateRenewalOrderByRenewalOrderId",
        "kind": "function",
        "signature": "export async function updateRenewalOrderByRenewalOrderId(\n    renewal_order_id: string,\n    updated_payload: Partial<RenewalOrder | any>\n): Promise<{ status: Status; data: RenewalOrder | null }> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('renewal_orders')\n        .update(updated_payload)\n        .eq('renewal_order_id', renewal_order_id)\n        .select();\n\n    if (error) {\n        console.error(\n            'Error updating renewal order order_status',\n            error,\n            renewal_order_id\n        );\n        return { status: Status.Failure, data: null };\n    }\n\n    if (!data || !data[0]) {\n        return { status: Status.Failure, data: null };\n    }\n    return { status: Status.Success, data: data[0] };\n}"
      },
      {
        "name": "getAllRenewalOrdersForProviderOrderTable",
        "kind": "function",
        "signature": "export async function getAllRenewalOrdersForProviderOrderTable(): Promise<\n    RenewalOrderProviderOverview[]\n> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_all_renewal_orders_for_provider_overview',\n        {\n            environment_: process.env.NEXT_PUBLIC_ENVIRONMENT,\n        }\n    );\n\n    if (error) {\n        console.error(\n            'Error retreiving renewal orders for provider overview table',\n            error\n        );\n        return [];\n    }\n    return data as RenewalOrderProviderOverview[];\n}"
      },
      {
        "name": "getAllRenewalOrdersForProviderOrderTablev2",
        "kind": "function",
        "signature": "export async function getAllRenewalOrdersForProviderOrderTablev2(): Promise<\n    RenewalOrderProviderOverview[]\n> {\n    const supabase = createSupabaseServiceClient();\n    const { data, error } = await supabase.rpc(\n        'get_all_renewal_orders_for_provider_overview_v2',\n        {\n            environment_: process.env.NEXT_PUBLIC_ENVIRONMENT,\n        }\n    );\n    if (error) {\n        console.error(\n            'Error retreiving renewal orders for provider overview table',\n            error\n        );\n        return [];\n    }\n\n    return data as RenewalOrderProviderOverview[];\n}"
      },
      {
        "name": "getNextRenewalOrderForTaskQueue",
        "kind": "function",
        "signature": "export async function getNextRenewalOrderForTaskQueue(\n    licensed_states: USStates[],\n    environment_override: boolean = false,\n    assigned_provider: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_next_renewal_for_task_queue_and_assign',\n        {\n            environment_: environment_override\n                ? 'dev'\n                : process.env.NEXT_PUBLIC_ENVIRONMENT,\n            licensed_states_: licensed_states,\n            provider_id_: assigned_provider,\n        }\n    );\n\n    if (error) return { error: error, data: null };\n\n    return { data: data[0] as TaskRenewalObject, error: null };\n}"
      },
      {
        "name": "getAllRenewalOrdersForTaskQueue",
        "kind": "function",
        "signature": "export async function getAllRenewalOrdersForTaskQueue(\n    licensed_states: USStates[]\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_all_renewal_orders_for_task_queue_v2',\n        {\n            environment_: process.env.NEXT_PUBLIC_ENVIRONMENT,\n            licensed_states_: licensed_states,\n        }\n    );\n\n    if (error) {\n        console.error('Error retreiving renewal orders for task queue', error);\n        return { error: error, data: null };\n    }\n\n    return { data: data, error: null };\n}"
      },
      {
        "name": "getAllTaskQueueTotaRenewalOrderCount",
        "kind": "function",
        "signature": "export async function getAllTaskQueueTotaRenewalOrderCount() {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_renewal_orders_count_for_task_queue',\n        {\n            environment_: process.env.NEXT_PUBLIC_ENVIRONMENT,\n        }\n    );\n\n    if (error) return { error: error, data: null };\n\n    return { data: data, error: null };\n}"
      },
      {
        "name": "getAssignedRenewalOrdersForProviderOrderTable",
        "kind": "function",
        "signature": "export async function getAssignedRenewalOrdersForProviderOrderTable(\n    user_id: string\n): Promise<RenewalOrderProviderOverview[]> {\n    const supabase = createSupabaseServiceClient();\n    const { data, error } = await supabase.rpc(\n        'get_assigned_renewal_orders_for_provider_overview',\n        {\n            environment_: process.env.NEXT_PUBLIC_ENVIRONMENT,\n            provider_id_: user_id,\n        }\n    );\n    if (error) {\n        console.error(\n            'Error retreiving renewal orders for provider overview table',\n            error\n        );\n        return [];\n    }\n\n    return data as RenewalOrderProviderOverview[];\n}"
      },
      {
        "name": "getAllRenewalOrdersForCoordinatorOrderTable",
        "kind": "function",
        "signature": "export async function getAllRenewalOrdersForCoordinatorOrderTable(): Promise<\n    RenewalOrderCoordinatorOverview[]\n> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_all_renewal_orders_for_coordinator_dashboardv2',\n        {\n            environment_: process.env.NEXT_PUBLIC_ENVIRONMENT,\n        }\n    );\n\n    if (error) {\n        console.error(\n            'Error retreiving renewal orders for coordinator dashboard table',\n            error\n        );\n        return [];\n    }\n\n    return data as RenewalOrderCoordinatorOverview[];\n}"
      },
      {
        "name": "getLastCompleteOrderForOriginalOrderId",
        "kind": "function",
        "signature": "export async function getLastCompleteOrderForOriginalOrderId(\n    original_order_id: number\n) {\n    const renewalOrders = await getAllRenewalOrdersForOriginalOrderId(\n        String(original_order_id)\n    );\n\n    if (renewalOrders.length <= 1) {\n        const orderData = await getBaseOrderById(original_order_id);\n\n        if (!orderData) {\n            return { orderData: null, orderType: null };\n        }\n\n        return { orderData, orderType: OrderType.Order };\n    }\n    return {\n        orderData: renewalOrders[renewalOrders.length - 2] as RenewalOrder,\n        orderType: OrderType.RenewalOrder,\n    };\n}"
      },
      {
        "name": "getAllRenewalOrdersForAdminOrderTable",
        "kind": "function",
        "signature": "export async function getAllRenewalOrdersForAdminOrderTable(): Promise<\n    RenewalOrderProviderOverview[]\n> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'getallrenewalordersadmintable',\n        { environment_: process.env.NEXT_PUBLIC_ENVIRONMENT }\n    );\n\n    if (error) {\n        console.error(\n            'Error retreiving renewal orders for admin overview table',\n            error\n        );\n        return [];\n    }\n\n    return data as RenewalOrderProviderOverview[];\n}"
      },
      {
        "name": "getRenewalOrderForPatientIntake",
        "kind": "function",
        "signature": "export async function getRenewalOrderForPatientIntake(\n    orderId: string\n): Promise<Partial<RenewalOrder>> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('renewal_orders')\n        .select(\n            `\n          *,\n          patient:profiles!customer_uuid (\n            first_name,\n            last_name\n          ),\n          product:products!product_href (\n            name\n          ),\n          order:orders!original_order_id (\n            assigned_provider,\n            address_line1,\n            address_line2,\n            state,\n            zip,\n            city,\n            question_set_version,\n            variant_text,\n            variant_index\n          ),\n          subscription:prescription_subscriptions!subscription_id (\n            stripe_subscription_id\n          )\n      `\n        )\n        .eq('renewal_order_id', orderId)\n        .single();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: orders, method: getOrderById, error: ',\n            error\n        );\n        return {};\n    }\n\n    return data;\n}"
      },
      {
        "name": "getRenewalOrder",
        "kind": "function",
        "signature": "export async function getRenewalOrder(\n    renewal_order_id: string\n): Promise<RenewalOrder | null> {\n    const supabase = createSupabaseServiceClient();\n\n    if (!renewal_order_id) {\n        return null;\n    }\n\n    const { data, error } = await supabase\n        .from('renewal_orders')\n        .select('*')\n        .eq('renewal_order_id', renewal_order_id)\n        .maybeSingle();\n\n    if (error) {\n        console.error('Could not retrieve renewal order for', renewal_order_id);\n        return null;\n    }\n    return data;\n}"
      },
      {
        "name": "getRenewalSubmissionTimes",
        "kind": "function",
        "signature": "export async function getRenewalSubmissionTimes(\n    user_id: string,\n    product_href: string\n): Promise<SubmissionTimes> {\n    const supabase = createSupabaseServiceClient();\n\n    async function transformArrayToObject(\n        arr: any[]\n    ): Promise<SubmissionTimes> {\n        const result: SubmissionTimes = {};\n\n        arr.forEach(async (item: any) => {\n            if (!item.order_label.includes('checkup')) {\n                const createdAt = await getFirstCompletedOrderCreatedDate(\n                    user_id,\n                    product_href\n                );\n                result[item.order_label] = createdAt;\n            } else {\n                result[item.order_label] = item.submission_time;\n            }\n        });\n        return result;\n    }\n\n    const { data, error } = await supabase.rpc(\n        'get_renewal_submission_times_v2',\n        {\n            user_id_: user_id,\n            product_href_: product_href,\n        }\n    );\n\n    if (error) {\n        console.error('Error retrieving renewal submission times', error);\n        return {};\n    }\n    return await transformArrayToObject(data);\n}"
      },
      {
        "name": "administrativeCancelRenewalOrder",
        "kind": "function",
        "signature": "export async function administrativeCancelRenewalOrder(\n    renewal_order_id: string,\n    reason: string,\n    subscription_id: number,\n    stripe_subscription_id: string,\n    userId: string\n): Promise<Status> {\n    await updateRenewalOrderFromRenewalOrderId(renewal_order_id, {\n        order_status: RenewalOrderStatus.Administrative_Canceled,\n    });\n\n    await insertAuditIntoAdministrativeCancelTable(renewal_order_id, reason);\n\n    const subscription = await getStripeSubscription(stripe_subscription_id);\n\n    const { success } = await safeCancelSubscription(\n        subscription,\n        subscription_id,\n        true\n    );\n\n    if (success) {\n        await triggerEvent(userId, ORDER_CANCELED, {\n            order_id: renewal_order_id,\n        });\n    }\n\n    if (!success) {\n        console.error(\n            'Error: Failed to administratively cancel subscription for order',\n            renewal_order_id,\n            reason,\n            subscription_id\n        );\n        return Status.Failure;\n    }\n    return Status.Success;\n}"
      },
      {
        "name": "isRenewalOrder",
        "kind": "function",
        "signature": "export async function isRenewalOrder(order_id: string, pharmacy: string) {\n    // Is a renewal order if it contains a hyphen in the order_id (applies to all BUT gogomeds)\n\n    const numHyphens = countHyphens(order_id as string);\n\n    if (pharmacy === EASYPOST_PHARMACIES.GOGO_MEDS) {\n        return numHyphens >= 2;\n    }\n\n    return numHyphens >= 1;\n}"
      },
      {
        "name": "getRenewalListForIntakesTabAllPatients",
        "kind": "function",
        "signature": "export async function getRenewalListForIntakesTabAllPatients(\n    patient_id: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('renewal_orders')\n        .select(\n            `\n            id,\n            created_at,\n            customer_uuid,\n            order_status,\n            product_href,\n            original_order_id,\n            renewal_order_id,\n            submission_time,\n            approval_denial_timestamp,\n            *,\n            action_item:action_items!checkup_action_item_id(type)\n            `\n        )\n        .eq('customer_uuid', patient_id);\n\n    return data;\n}"
      },
      {
        "name": "getMonthsIntoRenewalOrderSubscription",
        "kind": "function",
        "signature": "export async function getMonthsIntoRenewalOrderSubscription(\n    renewal_order_id: string\n): Promise<Months> {\n    const renewalOrder = await getRenewalOrder(renewal_order_id);\n\n    if (!renewalOrder) {\n        return 0;\n    }\n    if (renewalOrder.subscription_type === SubscriptionCadency.Quarterly) {\n        const subscription = await getPrescriptionSubscription(\n            renewalOrder.subscription_id\n        );\n\n        if (\n            !subscription ||\n            !isGLP1Product(subscription.product_href) ||\n            subscription.subscription_type === SubscriptionCadency.Monthly\n        ) {\n            return 0;\n        }\n\n        const stripeSubscription = await getStripeSubscription(\n            subscription.stripe_subscription_id\n        );\n\n        const date = convertEpochToDate(stripeSubscription.current_period_end);\n\n        const daysBetween = await getDaysBetweenDates(new Date(), date);\n\n        // CURRENTLY THIS ONLY WORKS FOR GLP-1 BIANNUALLY & QUARTERLY & MONTHLY SUBSCRIPTIONS\n        // Anything of a different cadency will need this function to have special cases for each product as we count backwards\n\n        if (renewalOrder.subscription_type === SubscriptionCadency.Quarterly) {\n            if (daysBetween >= 60) {\n                return 1;\n            } else if (daysBetween >= 30) {\n                return 2;\n            } else {\n                return 3;\n            }\n        } else if (\n            renewalOrder.subscription_type === SubscriptionCadency.Biannually\n        ) {\n            if (daysBetween >= 150) {\n                return 1;\n            } else if (daysBetween >= 120) {\n                return 2;\n            } else if (daysBetween >= 90) {\n                return 3;\n            } else if (daysBetween >= 60) {\n                return 4;\n            } else if (daysBetween >= 30) {\n                return 5;\n            } else {\n                return 6;\n            }\n        } else if (\n            renewalOrder.subscription_type === SubscriptionCadency.Annually\n        ) {\n            if (daysBetween >= 330) {\n                return 1;\n            } else if (daysBetween >= 300) {\n                return 2;\n            } else if (daysBetween >= 270) {\n                return 3;\n            } else if (daysBetween >= 240) {\n                return 4;\n            } else if (daysBetween >= 210) {\n                return 5;\n            } else if (daysBetween >= 180) {\n                return 6;\n            } else if (daysBetween >= 150) {\n                return 7;\n            } else if (daysBetween >= 120) {\n                return 8;\n            } else if (daysBetween >= 90) {\n                return 9;\n            } else if (daysBetween >= 60) {\n                return 10;\n            } else if (daysBetween >= 30) {\n                return 11;\n            } else {\n                return 12;\n            }\n        }\n    }\n    return 0;\n}"
      },
      {
        "name": "getPriceForRenewalOrder",
        "kind": "function",
        "signature": "export async function getPriceForRenewalOrder(renewal_order_id: string) {\n    const renewalOrder = await getRenewalOrder(renewal_order_id);\n\n    if (!renewalOrder) {\n        return 0;\n    }\n\n    if (renewalOrder.price) {\n        return Number(renewalOrder.price);\n    }\n\n    const { data: order, error } = await getOrderById(\n        String(renewalOrder.original_order_id)\n    );\n\n    if (!order || error) {\n        return 0;\n    }\n\n    const variantIndex = order.variant_index;\n\n    const productPrice = await getPriceDataRecordWithVariant(\n        renewalOrder.product_href,\n        variantIndex\n    );\n\n    return productPrice?.price_data.product_price || 0;\n}"
      },
      {
        "name": "assignProviderToOrderUsingRenewalOrderId",
        "kind": "function",
        "signature": "export async function assignProviderToOrderUsingRenewalOrderId(\n    renewal_order_id: string,\n    providerId: string\n) {\n    const supabase = await createSupabaseServiceClient();\n\n    const current_time = new Date();\n\n    const { data: fetchedData, error } = await supabase\n        .from('renewal_orders')\n        .update({\n            assigned_provider: providerId,\n            assigned_provider_timestamp: current_time,\n        })\n        .eq('renewal_order_id', renewal_order_id)\n        .select();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: renewal_orders, method: assignProviderToOrderUsingRenewalOrderId, error: ',\n            error\n        );\n\n        return { data: null, error: error };\n    }\n\n    return { data: fetchedData, error: null };\n}"
      },
      {
        "name": "updateRenewalOrderExternalTrackingMetadata",
        "kind": "function",
        "signature": "export async function updateRenewalOrderExternalTrackingMetadata(\n    renewal_order_id: string,\n    external_metadata: any\n) {\n    const supabase = await createSupabaseServiceClient();\n\n    const { data: originalMetadata, error: originalError } = await supabase\n        .from('renewal_orders')\n        .select('external_tracking_metadata')\n        .eq('renewal_order_id', renewal_order_id)\n        .limit(1)\n        .maybeSingle();\n\n    if (originalError) {\n        console.log(\n            'Controller Error. tablename: renewal_orders, method: updateRenewalOrderExternalTrackingMetadata, error: ',\n            originalError\n        );\n        return { data: null, error: originalError };\n    }\n\n    const updatePayload = originalMetadata\n        ? {\n              ...originalMetadata.external_tracking_metadata,\n              ...external_metadata,\n          }\n        : { ...external_metadata };\n\n    if (updatePayload.external_tracking_metadata === null) {\n        delete updatePayload.external_tracking_metadata;\n    }\n\n    const { data: fetchedData, error } = await supabase\n        .from('renewal_orders')\n        .update({ external_tracking_metadata: updatePayload })\n        .eq('renewal_order_id', renewal_order_id)\n        .select();\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: renewal_orders, method: updateRenewalOrderExternalTrackingMetadata, error: ',\n            error\n        );\n        return { data: null, error: error };\n    }\n\n    return { data: fetchedData, error: null };\n}"
      },
      {
        "name": "updateRenewalOrderMetadataSafely",
        "kind": "function",
        "signature": "export async function updateRenewalOrderMetadataSafely(\n    new_metadata: any,\n    renewal_order_id: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: current_metadata, error: current_error } = await supabase\n        .from('renewal_orders')\n        .select('metadata')\n        .eq('renewal_order_id', renewal_order_id)\n        .limit(1)\n        .maybeSingle();\n\n    if (current_error) {\n        console.log('Error in updating order metadata. ', current_error);\n    }\n\n    const { error } = await supabase\n        .from('renewal_orders')\n        .update({\n            metadata: { ...current_metadata?.metadata, ...new_metadata },\n        })\n        .eq('renewal_order_id', renewal_order_id);\n\n    console.log('update metadata error ', error);\n}"
      },
      {
        "name": "addCheckInCompletionToRenewalOrder",
        "kind": "function",
        "signature": "export async function addCheckInCompletionToRenewalOrder(\n    action_item_id: number,\n    completion_time: string,\n    renewal_order_id: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: current_check_ins, error: current_error } = await supabase\n        .from('renewal_orders')\n        .select('check_ins')\n        .eq('renewal_order_id', renewal_order_id)\n        .limit(1)\n        .maybeSingle();\n\n    if (current_error) {\n        console.log(\n            'Error in updating order check in completion for renewal order. ',\n            current_error\n        );\n        return Status.Error;\n    }\n\n    const { error } = await supabase\n        .from('renewal_orders')\n        .update({\n            check_ins: {\n                ...current_check_ins?.check_ins,\n                [action_item_id]: completion_time,\n            },\n        })\n        .eq('renewal_order_id', renewal_order_id);\n\n    if (error) {\n        console.log(\n            'Error in updating order check in completion for renewal order. ',\n            error\n        );\n        return Status.Error;\n    }\n\n    return Status.Success;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/renewal_orders/renewal_orders.ts",
      "bioverse-client/app/services/pharmacy-integration/empower/send-script.ts",
      "bioverse-client/app/services/pharmacy-integration/curexa/curexa-actions.ts",
      "bioverse-client/app/services/pharmacy-integration/gogomeds/ggm-actions.ts",
      "bioverse-client/app/services/pharmacy-integration/tmc/tmc-actions.ts",
      "bioverse-client/app/utils/database/controller/orders/create-order.ts",
      "bioverse-client/app/utils/database/controller/orders/process-manual-order.ts",
      "bioverse-client/app/utils/actions/subscriptions/subscription-actions.ts",
      "bioverse-client/app/api/stripe/webhook/invoice-paid/route.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/order-content.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/orders-content.tsx",
      "bioverse-client/app/(testing_and_development)/olivier-dev/page.tsx",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/StripeInvoicePaidJobHandler.ts",
      "bioverse-client/app/api/revive/send-script/route.ts",
      "bioverse-client/app/api/empower/send-script/route.ts",
      "bioverse-client/app/api/hallandale/send-script/route.ts",
      "bioverse-client/app/api/boothwyn/send-script/route.ts",
      "bioverse-client/app/(testing_and_development)/olivier-dev/utils.ts",
      "bioverse-client/app/utils/actions/check-up/check-up-actions.ts",
      "bioverse-client/app/api/dosespot/_event-type-cases/handlePrescriptionResult.ts",
      "bioverse-client/app/api/tmc/send-script/route.ts",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/refill/[subscription_id]/confirm/page.tsx",
      "bioverse-client/app/(testing_and_development)/dev/mock/order-history/[user_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/order-history/page.tsx",
      "bioverse-client/app/(patient-portal)/dosage-selection/[product]/choose-sub-plan/page.tsx",
      "bioverse-client/app/(patient-portal)/dosage-selection/[product]/choose-plan/page.tsx",
      "bioverse-client/app/(patient-portal)/dosage-selection/[product]/[variant_index]/page.tsx",
      "bioverse-client/app/(patient-portal)/dosage-selection/[product]/page.tsx",
      "bioverse-client/app/utils/database/controller/orders/orders-api.ts",
      "bioverse-client/app/utils/database/controller/profiles/profiles.ts",
      "bioverse-client/app/utils/classes/CommsScheduler/CommsSchedule.ts",
      "bioverse-client/app/utils/classes/CommsScheduler/MonthlyCheckInComms.ts",
      "bioverse-client/app/utils/classes/CommsScheduler/ThreeMonthCheckInComms.ts",
      "bioverse-client/app/(administration)/admin/stripe-api/stripe-api-actions.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/containers/coordinator-main-view-container.tsx",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/RenewalValidationJobHandler.ts",
      "bioverse-client/app/(employee)/(provider-portal)/provider/intakes/[orderId]/page.tsx",
      "bioverse-client/app/api/renewal/autoship/route.ts",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/cancel-flow/[subscription_id]/information/page.tsx",
      "bioverse-client/app/(patient-portal)/check-up/[product_href]/utils.ts",
      "bioverse-client/app/services/stripe/subscriptions.ts",
      "bioverse-client/app/utils/classes/Dashboard.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/intake-response-column/approval-buttons.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approval-buttons.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/patient-information/approval-buttons/review-approval-buttons.tsx",
      "bioverse-client/app/api/customerio/webhook/route.ts",
      "bioverse-client/_deprecated/clinical-intake-flow/approval-buttons/provider-approval-buttons.tsx",
      "bioverse-client/app/utils/classes/Scripts/BoothwynScriptHandler.ts",
      "bioverse-client/app/utils/classes/Scripts/ReviveScriptHandler.ts",
      "bioverse-client/app/utils/classes/Scripts/HallandaleScriptHandler.ts",
      "bioverse-client/app/utils/functions/pharmacy-helpers/bundle-to-single-vial-converter.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/message/message-display.tsx",
      "bioverse-client/app/services/pharmacy-integration/revive/revive-send-script-api.ts",
      "bioverse-client/app/services/pharmacy-integration/hallandale/hallandale-script-api.ts",
      "bioverse-client/app/services/pharmacy-integration/boothwyn/boothwyn-script-api.ts",
      "bioverse-client/app/(testing_and_development)/ben-dev/page.tsx",
      "bioverse-client/app/utils/classes/Pharmacy.ts",
      "bioverse-client/app/utils/classes/Scripts/EmpowerScriptHandler.ts",
      "bioverse-client/app/utils/classes/Scripts/BaseScriptHandler.ts",
      "bioverse-client/app/utils/actions/provider/update-renewal-order-metadata.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/containers/components/ReviewModal.tsx",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/confirm-prescription-dialog.tsx",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/script-view/coordiantor-hallandale-script-view.tsx",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/script-view/coordinator-empower-script-view.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/order-charts/components/StatusDropdown.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/RenewalOrderTabRow.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/CoordinatorConfirmDosage.tsx",
      "bioverse-client/app/components/provider-portal/order-table/utils/assign-provider-helper.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/quarterly-final-review-dialog.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approve-script-dialog.tsx",
      "bioverse-client/app/services/pharmacy-integration/util/utils.ts",
      "bioverse-client/app/services/pharmacy-integration/empower/provider-script-feedback.ts",
      "bioverse-client/app/services/easypost/easypost-tracker.ts",
      "bioverse-client/_deprecated/clinical-intake-flow/order-table/utils/assign-provider-helper.ts",
      "bioverse-client/app/utils/actions/admin/dashboard-scripts.ts",
      "bioverse-client/app/utils/actions/provider/dashboard-scripts.ts",
      "bioverse-client/app/api/provider-portal/tasks/route.ts",
      "bioverse-client/app/components/admin/task-overview/task-overview-container.tsx",
      "bioverse-client/app/components/provider-portal/tasks/task-action-page/utils/task-action-data-fetch.ts",
      "bioverse-client/app/components/provider-portal/order-table/utils/assigned-order-fetch-helper.ts",
      "bioverse-client/_deprecated/clinical-intake-flow/order-table/utils/assigned-order-fetch-helper.ts",
      "bioverse-client/app/utils/database/controller/coordinator_activity_audit/coordinator_activity_audit-api.ts",
      "bioverse-client/app/utils/actions/coordinator/dashboard-scripts.ts",
      "bioverse-client/app/(testing_and_development)/dev/send-script/components/ConvertBundleToMonthly.tsx",
      "bioverse-client/app/(testing_and_development)/dev/send-script/components/UpdateStripeProduct.tsx",
      "bioverse-client/app/(testing_and_development)/dev/send-script/helpers.tsx",
      "bioverse-client/app/utils/database/controller/orders/create-order-utils.ts",
      "bioverse-client/app/utils/actions/prescription-subscriptions/prescription-subscriptions-actions.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/IDAndSelfieCheckJobHandler.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/SendPrescriptionJobHandler.ts",
      "bioverse-client/app/utils/functions/jobs/jobs.ts",
      "bioverse-client/app/utils/functions/jobs/JobsFactory.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/resend-script-confirmation.tsx",
      "bioverse-client/app/api/supabase/payment-failure/route.ts",
      "bioverse-client/app/api/easypost/route.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/utils/data-fetch/intake-view-datafetch.ts",
      "bioverse-client/app/utils/database/controller/custom_orders/custom_orders_api.ts",
      "bioverse-client/app/utils/database/controller/tasks/task-api.ts",
      "bioverse-client/app/utils/database/controller/patient-status-tags/patient-status-tags-api.ts",
      "bioverse-client/app/utils/database/controller/coordinator_tasks/coordinator-task-api.ts",
      "bioverse-client/app/utils/functions/prescription-scripts/boothwyn-script-generator.ts",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/manage/[subscription_id]/page.tsx",
      "bioverse-client/app/services/pharmacy-integration/belmar/update-order.ts",
      "bioverse-client/app/services/pharmacy-integration/hallandale/update-order.ts",
      "bioverse-client/app/services/pharmacy-integration/boothwyn/update-order-boothwyn.ts",
      "bioverse-client/app/services/pharmacy-integration/curexa/update-order.ts",
      "bioverse-client/app/services/pharmacy-integration/gogomeds/update-order.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/intakes/intake-tab-function.ts",
      "bioverse-client/app/utils/functions/patient-portal/patient-portal-utils.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/revive_pharmacy_patient_data/revive_pharamacy_patient_data_api.ts",
    "exports": [
      {
        "name": "getReviveIdByPatientId",
        "kind": "function",
        "signature": "export async function getReviveIdByPatientId(\n    patientId: string\n): Promise<string | undefined> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('revive_pharmacy_patient_data')\n        .select(`*`)\n        .eq('patient_id', patientId)\n        .limit(1)\n        .maybeSingle();\n\n    if (error || isEmpty(data)) {\n        return undefined;\n    }\n\n    return data.revive_patient_id;\n}"
      },
      {
        "name": "createRevivePatientSupabaseEntry",
        "kind": "function",
        "signature": "export async function createRevivePatientSupabaseEntry(\n    patientId: string,\n    revivePatientId: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('revive_pharmacy_patient_data')\n        .insert({\n            patient_id: patientId,\n            revive_patient_id: revivePatientId,\n        });\n\n    if (error) {\n        console.error(\n            'createRevivePatientSupabaseEntry error in creating revive patient registry. error details: ',\n            error\n        );\n        return Status.Error;\n    }\n\n    return Status.Success;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/revive_pharmacy_patient_data/revive_pharamacy_patient_data_api.ts",
      "bioverse-client/app/services/pharmacy-integration/revive/revive-patient-api.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/revive_pharmacy_patient_data/revive_pharmacy_patient_data.d.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/controller/shipping_status_audit/shipping_status_audit.ts",
    "exports": [
      {
        "name": "updateShippingStatusAudit",
        "kind": "function",
        "signature": "export async function updateShippingStatusAudit(json: any, pharmacy: string) {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { error } = await supabase\n        .from('shipping_status_audit')\n        .insert({ request_json: json, pharmacy: pharmacy });\n\n    if (error) {\n        console.log(\n            'Shipping Status Audit TS Controller Error. Details: ',\n            error,\n        );\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/shipping_status_audit/shipping_status_audit.ts",
      "bioverse-client/app/api/ggm/order-update/route.ts",
      "bioverse-client/app/api/belmar/order-update/route.ts",
      "bioverse-client/app/api/revive/order-update/route.ts",
      "bioverse-client/app/api/empower/order-update/route.ts",
      "bioverse-client/app/api/hallandale/order-update/route.ts",
      "bioverse-client/app/api/boothwyn/order-update/route.ts",
      "bioverse-client/app/api/curexa/order-update/route.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/shipping_tracking_failed_audit/shipping-tracking-failed-audit.ts",
    "exports": [
      {
        "name": "auditShippingTrackingFailed",
        "kind": "function",
        "signature": "export async function auditShippingTrackingFailed(\n    orderId: number | string,\n    status: string,\n    request_data: any,\n    carrier: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('shipping_tracking_failed_audit')\n        .insert([\n            {\n                order_id: orderId,\n                status: status,\n                request_data: JSON.stringify(request_data),\n                carrier: carrier,\n            },\n        ]);\n\n    if (error) {\n        console.log(\n            'Controller Error. tablename: shipping_tracking_failed_audit, method: updateOrderTrackingNumber, error: ',\n            error,\n            orderId\n        );\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/shipping_tracking_failed_audit/shipping-tracking-failed-audit.ts",
      "bioverse-client/app/utils/database/controller/orders/orders-api.ts",
      "bioverse-client/app/services/pharmacy-integration/belmar/update-order.ts",
      "bioverse-client/app/services/pharmacy-integration/revive/update-order.ts",
      "bioverse-client/app/services/pharmacy-integration/empower/update-order.ts",
      "bioverse-client/app/services/pharmacy-integration/hallandale/update-order.ts",
      "bioverse-client/app/services/pharmacy-integration/boothwyn/update-order-boothwyn.ts",
      "bioverse-client/app/services/pharmacy-integration/curexa/update-order.ts",
      "bioverse-client/app/services/pharmacy-integration/gogomeds/update-order.ts",
      "bioverse-client/app/services/easypost/easypost-tracker.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/site-error-audit/site_error_audit.ts",
    "exports": [
      {
        "name": "auditErrorToSupabase",
        "kind": "function",
        "signature": "export async function auditErrorToSupabase(\n    identifier: string,\n    error_message: string,\n    error_json: any = {}\n) {\n    const supabase = createSupabaseServiceClient();\n\n    let user_email;\n    let user_id;\n\n    try {\n        const sessionData = (await readUserSession()).data.session;\n\n        user_email = sessionData?.user.email;\n        user_id = sessionData?.user.id;\n    } catch (error) {\n        user_email = undefined;\n        user_id = undefined;\n    }\n\n    const { error } = await supabase.from(`site_error_audit`).insert({\n        error_message: error_message,\n        user_data: {\n            user_id: user_id ?? undefined,\n            user_email: user_email ?? undefined,\n        },\n        identifier: identifier,\n        error_json: error_json,\n    });\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(administration)/admin/stripe-api/stripe-api-actions.ts",
      "bioverse-client/app/utils/database/controller/site-error-audit/site_error_audit.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/message/message-display.tsx",
      "bioverse-client/_deprecated/clinical-intake-flow/approval-buttons/provider-approval-buttons.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/site-error-audit/site_error_identifiers.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/controller/storage/face-pictures/face-picture-functions.ts",
    "exports": [
      {
        "name": "updateUserRightSidePhotoURL",
        "kind": "function",
        "signature": "export async function updateUserRightSidePhotoURL(\n    userId: string,\n    sideFileName: string\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    // Perform the update\n    const { data, error } = await supabase\n        .from('profiles')\n        .update({ right_side_profile_url: sideFileName })\n        .eq('id', userId);\n\n    if (error) {\n        console.error('Error updating profile:', error);\n        throw error;\n    }\n\n    console.log('Profile updated successfully!', data);\n}"
      },
      {
        "name": "updateUserLeftSidePhotoURL",
        "kind": "function",
        "signature": "export async function updateUserLeftSidePhotoURL(\n    userId: string,\n    sideFileName: string\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    // Perform the update\n    const { data, error } = await supabase\n        .from('profiles')\n        .update({ left_side_profile_url: sideFileName })\n        .eq('id', userId);\n\n    if (error) {\n        console.error('Error updating profile:', error);\n        throw error;\n    }\n\n    console.log('Profile updated successfully!', data);\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/storage/face-pictures/face-picture-functions.ts",
      "bioverse-client/app/components/intake-v2/pages/skincare-upload.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/storage/license-selfie/license-selfie-functions.ts",
    "exports": [
      {
        "name": "updateUserProfileLicensePhotoURL",
        "kind": "function",
        "signature": "export async function updateUserProfileLicensePhotoURL(\n    userId: string,\n    licensePhotoUrl: string\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    // Perform the update\n    const { data, error } = await supabase\n        .from('profiles')\n        .update({ license_photo_url: licensePhotoUrl })\n        .eq('id', userId);\n\n    if (error) {\n        console.error('Error updating profile:', error);\n        throw error;\n    }\n\n    console.log('Profile updated successfully!', data);\n}"
      },
      {
        "name": "updateUserProfileSelfiePhotoURL",
        "kind": "function",
        "signature": "export async function updateUserProfileSelfiePhotoURL(\n    userId: string,\n    selfie_photo_url: string\n) {\n    const supabase = await createSupabaseServerComponentClient();\n\n    // Perform the update\n    const { data, error } = await supabase\n        .from('profiles')\n        .update({ selfie_photo_url: selfie_photo_url })\n        .eq('id', userId);\n\n    if (error) {\n        console.error('Error updating profile:', error);\n        throw error;\n    }\n\n    console.log('Profile updated successfully!', data);\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/storage/license-selfie/license-selfie-functions.ts",
      "bioverse-client/app/components/patient-portal/patient-portal-client/patient-id-verification.tsx",
      "bioverse-client/app/components/intake-v3/pages/id-verification-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/id-verification-noskip-v3.tsx",
      "bioverse-client/app/components/intake-v2/pages/id-verification.tsx",
      "bioverse-client/app/components/intake-v2/pages/skincare-upload.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/stripe_audit/stripe_audit.ts",
    "exports": [
      {
        "name": "getRefundAuditForPaymentIntent",
        "kind": "function",
        "signature": "export async function getRefundAuditForPaymentIntent(\n    payment_intent_id: string,\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('stripe_audit')\n        .select(`*, profile:profiles!user_id (first_name, last_name)`)\n        .eq('event_type', 'refund')\n        .eq('enacted_object_id', payment_intent_id)\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        return { refunds: null, error: error };\n    }\n\n    return { refunds: data, error: null };\n}"
      },
      {
        "name": "auditStripe",
        "kind": "function",
        "signature": "export async function auditStripe(\n    event_type: string,\n    request_data: any,\n    response_data: any,\n    user_id: string,\n    enacted_object_id: string,\n    metadata: any,\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('stripe_audit')\n        .insert({\n            event_type,\n            request_data,\n            response_data,\n            user_id,\n            enacted_object_id,\n            metadata,\n        });\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/stripe_audit/stripe_audit.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/invoices/components/refund-history-modal.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approval-buttons.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/patient-information/approval-buttons/review-approval-buttons.tsx",
      "bioverse-client/app/services/stripe/subscriptions.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/subscription_status_audit/subscription_stauts_audit.ts",
    "exports": [
      {
        "name": "addSubscriptionStatusAudit",
        "kind": "function",
        "signature": "export async function addSubscriptionStatusAudit(\n    actor: string,\n    new_status: string,\n    order_id?: string,\n    subscription_id?: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase.from('subscription_status_audit').insert({\n        new_status: new_status,\n        actor: actor,\n        ...(order_id ? { order_id: order_id } : {}),\n        ...(subscription_id ? { subscription_id: subscription_id } : {}),\n    });\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/subscription_status_audit/subscription_stauts_audit.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/controller/tasks/task-api.ts",
    "exports": [
      {
        "name": "getIncompleteTaskList",
        "kind": "function",
        "signature": "export async function getIncompleteTaskList(limit: number) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: taskListData, error: taskListError } = await supabase\n        .from('provider_tasks')\n        .select('*')\n        .eq('completion_status', false)\n        .order('created_at', { ascending: false })\n        .limit(limit);\n\n    if (taskListError) {\n        console.error(\n            'getTaskList error - ',\n            ' Error details: ',\n            taskListError.message\n        );\n        return { data: null, status: Status.Error };\n    }\n\n    if (isEmpty(taskListData)) {\n        return { data: null, status: Status.Success };\n    }\n\n    return {\n        data: taskListData as ProviderTaskSupabaseRecord[],\n        status: Status.Success,\n    };\n}"
      },
      {
        "name": "getExistingIntakeRenewalTaskList",
        "kind": "function",
        "signature": "export async function getExistingIntakeRenewalTaskList() {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: taskListData, error: taskListError } = await supabase\n        .from('provider_tasks')\n        .select('order_id, renewal_order_id')\n        .in('type', ['intake', 'renewal'])\n        .order('created_at', { ascending: false })\n        .limit(10);\n\n    if (taskListError) {\n        console.error('getExistingIntakeRenewalTaskList error ', taskListError);\n    }\n\n    return taskListData;\n}"
      },
      {
        "name": "getLastProviderTask",
        "kind": "function",
        "signature": "export async function getLastProviderTask(userId: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: taskListData, error: taskListError } = await supabase\n        .from('provider_tasks')\n        .select('*')\n        .eq('assigned_provider', userId)\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .maybeSingle();\n\n    if (taskListError) {\n        console.error(\n            'getTaskList error - ',\n            ' Error details: ',\n            taskListError.message\n        );\n        return { data: null, status: Status.Error };\n    }\n\n    if (isEmpty(taskListData)) {\n        return { data: null, status: Status.Success };\n    }\n\n    return {\n        data: taskListData as ProviderTaskSupabaseRecord,\n        status: Status.Success,\n    };\n}"
      },
      {
        "name": "getLastTwoProviderTasks",
        "kind": "function",
        "signature": "export async function getLastTwoProviderTasks(userId: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: taskListData, error: taskListError } = await supabase\n        .from('provider_tasks')\n        .select('*')\n        .eq('assigned_provider', userId)\n        .order('created_at', { ascending: false })\n        .limit(2);\n\n    if (taskListError) {\n        console.error(\n            'getTaskList error - ',\n            ' Error details: ',\n            taskListError.message\n        );\n        return { data: null, status: Status.Error };\n    }\n\n    if (isEmpty(taskListData)) {\n        return { data: null, status: Status.Success };\n    }\n\n    return {\n        data: taskListData as ProviderTaskSupabaseRecord[],\n        status: Status.Success,\n    };\n}"
      },
      {
        "name": "checkIfTaskAlreadyExists",
        "kind": "function",
        "signature": "export async function checkIfTaskAlreadyExists(\n    taskType: TaskType,\n    taskData: StatusTagObject | TaskOrderObject | TaskRenewalObject\n): Promise<boolean> {\n    const supabase = createSupabaseServiceClient();\n\n    let orderId: string;\n    if (isTaskOrderObject(taskData)) {\n        orderId = taskData.order_id.toString();\n    } else if (isTaskRenewalObject(taskData)) {\n        orderId = taskData.original_order_id.toString();\n    } else if (isStatusTagObject(taskData)) {\n        orderId = taskData.id.toString();\n    } else {\n        orderId = (taskData as StatusTagObject).id.toString();\n    }\n\n    const { data, error } = await supabase\n        .from('provider_tasks')\n        .select('*')\n        .eq('type', taskType)\n        .gte('created_at', new Date(Date.now() - 5 * 60 * 1000).toISOString())\n        .eq('order_id', orderId);\n\n    return data ? true : false;\n}"
      },
      {
        "name": "createTaskFromStatusTagData",
        "kind": "function",
        "signature": "export async function createTaskFromStatusTagData(\n    status_tag_object: StatusTagObject,\n    type: string,\n    provider_id: string\n) {\n    const supabase = createSupabaseServiceClient();\n\n    let isRenewalOrder: boolean;\n    let status_order_id: number;\n\n    if (status_tag_object.order_id.includes('-')) {\n        status_order_id = parseInt(status_tag_object.order_id.split('-')[0]);\n        isRenewalOrder = true;\n    } else {\n        status_order_id = parseInt(status_tag_object.order_id);\n        isRenewalOrder = false;\n    }\n\n    const task_object: Partial<ProviderTaskSupabaseRecord> = {\n        original_created_at: status_tag_object.created_at,\n        order_id: status_order_id,\n        ...(isRenewalOrder\n            ? { renewal_order_id: status_tag_object.order_id }\n            : {}),\n        completion_status: false,\n        assigned_provider: provider_id,\n        type: type,\n        environment: process.env.NEXT_PUBLIC_ENVIRONMENT!,\n    };\n\n    const { data, error } = await supabase\n        .from('provider_tasks')\n        .insert(task_object)\n        .select('*')\n        .limit(1)\n        .maybeSingle();\n\n    if (error) {\n        return { status: Status.Error };\n    }\n\n    return { id: data.id, status: Status.Success };\n}"
      },
      {
        "name": "createTaskFromOrderOrRenewalData",
        "kind": "function",
        "signature": "export async function createTaskFromOrderOrRenewalData(\n    orderType: OrderType,\n    type: string,\n    provider_id: string,\n    order_data?: TaskOrderObject,\n    renewal_data?: TaskRenewalObject\n) {\n    const supabase = createSupabaseServiceClient();\n\n    if (orderType === OrderType.RenewalOrder && renewal_data) {\n        const renewals_original_order_id = parseInt(\n            renewal_data.renewal_order_id.split('-')[0]\n        );\n\n        const task_object: Partial<ProviderTaskSupabaseRecord> = {\n            original_created_at:\n                renewal_data.submission_time ?? new Date().toISOString(),\n            order_id: renewals_original_order_id,\n            renewal_order_id: renewal_data.renewal_order_id,\n            completion_status: false,\n            assigned_provider: provider_id,\n            type: type,\n            environment: process.env.NEXT_PUBLIC_ENVIRONMENT!,\n        };\n\n        const { data, error } = await supabase\n            .from('provider_tasks')\n            .insert(task_object)\n            .select('*')\n            .limit(1)\n            .maybeSingle();\n\n        if (error) {\n            console.error(\n                'createTaskFromOrderOrRenewalData error: ',\n                error.message\n            );\n        }\n\n        return { id: data.id, status: Status.Success };\n    } else if (orderType === OrderType.Order && order_data) {\n        const task_object: Partial<ProviderTaskSupabaseRecord> = {\n            original_created_at: order_data.created_at,\n            order_id: order_data.order_id,\n            renewal_order_id: undefined,\n            completion_status: false,\n            assigned_provider: provider_id,\n            type: type,\n            environment: process.env.NEXT_PUBLIC_ENVIRONMENT!,\n        };\n\n        const { data, error } = await supabase\n            .from('provider_tasks')\n            .insert(task_object)\n            .select('*')\n            .limit(1)\n            .maybeSingle();\n\n        if (error) {\n            console.error(\n                'createTaskFromOrderOrRenewalData error: ',\n                error.message\n            );\n        }\n\n        return { id: data.id, status: Status.Success };\n    }\n\n    return { id: null, status: Status.Error };\n}"
      },
      {
        "name": "updateTaskCompletionStatus",
        "kind": "function",
        "signature": "export async function updateTaskCompletionStatus(\n    task_id: string,\n    new_status: boolean\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('provider_tasks')\n        .update({ completion_status: new_status })\n        .eq('id', task_id);\n\n    if (error) {\n        console.error(\n            'updateTaskCompletionStatus: ',\n            task_id,\n            ' error msg: ',\n            error.message\n        );\n        return { status: Status.Error };\n    }\n}"
      },
      {
        "name": "getTaskOrderIdFromTaskId",
        "kind": "function",
        "signature": "export async function getTaskOrderIdFromTaskId(taskId: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('provider_tasks')\n        .select('order_id, renewal_order_id')\n        .eq('id', taskId)\n        .limit(1)\n        .maybeSingle();\n\n    if (data?.renewal_order_id) {\n        return data.renewal_order_id as string;\n    }\n\n    return data?.order_id as string;\n}"
      },
      {
        "name": "getTaskCompletionCount",
        "kind": "function",
        "signature": "export async function getTaskCompletionCount() {\n    const supabase = createSupabaseServiceClient();\n\n    const userId = (await readUserSession()).data.session?.user.id!;\n\n    function getBeginningOfMonth(): string {\n        const now = new Date();\n        const beginningOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);\n        return beginningOfMonth.toISOString();\n    }\n    const beginningOfMonth = getBeginningOfMonth();\n\n    const { count, error } = await supabase\n        .from('provider_tasks')\n        .select('*', { count: 'exact', head: true })\n        .eq('assigned_provider', userId)\n        .eq('completion_status', true)\n        .eq('type', 'intake')\n        .gt('created_at', beginningOfMonth);\n\n    if (error) {\n        console.error(error);\n    }\n\n    return count;\n}"
      },
      {
        "name": "getMessagingTaskCompletionCount",
        "kind": "function",
        "signature": "export async function getMessagingTaskCompletionCount() {\n    const supabase = createSupabaseServiceClient();\n\n    const userId = (await readUserSession()).data.session?.user.id!;\n    // const userId = '28e2a459-2805-425f-96f3-a3d7f39c0528'; //Kristen Curcio\n\n    function getBeginningOfMonth(): string {\n        const now = new Date();\n        const beginningOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);\n        return beginningOfMonth.toISOString();\n    }\n    const beginningOfMonth = getBeginningOfMonth();\n\n    const { count, error } = await supabase\n        .from('provider_tasks')\n        .select('*', { count: 'exact', head: true })\n        .eq('assigned_provider', userId)\n        .eq('completion_status', true)\n        .eq('type', 'message')\n        .gt('created_at', beginningOfMonth);\n\n    if (error) {\n        console.error(error);\n        return 0;\n    }\n\n    return count ?? 0;\n}"
      },
      {
        "name": "getTodaysTaskCompletionCount",
        "kind": "function",
        "signature": "export async function getTodaysTaskCompletionCount() {\n    const supabase = createSupabaseServiceClient();\n\n    function getMidnightOfPreviousDay(): string {\n        const now = new Date();\n        const previousDay = new Date(now);\n        previousDay.setDate(now.getDate() - 1);\n        previousDay.setHours(0, 0, 0, 0);\n        return previousDay.toISOString();\n    }\n\n    const { count, error } = await supabase\n        .from('provider_tasks')\n        .select('*', { count: 'exact', head: true })\n        .eq('completion_status', true)\n        .eq('environment', process.env.NEXT_PUBLIC_ENVIRONMENT!)\n        .gte('created_at', getMidnightOfPreviousDay());\n\n    return { data: count, status: Status.Success };\n}"
      },
      {
        "name": "reportTaskFailure",
        "kind": "function",
        "signature": "export async function reportTaskFailure(taskId: number) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('provider_tasks')\n        .update({ reported_failure: true })\n        .eq('id', taskId);\n\n    if (error) {\n        console.error('reportTaskFailure: task ID: ', taskId);\n    }\n\n    return;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/tasks/task-api.ts",
      "bioverse-client/app/api/provider-portal/tasks/route.ts",
      "bioverse-client/app/utils/database/controller/coordinator_tasks/coordinator-task-api.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/containers/components/coordinator-task-action-info-bar.tsx",
      "bioverse-client/app/components/provider-portal/tasks/task-action-page/components/task-action-info-bar.tsx",
      "bioverse-client/app/(employee)/(registered-nurse-portal)/registered-nurse/tasks/[taskId]/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/tasks/[taskId]/page.tsx",
      "bioverse-client/app/components/provider-portal/tasks/task-action-page/components/task-action-container.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/review-container/provider-review-container.tsx",
      "bioverse-client/app/components/provider-portal/tasks/task-action-page/utils/task-action-data-fetch.ts",
      "bioverse-client/app/components/provider-portal/tasks/task-counter-view/functions/getAllTaskCount.ts",
      "bioverse-client/app/components/provider-portal/tasks/task-action-page/components/intake-view-task-container.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/provider-review-ui.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/schema.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/database/storage/lab-work-documents/lab-work-documents.ts",
    "exports": [
      {
        "name": "getLabWorkDocumentNames",
        "kind": "function",
        "signature": "export async function getLabWorkDocumentNames(patientId: string) {\n    const supabase = createSupabaseServiceClient();\n\n    try {\n        const { error, data: documents } = await supabase\n            .from('lab_work_document')\n            .select('*')\n            .eq('patient_id', patientId)\n            .order('id', { ascending: false });\n\n        if (error) {\n            throw error;\n        }\n\n        return documents;\n    } catch (error) {\n        console.error('An error occured:', error);\n    }\n}"
      },
      {
        "name": "getLabWorkSignedURL",
        "kind": "function",
        "signature": "export async function getLabWorkSignedURL(\n    documentId: number,\n    patientId: string\n) {\n    const supabase = createSupabaseServiceClient();\n    try {\n        const { error: queryError, data } = await supabase\n            .from('lab_work_file')\n            .select('filename')\n            .eq('lab_work_document_id', documentId)\n            .single();\n\n        if (queryError) {\n            throw queryError;\n        }\n\n        const fileName = `${patientId}/${data.filename}`;\n        const { error, data: fileUrl } = await supabase.storage\n            .from('lab_work_file_uploads')\n            .createSignedUrl(fileName, 60);\n\n        if (error) {\n            console.error('getLabWorkSignedURL error', error);\n        }\n\n        return fileUrl;\n    } catch (error) {\n        alert(\n            'An error occurred while downloading the file. Please try again.'\n        );\n        console.error('An error occurred:', error);\n\n        return null;\n    }\n}"
      },
      {
        "name": "uploadLabDocument",
        "kind": "variable",
        "signature": "uploadLabDocument = async (\n    documentName: string,\n    patientId: string,\n    lab_work_type: string,\n    file: File\n) => {\n    const supabase = createSupabaseServiceClient();\n\n    // Generate a unique filename\n    const uniqueSuffix = `${Date.now()}-${Math.round(Math.random() * 1e9)}`;\n    const fileExt = file.name.split('.').pop();\n    const fileName = `${uniqueSuffix}.${fileExt}`;\n\n    // Put the file inside a unique folder for the user\n    const filePath = `${patientId}/${fileName}`;\n\n    try {\n        let { error, data: upload_data } = await supabase.storage\n            .from('lab_work_file_uploads')\n            .upload(filePath, file);\n\n        if (error) {\n            throw error;\n        }\n\n        // Create a new lab work document entry\n        const document: LabWorkDocument = {\n            lab_work_type: lab_work_type,\n            document_name: documentName,\n            patient_id: patientId,\n        };\n\n        // Get the id of the new entry for the new lab work file entry\n        const { error: documentError, data } = await supabase\n            .from('lab_work_document')\n            .insert(document)\n            .select('id')\n            .single();\n\n        if (documentError) {\n            // TODO: delete the uploaded file and rollback database insert\n            throw documentError;\n        }\n\n        // Create a new lab work file entry\n        const workFile: LabWorkFile = {\n            filename: fileName,\n            lab_work_document_id: data.id, // Put the inserted document id here,\n        };\n\n        const { error: fileError } = await supabase\n            .from('lab_work_file')\n            .insert(workFile);\n\n        if (fileError) {\n            // TODO: delete the uploaded file and rollback database insert\n            throw fileError;\n        }\n    } catch (error) {\n        console.error('error uploading labs', error);\n        return { status: Status.Failure };\n    }\n\n    return { status: Status.Success };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/storage/lab-work-documents/lab-work-documents.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/documents/documents-content.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/patient-information/document-accordion/documents-accordion.tsx",
      "bioverse-client/app/components/patient-portal/labs/labs-content.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/documents/document-type-components/lab-work-ptChart.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/patient-information/document-accordion/components/lab-work-provider-review.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/storage/license-selfie/license-selfie.ts",
    "exports": [
      {
        "name": "getLicenseSelfieSignedURL",
        "kind": "function",
        "signature": "export async function getLicenseSelfieSignedURL(\n    patient_id: string,\n): Promise<LicenseData | null> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('profiles')\n        .select('license_photo_url, selfie_photo_url')\n        .eq('id', patient_id)\n        .single();\n\n    if (!data || error) {\n        return null;\n    }\n\n    const urlToRetrieveLicenseFrom = `${patient_id}/${data?.license_photo_url}`;\n    const { data: licenseUrl, error: licenseError } =\n        await getLicenseOrSelfieSignedURL(urlToRetrieveLicenseFrom);\n\n    const urlToRetrieveSelfieFrom = `${patient_id}/${data?.selfie_photo_url}`;\n    const { data: selfieUrl, error: selfieError } =\n        await getLicenseOrSelfieSignedURL(urlToRetrieveSelfieFrom);\n\n    const licenseData: LicenseData = {\n        license: licenseError ? undefined : licenseUrl.signedUrl,\n        selfie: selfieError ? undefined : selfieUrl.signedUrl,\n    };\n\n    return licenseData;\n}"
      },
      {
        "name": "getLicenseOrSelfieSignedURL",
        "kind": "function",
        "signature": "export async function getLicenseOrSelfieSignedURL(filePath: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data: urlData, error } = await supabase.storage\n        .from('license_and_selfie_images')\n        .createSignedUrl(filePath, 60 * 60);\n\n    if (error) {\n        console.log('getLicenseOrSelfieURL', error);\n        return { data: null, error: error };\n    } else return { data: urlData, error: null };\n}"
      },
      {
        "name": "getAllLicenseAndSelfiePhotos",
        "kind": "function",
        "signature": "export async function getAllLicenseAndSelfiePhotos(\n    user_id: string,\n): Promise<{ url: string; created_at: string; name: string }[]> {\n    const supabase = createSupabaseServiceClient();\n\n    // List all files in the user's folder\n    const { data: files, error } = await supabase.storage\n        .from('license_and_selfie_images')\n        .list(user_id);\n\n    if (error) {\n        console.error('Error listing files:', error);\n        return [];\n    }\n\n    if (!files || files.length === 0) {\n        return [];\n    }\n\n    // Generate signed URLs and collect created_at dates and file names for each file\n    const fileDataArray = await Promise.all(\n        files.map(async (file) => {\n            const filePath = `${user_id}/${file.name}`;\n            const { data: urlData, error: urlError } =\n                await getLicenseOrSelfieSignedURL(filePath);\n\n            if (urlError) {\n                console.error(\n                    'Error getting signed URL for',\n                    filePath,\n                    urlError,\n                );\n                return null;\n            }\n\n            return {\n                url: urlData.signedUrl,\n                created_at: file.created_at,\n                name: file.name,\n            };\n        }),\n    );\n\n    // Filter out any null values in case of errors\n    return fileDataArray.filter(\n        (\n            fileData,\n        ): fileData is { url: string; created_at: string; name: string } =>\n            fileData !== null,\n    );\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/storage/license-selfie/license-selfie.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/utils/license-selfies/signed-url-retriever.ts",
      "bioverse-client/app/components/coordinator-portal/thread-view/provider-view-clone/components/patient-information-column/documents-content.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/documents/documents-content.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/utils/license-selfies/signed-url-retriever.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/documents-content.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/demographics-content.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/patient-information/document-accordion/documents-accordion.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/database/storage/skin-care-face-pictures/skin-care-face-uploads.ts",
    "exports": [
      {
        "name": "getSkinCareFaceUploads",
        "kind": "function",
        "signature": "export async function getSkinCareFaceUploads(patient_id: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('profiles')\n        .select('right_side_profile_url, left_side_profile_url')\n        .eq('id', patient_id)\n        .single();\n\n    if (!data || error) {\n        return {\n            left_side_url: undefined,\n            right_side_url: undefined,\n        };\n    }\n\n    const urlToRetrieveRightSideFrom = `${patient_id}/${data?.right_side_profile_url}`;\n    const { data: rightSideUrl, error: rightSideError } =\n        await getFacePictureSignedURL(urlToRetrieveRightSideFrom);\n\n    const urlToRetrieveSelfieFrom = `${patient_id}/${data?.left_side_profile_url}`;\n    const { data: leftSideUrl, error: leftSideError } =\n        await getFacePictureSignedURL(urlToRetrieveSelfieFrom);\n\n    return {\n        left_side_url: leftSideUrl?.signedUrl,\n        right_side_url: rightSideUrl?.signedUrl,\n    };\n    //face-picture-uploads\n}"
      },
      {
        "name": "getFacePictureSignedURL",
        "kind": "function",
        "signature": "export async function getFacePictureSignedURL(filePath: string) {\n    const supabase = await createSupabaseServiceClient();\n\n    const { data: urlData, error } = await supabase.storage\n        .from('face-picture-uploads')\n        .createSignedUrl(filePath, 60 * 60);\n\n    if (error) {\n        console.log('getFacePictureSignedURL', error);\n        return { data: null, error: error };\n    } else return { data: urlData, error: null };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/storage/skin-care-face-pictures/skin-care-face-uploads.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/documents/documents-content.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/patient-information/document-accordion/documents-accordion.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/address-verification.ts",
    "exports": [
      {
        "name": "determineAddressValidationLevel",
        "kind": "variable",
        "signature": "determineAddressValidationLevel = (\n    verdict: Verdict,\n): ValidationLevel => {\n    // 1. Determine if needs to FIX ADDRESS\n\n    if (verdict.validationGranularity === 'OTHER' || !verdict.addressComplete) {\n        return 0;\n    }\n\n    // TODO: Provide more in depth feedback about incorrect address\n\n    return 1;\n}"
      },
      {
        "name": "determineIsPoBox",
        "kind": "variable",
        "signature": "determineIsPoBox = (\n    metadata: Metadata,\n): boolean => {\n    if (\n        metadata && metadata.poBox\n    ) {\n        return true;\n    }\n\n    return false;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/address-verification.ts",
      "bioverse-client/app/api/google/route.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/annual-glp1/annual-glp1-controller.ts",
    "exports": [
      {
        "name": "createAnnualGLP1Record",
        "kind": "function",
        "signature": "export async function createAnnualGLP1Record(orderId: string, scriptJSON: any) {\n    const { data, type } = await fetchOrderData(orderId);\n\n    const subscriptionId = data.subscription_id;\n\n    /**\n     * Start with the fact that the script was sent for a specific order/renewal order id\n     */\n    //Fetch the subscription data with subscription ID\n    const stripe_subscription_id =\n        await getStripeSubscriptionIdFromSubscription(subscriptionId);\n\n    if (!stripe_subscription_id) {\n        throw new Error('No Stripe Subscription found for ID');\n    }\n\n    //Use subscription data to get the stripe subcsription data and then fetch the next renewal date epoch\n    const stripeSubscription = await getStripeSubscription(\n        stripe_subscription_id\n    );\n\n    const nextRenewalEpoch = stripeSubscription.current_period_end;\n\n    const currentTimeEpoch = Math.floor(Date.now() / 1000);\n\n    //take the epoch time of that and the epoch time of current and then take half the difference and add it to the current\n    const timeDifference = nextRenewalEpoch - currentTimeEpoch;\n    const halfTimeDifference = Math.floor(timeDifference / 2);\n\n    // Then take the current and add the 1/2-difference and get the scheduled release time\n    const scheduledReleaseEpoch = currentTimeEpoch + halfTimeDifference;\n\n    // turn the subscription renewal time & the 1/2-difference and then turn them into timestamptz for the database to store.\n    const scheduledReleaseTime = new Date(\n        scheduledReleaseEpoch * 1000\n    ).toISOString();\n    const subscriptionRenewalTime = new Date(\n        nextRenewalEpoch * 1000\n    ).toISOString();\n\n    // These timestamps can now be stored in Supabase\n    const timestampsForDatabase = {\n        scheduled_release_time: scheduledReleaseTime,\n        subscription_renewal_time: subscriptionRenewalTime,\n    };\n\n    const supabase = createSupabaseServiceClient();\n\n    const annualOrderTrackingRecord = {\n        patient_id:\n            type === OrderType.Order ? data.customer_uid : data.customer_uuid,\n        product_href: data.product_href,\n        variant_index: data.variant_index,\n        scheduled_next_renewal_date:\n            timestampsForDatabase.subscription_renewal_time,\n        scheduled_second_supply_date:\n            timestampsForDatabase.scheduled_release_time,\n        base_order_id:\n            type === OrderType.Order ? data.id : data.original_order_id,\n        renewal_order_id:\n            type === OrderType.RenewalOrder ? data.renewal_order_id : null,\n        subscription_id: subscriptionId,\n        prescription_json_1: scriptJSON,\n    };\n\n    const { data: record_added, error } = await supabase\n        .from('annual_order_tracking')\n        .insert(annualOrderTrackingRecord)\n        .select('id')\n        .single();\n\n    if (error) {\n        throw new Error('Could not add record to supabase: ' + error.message);\n    }\n\n    return record_added.id;\n}"
      },
      {
        "name": "updateAnnualGLP1RecordCheckIns",
        "kind": "function",
        "signature": "export async function updateAnnualGLP1RecordCheckIns() {}"
      },
      {
        "name": "updateAnnualGLP1SecondShipmentSent",
        "kind": "function",
        "signature": "export async function updateAnnualGLP1SecondShipmentSent(\n    annualShipmentRecordId: number,\n    scriptJSON: any\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('annual_order_tracking')\n        .update({\n            status: 'complete',\n            second_script_sent_time: new Date().toISOString(),\n            prescription_json_2: scriptJSON,\n        })\n        .eq('id', annualShipmentRecordId);\n\n    if (error) {\n        console.log(error);\n    }\n}"
      },
      {
        "name": "checkIfOrderIsAnnualVariant",
        "kind": "function",
        "signature": "export async function checkIfOrderIsAnnualVariant(\n    new_variant_index: number,\n    orderId: string\n): Promise<{\n    isAnnualOrderScript: boolean;\n    shipmentNumber: 'first' | 'second';\n}> {\n    let isAnnualOrderScript: boolean = false;\n    let shipmentNumber: 'first' | 'second' = 'first';\n\n    const { data, type } = await fetchOrderData(orderId);\n\n    const product_href = data.product_href;\n\n    isAnnualOrderScript =\n        AnnualGLP1VariantIndexMap[product_href].includes(new_variant_index);\n    const elibibleVariants =\n        ANNUAL_GLP1_VARIANT_MAP[product_href][new_variant_index];\n\n    if (!elibibleVariants) {\n        return {\n            isAnnualOrderScript: false,\n            shipmentNumber: 'first',\n        };\n    }\n\n    if (elibibleVariants.firstShipmentVariant === new_variant_index) {\n        shipmentNumber = 'first';\n    } else {\n        shipmentNumber = 'second';\n    }\n\n    console.log('ANNUAL CHECK RESULT SHIP NUM: ', shipmentNumber);\n\n    return {\n        isAnnualOrderScript: isAnnualOrderScript,\n        shipmentNumber: shipmentNumber,\n    };\n}"
      },
      {
        "name": "cancelAnnualShipmentTracking",
        "kind": "function",
        "signature": "export async function cancelAnnualShipmentTracking(subscription_id: number) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('annual_order_tracking')\n        .update({ status: 'canceled' })\n        .eq('subscription_id', subscription_id);\n\n    if (error) {\n        console.error('Error in canceling annual shipment information ', error);\n    }\n\n    return;\n}"
      },
      {
        "name": "checkSubscriptionIsAnnual",
        "kind": "function",
        "signature": "export async function checkSubscriptionIsAnnual(subscription_id: number) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('prescription_subscriptions')\n        .select('subscription_type')\n        .eq('id', subscription_id)\n        .limit(1)\n        .maybeSingle();\n\n    if (!data || error) {\n        console.error(\n            'No record found for subscription on check is annual ',\n            error\n        );\n    }\n\n    return data?.subscription_type === 'annually';\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/annual-glp1/annual-glp1-controller.ts",
      "bioverse-client/app/api/hallandale/send-script/route.ts",
      "bioverse-client/app/api/supabase/annual-glp1/route.ts",
      "bioverse-client/app/(administration)/admin/stripe-api/stripe-api-actions.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/annual-glp1/annual-glp1-mappings.ts",
    "exports": [
      {
        "name": "ANNUAL_GLP1_VARIANT_MAP",
        "kind": "variable",
        "signature": "ANNUAL_GLP1_VARIANT_MAP: AnnualGlp1Map = {\n    /**\n     * These mappings correspond to two variant indices, but they are double mapped\n     * to give the same results whether the first or second shipment variant index is used.\n     */\n    [PRODUCT_HREF.SEMAGLUTIDE]: {\n        37: {\n            firstShipmentVariant: 37,\n            secondShipmentVariant: 38,\n        },\n        38: {\n            firstShipmentVariant: 37,\n            secondShipmentVariant: 38,\n        },\n        39: {\n            firstShipmentVariant: 39,\n            secondShipmentVariant: 40,\n        },\n        40: {\n            firstShipmentVariant: 39,\n            secondShipmentVariant: 40,\n        },\n        41: {\n            firstShipmentVariant: 41,\n            secondShipmentVariant: 42,\n        },\n        42: {\n            firstShipmentVariant: 41,\n            secondShipmentVariant: 42,\n        },\n    },\n    [PRODUCT_HREF.TIRZEPATIDE]: {\n        40: {\n            firstShipmentVariant: 40,\n            secondShipmentVariant: 41,\n        },\n        41: {\n            firstShipmentVariant: 40,\n            secondShipmentVariant: 41,\n        },\n    },\n}"
      },
      {
        "name": "AnnualGLP1VariantIndexMap",
        "kind": "variable",
        "signature": "AnnualGLP1VariantIndexMap: AnnualGlp1AllowedMap = {\n    [PRODUCT_HREF.SEMAGLUTIDE]: [37, 38, 39, 40, 41, 42],\n    [PRODUCT_HREF.TIRZEPATIDE]: [40, 41],\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/annual-glp1/annual-glp1-mappings.ts",
      "bioverse-client/app/utils/functions/annual-glp1/annual-glp1-controller.ts",
      "bioverse-client/app/api/supabase/annual-glp1/route.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/annual-glp1/annual_record.d.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/functions/auth/authorization/authorizaiton-helper.ts",
    "exports": [
      {
        "name": "determineAccessByRoleName",
        "kind": "function",
        "signature": "export function determineAccessByRoleName(\n    access_level: BV_AUTH_TYPE | null,\n    required_level: BV_AUTH_TYPE\n): boolean {\n    if (!access_level) {\n        return false;\n    }\n    if (\n        extractNumericFromAccessLevel(access_level) <\n        extractNumericFromAccessLevel(required_level)\n    ) {\n        return false;\n    } else return true;\n}"
      },
      {
        "name": "BV_ROLE_VALUE_MAP",
        "kind": "variable",
        "signature": "BV_ROLE_VALUE_MAP: BV_ROLE_VALUE_INTERFACE = {\n    test: 1,\n    coordinator: 2,\n    'registered-nurse': 3,\n    provider: 4,\n    'lead-provider': 5,\n    'lead-coordinator': 6,\n    developer: 7,\n    admin: 999,\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/actions/auth/authorization.ts",
      "bioverse-client/app/utils/functions/auth/authorization/authorizaiton-helper.ts",
      "bioverse-client/app/(employee)/(provider-portal)/provider/all-patients/[patient_id]/page.tsx",
      "bioverse-client/app/components/coordinator-portal/navbar/components/coordinator-portal-tabs.tsx",
      "bioverse-client/app/components/coordinator-portal/navbar/coordinator-resources/coordinator-resources-button.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/intakes/intakes-content.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/invoices/invoice-content.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/subscriptions/components/subscription-accordion.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/info/info-content.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/order-tab-row.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/RenewalOrderTabRow.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/order-content.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/all-patients-table-row.tsx",
      "bioverse-client/app/components/navigation/components/client-side-navigation/account-menu/account-menu.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/utils/verify-intake-view-permission.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/auth/password-reset/password-reset.ts",
    "exports": [
      {
        "name": "resetPasswordForUser",
        "kind": "function",
        "signature": "export async function resetPasswordForUser(newPassword: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.auth.updateUser({\n        password: newPassword,\n    });\n\n    if (error) {\n        console.error('Error in resetting password ', error);\n        return Status.Error;\n    }\n\n    return Status.Success;\n}"
      },
      {
        "name": "loggerTester",
        "kind": "function",
        "signature": "export async function loggerTester(content: any) {\n    //console.log('Session log for testing ', content);\n}"
      },
      {
        "name": "logUserInWithCode",
        "kind": "function",
        "signature": "export async function logUserInWithCode(code: string) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.auth.exchangeCodeForSession(code);\n\n    if (error) {\n        console.error('sign in with code error', error);\n        return 'issue with login ' + error.message;\n    } else {\n        console.log('signed in with code');\n        return 'success';\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/auth/password-reset/password-reset.ts",
      "bioverse-client/app/components/login/ChangePassword.tsx",
      "bioverse-client/app/auth/changePassword/page.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/clean-stale-orders/clean-stale-orders.ts",
    "exports": [
      {
        "name": "cleanStaleOrders",
        "kind": "function",
        "signature": "export async function cleanStaleOrders(\n    patient_id: string,\n    product_href: PRODUCT_HREF\n) {\n    //Order of operations:\n    //1. Obtain all orders for patient under product_href\n    //2. Filter fetched data for orders with order_status 'Incomplete' or 'Unapproved-CardDown' & also remove latest order\n    //3. Call an update to supabase such that we update the order status of all those orders to Administrative-Cancel.\n\n    try {\n        if (!product_href) {\n            throw new Error('No Product Href');\n        }\n\n        const getProductsToCheck = (href: PRODUCT_HREF): PRODUCT_HREF[] => {\n            switch (href) {\n                case PRODUCT_HREF.SEMAGLUTIDE:\n                case PRODUCT_HREF.TIRZEPATIDE:\n                    return [PRODUCT_HREF.SEMAGLUTIDE, PRODUCT_HREF.TIRZEPATIDE];\n                default:\n                    return [href];\n            }\n        };\n        const supabase = createSupabaseServiceClient();\n\n        const { data: orders, error: ordersError } = await supabase\n            .from('orders')\n            .select('*')\n            .eq('customer_uid', patient_id)\n            .in('product_href', getProductsToCheck(product_href))\n            .order('created_at', { ascending: false });\n\n        if (ordersError) {\n            console.error('Error fetching orders:', ordersError);\n            throw new Error(\n                `Error fetching orders for patient. ${patient_id} Logging error message: ${ordersError.message}`\n            );\n        }\n\n        if (orders.length <= 1) {\n            return Status.Failure;\n        }\n\n        const staleOrders = orders\n            .slice(1) //slice at 1 to exclude the most recent order.\n            .filter(\n                (order) =>\n                    order.order_status === 'Incomplete' ||\n                    order.order_status === 'Unapproved-CardDown'\n            );\n\n        const { error: updateError } = await supabase\n            .from('orders')\n            .update({ order_status: OrderStatus.Voided })\n            .in(\n                'id',\n                staleOrders.map((order) => order.id)\n            );\n\n        if (updateError) {\n            throw new Error(\n                `Error updating order status for patient. ${patient_id} Logging error message: ${updateError.message}`\n            );\n        }\n        return Status.Success;\n    } catch (error) {\n        console.error(error);\n        return Status.Error;\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/clean-stale-orders/clean-stale-orders.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/ManualOrderCreationDialog.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/SubscriptionList/utils/SubscriptionItem-functions.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/client-utils.ts",
    "exports": [
      {
        "name": "getURL",
        "kind": "variable",
        "signature": "getURL = () => {\n    let url =\n        process?.env?.NEXT_PUBLIC_SITE_URL ??\n        process?.env?.NEXT_PUBLIC_VERCEL_URL ??\n        'http://localhost:3000';\n    url = url.includes('http') ? url : `https://${url}`;\n    // Remove trailing slashes using replace\n    url = url.replace(/\\/+$/, '');\n    return url;\n}"
      },
      {
        "name": "convertStripePriceToDollars",
        "kind": "function",
        "signature": "export function convertStripePriceToDollars(unitAmount: number) {\n    if (typeof unitAmount !== 'number') {\n        throw new Error('Unit amount must be a number');\n    }\n    return (unitAmount / 100).toFixed(2); // Convert cents to dollars and format to 2 decimal places\n}"
      },
      {
        "name": "formatDateToMMDDYYYY",
        "kind": "function",
        "signature": "export function formatDateToMMDDYYYY(date: Date) {\n    const month = String(date.getMonth() + 1).padStart(2, '0'); // Months are zero-based\n    const day = String(date.getDate()).padStart(2, '0');\n    const year = date.getFullYear();\n\n    return `${month}/${day}/${year}`;\n}"
      },
      {
        "name": "formatDateToMMDDYYYYFacebook",
        "kind": "function",
        "signature": "export function formatDateToMMDDYYYYFacebook(date: Date) {\n    const month = String(date.getMonth() + 1).padStart(2, '0'); // Months are zero-based\n    const day = String(date.getDate()).padStart(2, '0');\n    const year = date.getFullYear();\n\n    return `${month}-${day}-${year}`;\n}"
      },
      {
        "name": "formatPhoneNumberToNumericString",
        "kind": "function",
        "signature": "export function formatPhoneNumberToNumericString(phoneNumber: string) {\n    return phoneNumber.replace(/\\D/g, '');\n}"
      },
      {
        "name": "extractRenewalOrderId",
        "kind": "function",
        "signature": "export function extractRenewalOrderId(renewal_order_id: string) {\n    const [firstPart, secondPart] = renewal_order_id.split('-').map(Number);\n    return [firstPart, secondPart];\n}"
      },
      {
        "name": "getOrderTypeFromOrderId",
        "kind": "function",
        "signature": "export function getOrderTypeFromOrderId(order_id: string) {\n    if (order_id.includes('-')) {\n        return OrderType.RenewalOrder;\n    }\n    return OrderType.Order;\n}"
      },
      {
        "name": "getActiveVWOTestIDForQuestionnaire",
        "kind": "function",
        "signature": "export function getActiveVWOTestIDForQuestionnaire(\n    vwo_test_ids: string[],\n    product_href: PRODUCT_HREF,\n) {\n    // Filter test IDs that exist in the mapping for the given product\n\n    const matchedTestIds = vwo_test_ids.filter(\n        (test_id) =>\n            VWO_TEST_QUESTIONNAIRES_VERSION_MAPPINGS[\n                product_href as PRODUCT_HREF\n            ]?.[test_id as AB_TESTS_IDS] !== undefined,\n    );\n\n    if (matchedTestIds.length >= 1) {\n        return matchedTestIds[0] as AB_TESTS_IDS;\n    } else {\n        return null;\n    }\n}"
      },
      {
        "name": "getVersionForActiveVWOTestID",
        "kind": "function",
        "signature": "export function getVersionForActiveVWOTestID(\n    vwo_test_id: AB_TESTS_IDS,\n    product_href: PRODUCT_HREF,\n) {\n    const version =\n        VWO_TEST_QUESTIONNAIRES_VERSION_MAPPINGS[product_href]?.[vwo_test_id];\n\n    return version;\n}"
      },
      {
        "name": "getCommonStringsSorted",
        "kind": "function",
        "signature": "export function getCommonStringsSorted(\n    arr1: string[],\n    arr2: string[],\n): string[] {\n    const set2 = new Set(arr2);\n    return arr1.filter((str) => set2.has(str)).sort();\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(testing_and_development)/dev/send-script-hallandale/page.tsx",
      "bioverse-client/app/utils/actions/auth/oauth.ts",
      "bioverse-client/app/utils/functions/utils.ts",
      "bioverse-client/app/utils/functions/client-utils.ts",
      "bioverse-client/app/utils/functions/rudderstack/rudderstack-utils.ts",
      "bioverse-client/app/(employee)/(provider-portal)/provider/intakes/[orderId]/page.tsx",
      "bioverse-client/app/components/coordinator-portal/tasks/utils/findNextTask.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/utils/resend-scripts.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/ManualOrderCreationDialog.tsx",
      "bioverse-client/app/components/provider-portal/tasks/utils/findNextTask.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/message/ai-response-helper/utils/ai-response-controller.ts",
      "bioverse-client/app/components/login/forms/v2/sign-up-form-v2.tsx",
      "bioverse-client/app/components/login/forms/signUpForm.tsx",
      "bioverse-client/app/components/login/CheckEmail.tsx",
      "bioverse-client/app/components/login/login-drawer/drawer-specific-forms/sign-up-form-drawer.tsx",
      "bioverse-client/app/components/login/ResetPassword.tsx",
      "bioverse-client/app/api/supabase/payment-failure/route.ts",
      "bioverse-client/app/services/mixpanel/mixpanel-utils.ts",
      "bioverse-client/app/services/pharmacy-integration/revive/revive-send-script-api.ts",
      "bioverse-client/app/services/pharmacy-integration/empower/provider-script-feedback.ts",
      "bioverse-client/app/services/pharmacy-integration/hallandale/hallandale-script-api.ts",
      "bioverse-client/app/services/pharmacy-integration/boothwyn/boothwyn-script-api.ts",
      "bioverse-client/app/services/pharmacy-integration/tmc/provider-script-feedback.ts",
      "bioverse-client/app/services/stripe/charge-customer.ts",
      "bioverse-client/app/utils/database/controller/orders/create-order.ts",
      "bioverse-client/app/utils/database/controller/orders/create-manual-order.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/custom-prescription-script/components/CustomPrescriptionConfirmationDialog.tsx",
      "bioverse-client/app/components/intake-v3/data-collection/data-collection-wl-input-v4.tsx",
      "bioverse-client/app/components/intake-v3/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component-ab.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/ed/ed-checkout/ed-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v3/account/data-collection/data-collection-new.tsx",
      "bioverse-client/app/components/intake-v2/account/data-collection/data-collection-wl.tsx",
      "bioverse-client/app/components/intake-v2/account/data-collection/data-collection.tsx",
      "bioverse-client/app/components/intake-v2/account/data-collection/data-collection-new.tsx",
      "bioverse-client/app/components/intake-v2/account/data-collection/wl-data-collection.tsx",
      "bioverse-client/app/(testing_and_development)/olivier-dev/utils.ts",
      "bioverse-client/app/utils/database/controller/renewal_orders/renewal_orders.ts",
      "bioverse-client/app/utils/database/controller/pharmacy_order_audit/pharmacy_order_audit.tsx",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/IDAndSelfieCheckJobHandler.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/SendPrescriptionJobHandler.ts",
      "bioverse-client/app/components/intake-v3/pages/up-next-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/up-next-v3-ap.tsx",
      "bioverse-client/app/components/intake-v3/pages/up-next-v3-wl.tsx",
      "bioverse-client/app/components/intake-v3/pages/pre-question.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-preview-treatment.tsx",
      "bioverse-client/app/utils/actions/questionnaires/questionnaire-actions.ts",
      "bioverse-client/app/components/intake-v2/questions/functions/questions-functions.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/coordinator-portal/time-tracker/coordinator-time-tracker-functions.ts",
    "exports": [
      {
        "name": "checkCoordinatorSessionStatus",
        "kind": "function",
        "signature": "export async function checkCoordinatorSessionStatus(\n    coordinator_id: string\n): Promise<boolean> {\n    const coordinator_activity_stream = await getCoordinatorSessionRecord(\n        coordinator_id\n    );\n\n    try {\n        if (!coordinator_activity_stream) {\n            //if there is no activity stream that indicates there is no start_session event for the current coordinator.\n            //In that event, return false to allow coordinator to start a session.\n            return false;\n        }\n\n        if (coordinator_activity_stream[0]?.action === 'end_session') {\n            return false;\n        } else {\n            const lastActivityTime = coordinator_activity_stream[0]!.timestamp;\n            const currentTime = Date.now();\n            const tenMinutesInMs = 10 * 60 * 1000; // 10 minutes in milliseconds\n\n            if (currentTime - lastActivityTime > tenMinutesInMs) {\n                console.warn(\n                    'Coordinator: ',\n                    coordinator_id,\n                    ' invoked automated session end at their last completed activity.'\n                );\n\n                await endSession(coordinator_id, lastActivityTime);\n\n                return false;\n            } else {\n                return true;\n            }\n        }\n    } catch (error) {\n        console.log(error);\n        return false;\n    }\n}"
      },
      {
        "name": "getCoordinatorArray",
        "kind": "function",
        "signature": "export async function getCoordinatorArray(): Promise<\n    CoordinatorTimeTrackerArrayItem[]\n> {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('providers')\n        .select('name, id, role')\n        .in('role', [BV_AUTH_TYPE.COORDINATOR, BV_AUTH_TYPE.LEAD_COORDINATOR]);\n\n    if (error) {\n        console.log(error);\n        return [];\n    }\n\n    const filteredData = data.filter(\n        (coordinator) =>\n            !DUMMY_COORDINATOR_ARRAY_FILTER.includes(coordinator.id)\n    );\n\n    return filteredData as CoordinatorTimeTrackerArrayItem[];\n}"
      },
      {
        "name": "fetchCoordinatorAutomaticSessionLogData",
        "kind": "function",
        "signature": "export async function fetchCoordinatorAutomaticSessionLogData({\n    selectedCoordinatorIds,\n    selectedDateSessionsHoursTab,\n    selectedTab,\n    array,\n    timeZone,\n}: FetchCoordinatorAutomaticSessionLogParams) {\n    if (selectedTab !== 0) {\n        return null;\n    }\n\n    if (!selectedDateSessionsHoursTab) {\n        return null;\n    }\n\n    const date = dayjs(selectedDateSessionsHoursTab).tz(timeZone);\n    const startOfDay = date.startOf('day');\n    const endOfDay = date.endOf('day');\n\n    if (selectedCoordinatorIds.length > 0) {\n        const sessionLogs = await Promise.all(\n            selectedCoordinatorIds.map(async (coordinatorId) => {\n                const logs = await getCoordinatorAutomaticSessionTimes(\n                    coordinatorId,\n                    startOfDay.toDate(),\n                    endOfDay.toDate()\n                );\n                return { [coordinatorId]: logs };\n            })\n        );\n        const combinedLogs = Object.assign({}, ...sessionLogs);\n        const newRows = Object.entries(combinedLogs).flatMap(\n            ([coordinatorId, sessions]) => {\n                if (!Array.isArray(sessions)) return [];\n                return sessions.map(\n                    (session: SessionLogCTT, sessionIndex: number) => ({\n                        id: coordinatorId + '_' + sessionIndex,\n                        employeeName:\n                            array.find(\n                                (coordinator) =>\n                                    coordinator.id === coordinatorId\n                            )?.name || 'Unknown',\n                        startTime: new Date(\n                            session.start_session_timestamp\n                        ).toLocaleString('en-US', { timeZone }),\n                        endTime: new Date(\n                            session.end_session_timestamp\n                        ).toLocaleString('en-US', { timeZone }),\n                        sessionsDuration: calculateDuration(\n                            Number(session.start_session_timestamp),\n                            Number(session.end_session_timestamp)\n                        ),\n                        totalHoursDaily: calculateTotalHours(sessions),\n                    })\n                );\n            }\n        );\n        newRows.sort(\n            (a, b) =>\n                new Date(b.startTime).getTime() -\n                new Date(a.startTime).getTime()\n        );\n        return newRows;\n    }\n    return null;\n}"
      },
      {
        "name": "fetchCoordinatorActivityAuditCountsData",
        "kind": "function",
        "signature": "export async function fetchCoordinatorActivityAuditCountsData({\n    selectedCoordinatorIds,\n    selectedStartDatePerformanceTab,\n    selectedEndDatePerformanceTab,\n    selectedTab,\n    array,\n    timeZone,\n}: FetchCoordinatorActivityAuditCountsParams): Promise<Record<\n    string,\n    any\n> | null> {\n    if (selectedTab !== 1) {\n        return null;\n    }\n\n    if (!selectedStartDatePerformanceTab || !selectedEndDatePerformanceTab) {\n        return null;\n    }\n\n    const startDate = dayjs(selectedStartDatePerformanceTab).tz(timeZone);\n    const endDate = dayjs(selectedEndDatePerformanceTab).tz(timeZone);\n    const startOfDay = startDate.startOf('day');\n    const endOfDay = endDate.endOf('day');\n\n    if (selectedCoordinatorIds.length > 0) {\n        const actionCounts = await Promise.all(\n            selectedCoordinatorIds.map(async (coordinatorId) => {\n                const logs =\n                    await getCoordinatorActivityAuditCountsBetweenDates(\n                        coordinatorId,\n                        startOfDay.valueOf(),\n                        endOfDay.valueOf()\n                    );\n                return { [coordinatorId]: logs };\n            })\n        );\n        const sessions = await Promise.all(\n            selectedCoordinatorIds.map(async (coordinatorId) => {\n                const sessions = await getCoordinatorAutomaticSessionTimes(\n                    coordinatorId,\n                    startOfDay.toDate(),\n                    endOfDay.toDate()\n                );\n                return { [coordinatorId]: sessions };\n            })\n        );\n        const combinedLogs: Record<string, any> = Object.assign(\n            {},\n            ...actionCounts\n        );\n        let newRows = Object.entries(combinedLogs).map(\n            ([providerId, actionCounts]) => ({\n                id: providerId + '_',\n                employeeName:\n                    array.find((provider) => provider.id === providerId)\n                        ?.name || 'Unknown',\n                hoursLogged: 'n/a',\n                messagesAnswered:\n                    actionCounts?.coordinatorMessagesAnswered || 0,\n                fwdPercentage: actionCounts?.forwardPercentage || 'n/a',\n            })\n        );\n\n        newRows.forEach((row, index) => {\n            const coordinatorId = selectedCoordinatorIds[index];\n            const coordinatorSessions = sessions.find(\n                (s) => Object.keys(s)[0] === coordinatorId\n            )?.[coordinatorId];\n            row.hoursLogged = calculateTotalHours(coordinatorSessions);\n        });\n\n        return newRows;\n    }\n    return null;\n}"
      },
      {
        "name": "fetchCoordinatorWeeklySummaryRowsData",
        "kind": "function",
        "signature": "export async function fetchCoordinatorWeeklySummaryRowsData({\n    selectedCoordinatorIds,\n    selectedStartDateWeeklySummaryTab,\n    selectedEndDateWeeklySummaryTab,\n    selectedTab,\n    array,\n    timeZone,\n}: FetchCoordinatorWeeklySummaryRowsParams) {\n    if (selectedTab !== 2) {\n        return null;\n    }\n\n    if (\n        !selectedStartDateWeeklySummaryTab ||\n        !selectedEndDateWeeklySummaryTab\n    ) {\n        return null;\n    }\n\n    const startDate = dayjs(selectedStartDateWeeklySummaryTab).tz(timeZone);\n    const endDate = dayjs(selectedEndDateWeeklySummaryTab).tz(timeZone);\n    const startOfDay = startDate.startOf('day');\n    const endOfDay = endDate.endOf('day');\n\n    if (selectedCoordinatorIds.length > 0) {\n        const sessionLogs = await Promise.all(\n            selectedCoordinatorIds.map(async (coordinatorId) => {\n                const logs = await getCoordinatorAutomaticSessionTimes(\n                    coordinatorId,\n                    startOfDay.toDate(),\n                    endOfDay.toDate()\n                );\n                return { [coordinatorId]: logs };\n            })\n        );\n        const combinedLogs = Object.assign({}, ...sessionLogs);\n        const newRows = Object.entries(combinedLogs)\n            .map(([coordinatorId, sessions]) => {\n                if (!Array.isArray(sessions)) return null;\n                const {\n                    totalHoursMonday,\n                    totalHoursTuesday,\n                    totalHoursWednesday,\n                    totalHoursThursday,\n                    totalHoursFriday,\n                    totalHoursSaturday,\n                    totalHoursSunday,\n                } = calculateTotalHoursMondayThroughFriday(sessions, timeZone);\n                return {\n                    id: coordinatorId,\n                    employeeName:\n                        array.find(\n                            (coordinator) => coordinator.id === coordinatorId\n                        )?.name || 'Unknown',\n                    hoursM: totalHoursMonday,\n                    hoursT: totalHoursTuesday,\n                    hoursW: totalHoursWednesday,\n                    hoursTh: totalHoursThursday,\n                    hoursF: totalHoursFriday,\n                    hoursSa: totalHoursSaturday,\n                    hoursSu: totalHoursSunday,\n                    weeklyTotal: calculateTotalHours(sessions),\n                    weeklyEarnings: 'n/a',\n                };\n            })\n            .filter((row): row is WeeklySummaryRowCTT => row !== null);\n        return newRows;\n    }\n    return null;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/coordinator-portal/time-tracker/coordinator-time-tracker-functions.ts",
      "bioverse-client/app/components/coordinator-portal/navbar/start-session-button/start-session-button.tsx",
      "bioverse-client/app/(employee)/(coordinator-portal)/coordinator/track-hours/page.tsx",
      "bioverse-client/app/components/coordinator-portal/track-hours/coordinator-time-tracker-content.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/coordinator-portal/time-tracker/coordinator-time-tracker-types.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/functions/csv_convert_download.ts",
    "exports": [
      {
        "name": "convertToCSV",
        "kind": "function",
        "signature": "export function convertToCSV(\n    data: any[],\n    excludeColumns: string[] = []\n): string {\n    if (!data || data.length === 0) return '';\n\n    const allHeaders = Object.keys(data[0]);\n    const headers = allHeaders.filter(\n        (header) => !excludeColumns.includes(header)\n    );\n\n    const csvRows = [\n        headers.join(','),\n        ...data.map((row) =>\n            headers.map((header) => JSON.stringify(row[header] ?? '')).join(',')\n        ),\n    ];\n\n    return csvRows.join('\\n');\n}"
      },
      {
        "name": "downloadCSV",
        "kind": "function",
        "signature": "export function downloadCSV(\n    data: any[],\n    filename: string,\n    excludeColumns: string[] = []\n): void {\n    const csvContent = convertToCSV(data, excludeColumns);\n    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n    const link = document.createElement('a');\n    if (link.download !== undefined) {\n        const url = URL.createObjectURL(blob);\n        link.setAttribute('href', url);\n        link.setAttribute('download', filename);\n        link.style.visibility = 'hidden';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/csv_convert_download.ts",
      "bioverse-client/app/components/provider-portal/csv-download/TXPatientCSV.tsx",
      "bioverse-client/app/components/coordinator-portal/upcoming-list/upcoming-page-component.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/customerio/utils.ts",
    "exports": [
      {
        "name": "formatE164",
        "kind": "function",
        "signature": "export function formatE164(phoneNumber: string): string {\n    // Define the country code, in this case for the United States\n    const countryCode = '+1';\n\n    // Remove all non-numeric characters from the phone number\n    const cleanedNumber = phoneNumber.replace(/\\D/g, '');\n\n    // Concatenate the country code with the cleaned number\n    const e164Number = countryCode + cleanedNumber;\n\n    return e164Number;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/customerio/utils.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/info/info-edit-dialog.tsx",
      "bioverse-client/app/components/patient-portal/account-information/personal-information/account-edit-drawer.tsx",
      "bioverse-client/app/components/intake-v3/data-collection/data-collection-wl-input-v4.tsx",
      "bioverse-client/app/components/intake-v3/account/data-collection/data-collection-new.tsx",
      "bioverse-client/app/components/intake-v2/account/data-collection/data-collection-wl.tsx",
      "bioverse-client/app/components/intake-v2/account/data-collection/data-collection.tsx",
      "bioverse-client/app/components/intake-v2/account/data-collection/data-collection-new.tsx",
      "bioverse-client/app/components/intake-v2/account/data-collection/wl-data-collection.tsx",
      "bioverse-client/app/services/customerio/customerioApiFactory.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/dates.ts",
    "exports": [
      {
        "name": "getDateHourDifference",
        "kind": "variable",
        "signature": "getDateHourDifference = (dateA: Date, dateB: Date): number => {\n    if(!dateA  || !dateB){\n        return 0\n    }\n    const diffInMs = Math.abs(Number(dateB) - Number(dateA));\n    return Math.round(diffInMs / (1000 * 60 * 60));\n}"
      },
      {
        "name": "getDateDayDifference",
        "kind": "variable",
        "signature": "getDateDayDifference = (dateA: Date, dateB: string): number | null => {\n    if(!dateA  || !dateB){\n        return 0\n    }\n    const dateBDate = new Date(dateB);\n\n    // Calculate the difference in milliseconds\n    const diffInMs = Math.abs(dateBDate.getTime() - dateA.getTime());\n\n    // Convert milliseconds to days\n    const totalDays = diffInMs / (1000 * 60 * 60 * 24);\n\n    return totalDays;\n}"
      },
      {
        "name": "getDateMonthDifference",
        "kind": "variable",
        "signature": "getDateMonthDifference = (dateA: Date, dateB: string): number => {\n    const dateBMillis = dateB;\n    const dateBDate = new Date(dateBMillis);\n\n      const diffInMs = Math.abs(dateBDate.getTime() - dateA.getTime());\n      \n      const avgDaysInMonth = 30.44; // Approximate average number of days in a month\n      const totalDays = diffInMs / (1000 * 60 * 60 * 24); // Convert milliseconds to days\n      const monthDifference = Math.round(totalDays / avgDaysInMonth);\n      \n      return monthDifference;\n}"
      },
      {
        "name": "addDeltaToDate",
        "kind": "variable",
        "signature": "addDeltaToDate = (\n    dateA: Date,\n    delta: number,\n    mode: string,\n): Date => {\n    const result = new Date(dateA);\n\n    \n    if (mode == 'w') {\n        result.setDate(result.getDate() + delta * 7);\n    } else if (mode == 'd') {\n        result.setDate(result.getDate() + delta);\n    }\n    return result;\n}"
      },
      {
        "name": "convertEpochToDate",
        "kind": "variable",
        "signature": "convertEpochToDate = (epoch: number): Date => {\n    return new Date(epoch * 1000);\n}"
      },
      {
        "name": "convertDateToEpoch",
        "kind": "variable",
        "signature": "convertDateToEpoch = (date: Date): number => {\n    return Math.floor(date.getTime() / 1000); // Convert milliseconds to seconds\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(administration)/admin/order-administration/_components/administrator-order-table.tsx",
      "bioverse-client/app/utils/actions/admin/parsers.ts",
      "bioverse-client/app/utils/functions/dates.ts",
      "bioverse-client/_deprecated/provider_dashboard/order-table-new-(deprecataed).tsx",
      "bioverse-client/_deprecated/clinical-intake-flow/order-table/components/order-table-new.tsx",
      "bioverse-client/_deprecated/clinical-intake-flow/order-table/components/order-table.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/CancelSubscription/CancelSubscriptionConfirm.tsx",
      "bioverse-client/app/(testing_and_development)/olivier-dev/utils.ts",
      "bioverse-client/app/components/patient-portal/subscriptions/components/ChangeRefillDate/ChangeRefillDate.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/ChangeRefillDate/confirm/ConfirmRefillData.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/ChangeRefillDate/ChangeRefillQuestionItem.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/CancelSubscription/refill/ChangeRefillOffer.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/CancelSubscription/refill/ChangeRefillOfferItem.tsx",
      "bioverse-client/app/(administration)/admin/stripe-api/stripe-api-actions.ts",
      "bioverse-client/app/utils/database/controller/renewal_orders/renewal_orders.ts",
      "bioverse-client/app/utils/database/controller/orders/create-manual-order.ts",
      "bioverse-client/app/utils/database/controller/messaging/messages/messages.ts",
      "bioverse-client/app/utils/classes/Dashboard.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/ManualOrderCreationDialog.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/utils/intake-helpers.ts",
      "bioverse-client/app/components/patient-portal/subscriptions/components/ChangeRefillDate/confirmed/ConfirmedRefill.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/SubscriptionList/SubscriptionItem.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/refill/[subscription_id]/confirm/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/refill/[subscription_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/cancel-flow/[subscription_id]/information/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/cancel-flow/[subscription_id]/change-refill/page.tsx",
      "bioverse-client/app/services/stripe/subscriptions.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/subscriptions/components/change-cadence-dialog/change-cadence-dialog.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/formatting.ts",
    "exports": [
      {
        "name": "getFormattedCadence",
        "kind": "function",
        "signature": "export function getFormattedCadence(cadence: string | SubscriptionCadency) {\n    switch (cadence) {\n        case SubscriptionCadency.Monthly:\n            return 'Monthly';\n        case SubscriptionCadency.Quarterly:\n            return 'Quarterly';\n        case SubscriptionCadency.Bimonthly:\n            return 'Bimonthly';\n        case SubscriptionCadency.OneTime:\n            return 'One-Time';\n        case SubscriptionCadency.Pentamonthly:\n            return 'Pentamonthly';\n        case SubscriptionCadency.Biannually:\n            return 'Biannually';\n        case SubscriptionCadency.Annually:\n            return 'Annually';\n        default:\n            return 'Unknown';\n    }\n}"
      },
      {
        "name": "formatDateNonAsync",
        "kind": "function",
        "signature": "export function formatDateNonAsync(isoDateString: string | Date) {\n    const date = new Date(isoDateString);\n    const monthNames = [\n        'Jan',\n        'Feb',\n        'Mar',\n        'Apr',\n        'May',\n        'Jun',\n        'Jul',\n        'Aug',\n        'Sep',\n        'Oct',\n        'Nov',\n        'Dec',\n    ];\n    const day = date.getDate();\n    const monthIndex = date.getMonth();\n    const year = date.getFullYear();\n    const hours = date.getHours();\n    const minutes = date.getMinutes();\n    const ampm = hours >= 12 ? 'PM' : 'AM';\n    const formattedHours = hours % 12 || 12; // the hour '0' should be '12'\n    const formattedMinutes = minutes < 10 ? '0' + minutes : minutes;\n\n    return `${monthNames[monthIndex]} ${day}, ${year}`;\n}"
      },
      {
        "name": "formatDateFullMonth",
        "kind": "function",
        "signature": "export function formatDateFullMonth(date: Date): string {\n    return new Intl.DateTimeFormat('en-US', {\n        month: 'long',\n        day: 'numeric',\n        year: 'numeric',\n    }).format(date);\n}"
      },
      {
        "name": "getProductName",
        "kind": "function",
        "signature": "export function getProductName(href: string): string {\n    const productMap: Record<string, string> = {\n        [PRODUCT_HREF.NAD_INJECTION]: PRODUCT_NAME.NAD_INJECTION,\n        [PRODUCT_HREF.NAD_NASAL_SPRAY]: PRODUCT_NAME.NAD_NASAL_SPRAY,\n        [PRODUCT_HREF.NAD_PATCHES]: PRODUCT_NAME.NAD_PATCHES,\n        [PRODUCT_HREF.OZEMPIC]: PRODUCT_NAME.OZEMPIC,\n        [PRODUCT_HREF.WEGOVY]: PRODUCT_NAME.WEGOVY,\n        [PRODUCT_HREF.TIRZEPATIDE]: PRODUCT_NAME.TIRZEPATIDE,\n        [PRODUCT_HREF.CGM_SENSOR]: PRODUCT_NAME.CGM_SENSOR,\n        [PRODUCT_HREF.METFORMIN]: PRODUCT_NAME.METFORMIN,\n        [PRODUCT_HREF.ACARBOSE]: PRODUCT_NAME.ACARBOSE,\n        [PRODUCT_HREF.TELMISARTAN]: PRODUCT_NAME.TELMISARTAN,\n        [PRODUCT_HREF.ATORVASTATIN]: PRODUCT_NAME.ATORVASTATIN,\n        [PRODUCT_HREF.RAPAMYCIN]: PRODUCT_NAME.RAPAMYCIN,\n        [PRODUCT_HREF.B12_INJECTION]: PRODUCT_NAME.B12_INJECTION,\n        [PRODUCT_HREF.B12_MIC_INJECTION]: PRODUCT_NAME.B12_MIC_INJECTION,\n        [PRODUCT_HREF.GLUTATIONE_INJECTION]: PRODUCT_NAME.GLUTATIONE_INJECTION,\n        [PRODUCT_HREF.GLUTATHIONE_NASAL_SPRAY]:\n            PRODUCT_NAME.GLUTATHIONE_NASAL_SPRAY,\n        [PRODUCT_HREF.GLUTATHIONE_PATCHES]: PRODUCT_NAME.GLUTATHIONE_PATCHES,\n        [PRODUCT_HREF.LOW_DOSE_NALTREXONE]: PRODUCT_NAME.LOW_DOSE_NALTREXONE,\n        [PRODUCT_HREF.FINASTERIDE_AND_MINOXIDIL]:\n            PRODUCT_NAME.FINASTERIDE_AND_MINOXIDIL,\n        [PRODUCT_HREF.TADALAFIL_DAILY]: PRODUCT_NAME.TADALAFIL_DAILY,\n        [PRODUCT_HREF.TADALAFIL_AS_NEEDED]: PRODUCT_NAME.TADALAFIL_AS_NEEDED,\n        [PRODUCT_HREF.NAD_FACE_CREAM]: PRODUCT_NAME.NAD_FACE_CREAM,\n        [PRODUCT_HREF.TRETINOIN]: PRODUCT_NAME.TRETINOIN,\n        [PRODUCT_HREF.MOUNJARO]: PRODUCT_NAME.MOUNJARO,\n        [PRODUCT_HREF.SEMAGLUTIDE]: PRODUCT_NAME.SEMAGLUTIDE,\n        [PRODUCT_HREF.ZEPBOUND]: PRODUCT_NAME.ZEPBOUND,\n        [PRODUCT_HREF.WEIGHT_LOSS]: PRODUCT_NAME.WEIGHT_LOSS,\n        [PRODUCT_HREF.OZEMPIC_TEST]: PRODUCT_NAME.OZEMPIC_TEST,\n    };\n\n    const productName = productMap[href];\n\n    if (!productName) {\n        return 'Unknown';\n    }\n    return productName;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/classes/Dashboard.ts",
      "bioverse-client/app/utils/functions/formatting.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/custom-prescription-script/components/CustomPrescriptionConfirmationDialog.tsx",
      "bioverse-client/app/components/patient-portal/dosage-selection-first-time/components/FirstTimeAlmostDone.tsx",
      "bioverse-client/app/(testing_and_development)/olivier-dev/utils.ts",
      "bioverse-client/app/utils/database/controller/products/products.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/custom-prescription-script/custom-prescription-script.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/quarterly-final-review-dialog/quarterly-final-review-dialog-content.tsx",
      "bioverse-client/app/components/patient-portal/dosage-selection-first-time/components/utils.ts",
      "bioverse-client/app/components/patient-portal/dosage-selection-first-time/components/FirstTimeDosingOption.tsx",
      "bioverse-client/app/components/patient-portal/check-up-requested/refill-preference/components/dosage-option.tsx",
      "bioverse-client/app/components/patient-portal/check-up-requested/refill-preference/components/dosage-option-v2.tsx",
      "bioverse-client/app/components/patient-portal/check-up-requested/almost-done/almost-done-screen-v2.tsx",
      "bioverse-client/app/components/patient-portal/check-up-requested/almost-done/almost-done-screen.tsx",
      "bioverse-client/app/components/patient-portal/alternative-selection/weight-loss/alternative-checkout/alt-checkout-summary.tsx",
      "bioverse-client/app/components/patient-portal/alternative-selection/weight-loss/option-selection/option-select-card/option-select-card.tsx",
      "bioverse-client/app/components/intake-v3/checkout/order-summary-v3/wl-order-summary-ab.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/wl-goal-transition-v3.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/wl-goal-transition.tsx",
      "bioverse-client/app/api/easypost/route.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-graph/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/wl-graph-v3/page.tsx",
      "bioverse-client/app/services/easypost/easypost-tracker.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/generateUUIDFromStringAndNumber.ts",
    "exports": [
      {
        "name": "generateUUIDFromStringAndNumber",
        "kind": "function",
        "signature": "export function generateUUIDFromStringAndNumber(\n    inputString: string,\n    event: string,\n    number: number\n) {\n    const randomBytes = require('crypto').randomBytes(16); // Generate 16 random bytes as salt\n    const hash = createHash('sha256');\n    hash.update(\n        inputString + number.toString() + event + randomBytes.toString('hex')\n    ); // Combine input string, number, and salt\n    return hash.digest('hex');\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/generateUUIDFromStringAndNumber.ts",
      "bioverse-client/app/components/intake-v3/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component-ab.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v3/pages/question-id-pre-signup.tsx",
      "bioverse-client/app/components/intake-v3/pages/shipping-information-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/id-verification-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/pre-question-id-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/id-verification-noskip-v3.tsx",
      "bioverse-client/app/components/intake-v2/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/components/wl-checkout-component-fulltest.tsx",
      "bioverse-client/app/components/intake-v2/checkout/checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/pages/id-verification.tsx",
      "bioverse-client/app/components/intake-v2/pages/shipping-information.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/intake-route-controller.ts",
    "exports": [
      {
        "name": "getNextIntakeRoute",
        "kind": "function",
        "signature": "export function getNextIntakeRoute(\n    currentPath: string,\n    product_href: string,\n    searchParams: string,\n    first: boolean = false,\n    subscription_cadence: string = 'none',\n    selected_product?: string\n): string {\n    /**\n     * We need to determine the current route based on the full url path.\n     * Since the 'questions' routes have extra index in their array of url components (i.e. .../questions/166?...)...\n     * ...we need to first check if the current path is a questions route so we know to access the second to last index (instead of the last index).\n     * To check if the current path is a questions route, we first need to figure out what the questions route would be called given the current test_id.\n     */\n    const searchParamsFormat = new URLSearchParams(searchParams);\n    const test_id = searchParamsFormat.get('test_id');\n\n    const vwo_test_ids: string[] =\n        typeof window !== 'undefined'\n            ? JSON.parse(localStorage.getItem('vwo_ids') || '[]')\n            : [];\n\n    const pathArray = currentPath.split('/');\n\n    const testIDtoQuestionsRouteNameMapping: {\n        //deprecated\n        [key: string]: INTAKE_ROUTE | INTAKE_ROUTE_V3;\n    } = {\n        'wl-v3': INTAKE_ROUTE_V3.QUESTIONS, //deprecated\n        default: INTAKE_ROUTE.QUESTIONS,\n    };\n\n    //determine what the questions route would be called given the current test_id\n    var questionsRoute: string =\n        test_id && testIDtoQuestionsRouteNameMapping[test_id]\n            ? testIDtoQuestionsRouteNameMapping['test_id']\n            : testIDtoQuestionsRouteNameMapping['default'];\n\n    //////\n    // delete soon\n    if (\n        product_href === 'semaglutide' ||\n        product_href === 'tirzepatide' ||\n        product_href === 'weight-loss' ||\n        product_href === PRODUCT_HREF.B12_INJECTION ||\n        product_href === PRODUCT_HREF.NAD_INJECTION\n    ) {\n        questionsRoute = INTAKE_ROUTE_V3.QUESTIONS;\n    }\n    //////\n\n    let next_route_string: string;\n\n    console.log('PATH ARRAY', pathArray);\n\n    //determine the current route\n    let currentRoute =\n        pathArray[pathArray.length - 2] === questionsRoute\n            ? questionsRoute\n            : pathArray[pathArray.length - 1];\n\n    // Temp fix:\n    if (pathArray.includes(INTAKE_ROUTE_V3.PRE_QUESTIONS)) {\n        currentRoute = INTAKE_ROUTE_V3.PRE_QUESTIONS;\n    }\n\n    //if the current route is a vwo replacement route, replace it with the equivalent non-test route to ensure the system works as if the test never happened.\n    const vwo_reversion_result =\n        replaceVWOSplitRouteWithOriginalIfNecessary(currentRoute);\n\n    if (vwo_reversion_result.replaced) {\n        currentRoute = vwo_reversion_result.replacement_route;\n    }\n\n    /**\n     * determine the type of flow the product is in via elimination.\n     */\n    switch (product_href) {\n        case PRODUCT_HREF.WEIGHT_LOSS: {\n            //indicator of first route is given as true or false\n            const current_version =\n                LATEST_INTAKE_VERSIONS.combined_weight_loss.latest_version;\n\n            // console.log(\n            //     'WL Route Object',\n            //     COMBINED_WEIGHT_LOSS_ROUTES[current_version]\n            // );\n\n            const combined_route_array = getRouteArrayForTest(\n                COMBINED_WEIGHT_LOSS_ROUTES[current_version],\n                vwo_test_ids\n            );\n            // console.log('combined_route_array', combined_route_array);\n\n            if (first) {\n                next_route_string = combined_route_array[0];\n                break;\n            }\n\n            const indexFound = combined_route_array.indexOf(currentRoute);\n\n            //skip over the supply page if they have picked metformin\n            if (selected_product === PRODUCT_HREF.METFORMIN) {\n                if (\n                    currentRoute === INTAKE_ROUTE.WEIGHT_LOSS_IN_GOOD_HANDS ||\n                    currentRoute === INTAKE_ROUTE_V3.WEIGHT_LOSS_INTRO_3\n                ) {\n                    next_route_string = combined_route_array[indexFound + 2];\n                    break;\n                }\n                //temp fix to skip calculating and graph screens if they picked metformin once they've finished up their questions\n                //811 is the \"anything else you want to tell provider\" and 290 is florida consent\n                if (\n                    currentPath.includes('questions/811') ||\n                    currentPath.includes('questions-v3/811') ||\n                    currentPath.includes('questions-v3/290') ||\n                    currentPath.includes('questions/290')\n                ) {\n                    if (test_id !== 'wl-wot') {\n                        next_route_string =\n                            combined_route_array[indexFound + 3];\n                        break;\n                    }\n                }\n            }\n\n            /**\n             * Hard coding here the route for the WL capsule product cadence selection.\n             * This is because the WL capsule product has a different cadence selection route than the other products.\n             */\n            if (selected_product === PRODUCT_HREF.WL_CAPSULE) {\n                if (currentRoute === INTAKE_ROUTE_V3.WEIGHT_LOSS_INTRO_3) {\n                    next_route_string =\n                        INTAKE_ROUTE_V3.WL_CAPSULE_CADENCE_SELECTION;\n                    break;\n                }\n            }\n\n            next_route_string = combined_route_array[indexFound + 1];\n            break;\n        }\n\n        case PRODUCT_HREF.SEMAGLUTIDE: {\n            const current_version =\n                LATEST_INTAKE_VERSIONS.semaglutide.latest_version;\n\n            const route_array = getRouteArrayForTest(\n                SEMAGLUTIDE_ROUTES[current_version],\n                vwo_test_ids\n            );\n\n            if (first) {\n                next_route_string = route_array[0];\n                break;\n            }\n\n            const indexFound = route_array.indexOf(currentRoute);\n            if (!indexFound || indexFound === -1) {\n                console.error('Route not found in the route array');\n            }\n            console.log('INDEX', indexFound);\n\n            if (\n                subscription_cadence === 'quarterly' &&\n                currentRoute === INTAKE_ROUTE.WEIGHT_LOSS_SUPPLY\n            ) {\n                next_route_string = route_array[indexFound + 2];\n                break;\n            }\n\n            next_route_string = route_array[indexFound + 1];\n            console.log('NEXT ROUTE STRING', next_route_string);\n            break;\n        }\n        case PRODUCT_HREF.TIRZEPATIDE: {\n            const current_version =\n                LATEST_INTAKE_VERSIONS.tirzepatide.latest_version;\n\n            const route_array = getRouteArrayForTest(\n                TIRZEPATIDE_ROUTES[current_version],\n                vwo_test_ids\n            );\n\n            if (first) {\n                next_route_string = route_array[0];\n                break;\n            }\n\n            const indexFound = route_array.indexOf(currentRoute);\n            if (!indexFound || indexFound === -1) {\n                console.error('Route not found in the route array');\n            }\n\n            if (\n                subscription_cadence === 'quarterly' &&\n                currentRoute === INTAKE_ROUTE.WEIGHT_LOSS_SUPPLY\n            ) {\n                next_route_string = route_array[indexFound + 2];\n                break;\n            }\n\n            //we don't have a 'reviews' route for tirzepatide yet, so just skip it in v3 funnel\n            // if (\n            //     product_href === PRODUCT_HREF.TIRZEPATIDE &&\n            //     (currentRoute === INTAKE_ROUTE_V3.ORDER_SUMMARY ||\n            //         currentRoute === INTAKE_ROUTE.ORDER_SUMMARY)\n            // ) {\n            //     return route_array[indexFound + 2];\n            // }\n\n            next_route_string = route_array[indexFound + 1];\n            break;\n        }\n\n        case PRODUCT_HREF.NAD_INJECTION: {\n            const current_version = LATEST_INTAKE_VERSIONS.nad.latest_version;\n            if (first) {\n                next_route_string =\n                    NAD_INTAKE_ROUTES[current_version].route_array[0];\n                break;\n            }\n\n            const indexFound =\n                NAD_INTAKE_ROUTES[current_version].route_array.indexOf(\n                    currentRoute\n                );\n            next_route_string =\n                NAD_INTAKE_ROUTES[current_version].route_array[indexFound + 1];\n            break;\n        }\n\n        case PRODUCT_HREF.GLUTATIONE_INJECTION: {\n            const current_version =\n                LATEST_INTAKE_VERSIONS.glutathione.latest_version;\n            if (first) {\n                next_route_string =\n                    GLUTATHIONE_INTAKE_ROUTES[current_version].route_array[0];\n                break;\n            }\n\n            const indexFound =\n                GLUTATHIONE_INTAKE_ROUTES[current_version].route_array.indexOf(\n                    currentRoute\n                );\n            next_route_string =\n                GLUTATHIONE_INTAKE_ROUTES[current_version].route_array[\n                    indexFound + 1\n                ];\n            break;\n        }\n\n        case PRODUCT_HREF.B12_INJECTION: {\n            const current_version = LATEST_INTAKE_VERSIONS.b12.latest_version;\n            if (first) {\n                next_route_string =\n                    B12_INTAKE_ROUTES[current_version].route_array[0];\n                break;\n            }\n\n            const indexFound =\n                B12_INTAKE_ROUTES[current_version].route_array.indexOf(\n                    currentRoute\n                );\n            next_route_string =\n                B12_INTAKE_ROUTES[current_version].route_array[indexFound + 1];\n            break;\n        }\n\n        case PRODUCT_HREF.METFORMIN: {\n            const current_version =\n                LATEST_INTAKE_VERSIONS.metformin.latest_version;\n            if (first) {\n                next_route_string =\n                    METFORMIN_INTAKE_ROUTES[current_version].route_array[0];\n                break;\n            }\n\n            const indexFound =\n                METFORMIN_INTAKE_ROUTES[current_version].route_array.indexOf(\n                    currentRoute\n                );\n            next_route_string =\n                METFORMIN_INTAKE_ROUTES[current_version].route_array[\n                    indexFound + 1\n                ];\n            break;\n        }\n\n        case PRODUCT_HREF.NAD_NASAL_SPRAY: {\n            const current_version =\n                LATEST_INTAKE_VERSIONS.nad_nasal.latest_version;\n            if (first) {\n                next_route_string =\n                    NAD_NASAL_SPRAY_INTAKE_ROUTES[current_version]\n                        .route_array[0];\n                break;\n            }\n\n            const indexFound =\n                NAD_NASAL_SPRAY_INTAKE_ROUTES[\n                    current_version\n                ].route_array.indexOf(currentRoute);\n            next_route_string =\n                NAD_NASAL_SPRAY_INTAKE_ROUTES[current_version].route_array[\n                    indexFound + 1\n                ];\n            break;\n        }\n\n        case PRODUCT_HREF.ED_GLOBAL: {\n            const current_version = LATEST_INTAKE_VERSIONS.ed.latest_version;\n            if (first) {\n                next_route_string =\n                    ED_GLOBAL_INTAKE_ROUTES[current_version].route_array[0];\n                break;\n            }\n\n            const indexFound =\n                ED_GLOBAL_INTAKE_ROUTES[current_version].route_array.indexOf(\n                    currentRoute\n                );\n            next_route_string =\n                ED_GLOBAL_INTAKE_ROUTES[current_version].route_array[\n                    indexFound + 1\n                ];\n            break;\n        }\n        case PRODUCT_HREF.RUSH_MELTS: {\n            const current_version =\n                LATEST_INTAKE_VERSIONS[product_href].latest_version;\n            if (first) {\n                next_route_string =\n                    RUSH_MELTS_INTAKE_ROUTES[current_version].route_array[0];\n                break;\n            }\n\n            const indexFound =\n                RUSH_MELTS_INTAKE_ROUTES[current_version].route_array.indexOf(\n                    currentRoute\n                );\n            next_route_string =\n                RUSH_MELTS_INTAKE_ROUTES[current_version].route_array[\n                    indexFound + 1\n                ];\n            break;\n        }\n\n        case PRODUCT_HREF.PEAK_CHEWS:\n\n        case PRODUCT_HREF.RUSH_CHEWS: {\n            const current_version =\n                LATEST_INTAKE_VERSIONS[product_href].latest_version;\n            if (first) {\n                next_route_string =\n                    ED_PRODUCT_INTAKE_ROUTES[current_version].route_array[0];\n                break;\n            }\n\n            const indexFound =\n                ED_PRODUCT_INTAKE_ROUTES[current_version].route_array.indexOf(\n                    currentRoute\n                );\n            next_route_string =\n                ED_PRODUCT_INTAKE_ROUTES[current_version].route_array[\n                    indexFound + 1\n                ];\n            break;\n        }\n\n        case PRODUCT_HREF.X_MELTS:\n        case PRODUCT_HREF.X_CHEWS: {\n            const current_version =\n                LATEST_INTAKE_VERSIONS[product_href].latest_version;\n            if (first) {\n                next_route_string =\n                    ED_X_PRODUCTS_INTAKE_ROUTES[current_version].route_array[0];\n                break;\n            }\n\n            const indexFound =\n                ED_X_PRODUCTS_INTAKE_ROUTES[\n                    current_version\n                ].route_array.indexOf(currentRoute);\n            next_route_string =\n                ED_X_PRODUCTS_INTAKE_ROUTES[current_version].route_array[\n                    indexFound + 1\n                ];\n            break;\n        }\n        case PRODUCT_HREF.TRETINOIN: {\n            const current_version =\n                LATEST_INTAKE_VERSIONS['skincare'].latest_version;\n            if (first) {\n                next_route_string =\n                    SKINCARE_INTAKE_ROUTES[current_version].route_array[0];\n                break;\n            }\n\n            const indexFound =\n                SKINCARE_INTAKE_ROUTES[current_version].route_array.indexOf(\n                    currentRoute\n                );\n            next_route_string =\n                SKINCARE_INTAKE_ROUTES[current_version].route_array[\n                    indexFound + 1\n                ];\n            break;\n        }\n\n        case PRODUCT_HREF.SERMORELIN: {\n            const current_version = LATEST_INTAKE_VERSIONS.sermorelin.latest_version;\n            const route_array = SERMORELIN_ROUTES[current_version].route_array;\n\n            if (first) {\n                next_route_string = route_array[0];\n                break;\n            }\n\n            // For sermorelin, we need to handle v3 route names\n            let currentRoute = pathArray[pathArray.length - 2] === INTAKE_ROUTE_V3.QUESTIONS\n                ? INTAKE_ROUTE_V3.QUESTIONS\n                : pathArray[pathArray.length - 1];\n\n            // Check if we're in the questions flow\n            if (currentRoute === INTAKE_ROUTE_V3.QUESTIONS || !isNaN(parseInt(currentRoute))) {\n                // If we're on question 2356 or the questions route, go to select-supply-ap\n                if (currentRoute === '2356' || currentRoute === INTAKE_ROUTE_V3.QUESTIONS) {\n                    const selectSupplyIndex = route_array.indexOf('select-supply-ap');\n                    if (selectSupplyIndex !== -1) {\n                        next_route_string = route_array[selectSupplyIndex];\n                        break;\n                    }\n                }\n                // For other questions, continue to next question\n                const questionsIndex = route_array.indexOf(INTAKE_ROUTE_V3.QUESTIONS);\n                if (questionsIndex !== -1) {\n                    next_route_string = route_array[questionsIndex + 1];\n                    break;\n                }\n            }\n\n            // If not found directly, check for v3 route variants\n            const v3RouteVariants = [\n                'pre-id-v3-ap',\n                INTAKE_ROUTE_V3.PRE_ID_VERIFICATION_AP,\n                'id-verification-v3',\n                INTAKE_ROUTE_V3.ID_VERIFICATION,\n                'shipping-information-v3',\n                INTAKE_ROUTE_V3.SHIPPING_INFORMATION,\n                'new-checkout-v3',\n                INTAKE_ROUTE_V3.NEW_CHECKOUT\n            ];\n\n            // Check if current route matches any variant\n            const matchingVariant = v3RouteVariants.find(variant => \n                variant === currentRoute\n            );\n\n            if (matchingVariant) {\n                const routeIndex = route_array.indexOf(matchingVariant);\n                if (routeIndex !== -1) {\n                    next_route_string = route_array[routeIndex + 1];\n                    break;\n                }\n            }\n\n            // Try to find the route in the array\n            const indexFound = route_array.indexOf(currentRoute);\n            if (indexFound === -1) {\n                console.error('Route not found in the route array:', currentRoute);\n                next_route_string = route_array[0];\n                break;\n            }\n\n            next_route_string = route_array[indexFound + 1];\n            break;\n        }\n\n\n        default: {\n            const current_version =\n                LATEST_INTAKE_VERSIONS.standard.latest_version;\n            console.log('current_version', current_version);\n\n            if (first) {\n                next_route_string =\n                    STANDARD_INTAKE_ROUTES[current_version].route_array[0];\n                break;\n            }\n            const indexFound =\n                STANDARD_INTAKE_ROUTES[current_version].route_array.indexOf(\n                    currentRoute\n                );\n            next_route_string =\n                STANDARD_INTAKE_ROUTES[current_version].route_array[\n                    indexFound + 1\n                ];\n            break;\n        }\n    }\n\n    console.log('CHECK CHEK CHECK', vwo_test_ids);\n\n    if (!isEmpty(vwo_test_ids) && !vwo_reversion_result.replaced) {\n        next_route_string = convertIntakeRouteToVWOStitchedRoute(\n            vwo_test_ids,\n            next_route_string,\n            product_href as PRODUCT_HREF\n        );\n    }\n\n    return next_route_string;\n}"
      },
      {
        "name": "getCurrentIntakeProgressBySection",
        "kind": "function",
        "signature": "export function getCurrentIntakeProgressBySection(\n    currentPath: string,\n    product_href: string\n) {\n    let routesArray;\n    // console.log(`logging current path ${currentPath}`);\n    const currentPathArray = currentPath.split('/');\n\n    const vwo_test_ids: string[] =\n        typeof window !== 'undefined'\n            ? JSON.parse(localStorage.getItem('vwo_ids') || '[]')\n            : [];\n\n    let currentRoute = '';\n    if (currentPathArray.includes(INTAKE_ROUTE_V3.PRE_QUESTIONS)) {\n        currentRoute = INTAKE_ROUTE_V3.PRE_QUESTIONS;\n    } else if (\n        product_href === PRODUCT_HREF.WEIGHT_LOSS ||\n        vwo_test_ids.includes(AB_TESTS_IDS.WL_HERS_FUNNEL) ||\n        product_href === PRODUCT_HREF.SEMAGLUTIDE ||\n        product_href === PRODUCT_HREF.TIRZEPATIDE ||\n        product_href === PRODUCT_HREF.B12_INJECTION ||\n        product_href === PRODUCT_HREF.NAD_INJECTION ||\n        product_href === PRODUCT_HREF.SERMORELIN\n    ) {\n        currentRoute =\n            currentPathArray[currentPathArray.length - 2] ===\n            INTAKE_ROUTE_V3.QUESTIONS\n                ? INTAKE_ROUTE_V3.QUESTIONS\n                : currentPathArray[currentPathArray.length - 1];\n    } else {\n        currentRoute =\n            currentPathArray[currentPathArray.length - 2] ===\n            INTAKE_ROUTE.QUESTIONS\n                ? INTAKE_ROUTE.QUESTIONS\n                : currentPathArray[currentPathArray.length - 1];\n    }\n\n    if (currentPath.includes('ed-selection')) {\n        currentRoute = INTAKE_ROUTE.ED_SELECTION;\n        //since the ed-global architecture appends more url components to the currentPath array at ed-selection, the [currentPathArray.length - 1] logic won't work\n    }\n\n    switch (product_href) {\n        case PRODUCT_HREF.METFORMIN:\n            routesArray = METFORMIN_INTAKE_ROUTES[1].route_array;\n            break;\n        case PRODUCT_HREF.B12_INJECTION:\n            routesArray = B12_INTAKE_ROUTES[2].route_array;\n            break;\n        case PRODUCT_HREF.TRETINOIN:\n            routesArray = SKINCARE_INTAKE_ROUTES[2].route_array;\n            break;\n        case PRODUCT_HREF.NAD_NASAL_SPRAY:\n            routesArray = NAD_NASAL_SPRAY_INTAKE_ROUTES[1].route_array;\n            break;\n        case PRODUCT_HREF.ED_GLOBAL:\n            routesArray = ED_GLOBAL_INTAKE_ROUTES[1].route_array;\n            break;\n        case PRODUCT_HREF.PEAK_CHEWS:\n            routesArray = ED_PRODUCT_INTAKE_ROUTES[1].route_array;\n            break;\n        case PRODUCT_HREF.X_CHEWS:\n        case PRODUCT_HREF.X_MELTS:\n            routesArray = ED_X_PRODUCTS_INTAKE_ROUTES[1].route_array;\n            break;\n        case PRODUCT_HREF.RUSH_MELTS:\n            routesArray = RUSH_MELTS_INTAKE_ROUTES[1].route_array;\n            break;\n        case PRODUCT_HREF.SEMAGLUTIDE:\n            const currentVersion =\n                LATEST_INTAKE_VERSIONS.semaglutide.latest_version;\n            routesArray = getRouteArrayForTest(\n                SEMAGLUTIDE_ROUTES[currentVersion],\n                vwo_test_ids\n            );\n            break;\n        case PRODUCT_HREF.TIRZEPATIDE:\n            const current_version =\n                LATEST_INTAKE_VERSIONS.tirzepatide.latest_version;\n\n            routesArray = getRouteArrayForTest(\n                TIRZEPATIDE_ROUTES[current_version],\n                vwo_test_ids\n            );\n            break;\n        case PRODUCT_HREF.WEIGHT_LOSS:\n            const current_version_WL =\n                LATEST_INTAKE_VERSIONS.combined_weight_loss.latest_version;\n\n            routesArray = getRouteArrayForTest(\n                COMBINED_WEIGHT_LOSS_ROUTES[current_version_WL],\n                vwo_test_ids\n            );\n            break;\n        case PRODUCT_HREF.NAD_INJECTION:\n            routesArray = NAD_INTAKE_ROUTES[2].route_array;\n            break;\n        case PRODUCT_HREF.SERMORELIN:\n            routesArray = SERMORELIN_ROUTES[1].route_array;\n            break;\n        default:\n            routesArray = NAD_NASAL_SPRAY_INTAKE_ROUTES[1].route_array;\n            break;\n    }\n\n    if (\n        DO_NOT_SHOW_PROGRESS_BAR_ROUTES.includes(currentRoute as INTAKE_ROUTE)\n    ) {\n        return {\n            progress: -1,\n            currentSection: -1,\n        };\n    }\n\n    let calculated_progress: number = 0;\n    let calculated_section: number = 0;\n\n    const questions_index_number = routesArray.indexOf(\n        product_href === PRODUCT_HREF.WEIGHT_LOSS ||\n            vwo_test_ids.includes(AB_TESTS_IDS.WL_HERS_FUNNEL) ||\n            product_href === PRODUCT_HREF.SEMAGLUTIDE ||\n            product_href === PRODUCT_HREF.TIRZEPATIDE ||\n            product_href === PRODUCT_HREF.B12_INJECTION ||\n            product_href === PRODUCT_HREF.NAD_INJECTION ||\n            product_href === PRODUCT_HREF.SERMORELIN\n            ? INTAKE_ROUTE_V3.QUESTIONS\n            : INTAKE_ROUTE.QUESTIONS\n    );\n\n    let current_index_number = routesArray.indexOf(currentRoute);\n    if (currentPath.includes('ed-ind-quantity-selection')) {\n        current_index_number = 11; //this route is not in the ED_PRODUCT_INTAKE_ROUTES, because it's not always shown\n        //we need to hardcode this value for the intake progress bar to show anything on this screen\n    }\n\n    console.log('CURRENT INDEX', current_index_number);\n    console.log('QUESTION INDEX', questions_index_number);\n\n    if (current_index_number < questions_index_number) {\n        calculated_section = 0;\n        if (currentRoute === INTAKE_ROUTE_V3.PRE_QUESTIONS) {\n            const initialProgress = Math.floor(\n                (100 / questions_index_number) * (current_index_number + 1)\n            );\n            const current_question_id = parseInt(\n                currentPathArray[currentPathArray.length - 1]\n            );\n\n            const current_question_id_index =\n                HERS_PRE_QUESTIONS_ID_LIST.indexOf(current_question_id);\n\n            calculated_progress = Math.floor(\n                (current_question_id_index /\n                    HERS_PRE_QUESTIONS_ID_LIST.length) *\n                    100\n            );\n            const finalProgress = initialProgress + calculated_progress / 11;\n            calculated_progress = finalProgress;\n        } else {\n            calculated_progress = Math.floor(\n                (100 / questions_index_number) * (current_index_number + 1)\n            );\n        }\n    } else if (current_index_number > questions_index_number) {\n        calculated_section = 2;\n        calculated_progress = Math.floor(\n            100 -\n                (100 / (routesArray.length - questions_index_number)) *\n                    (routesArray.length - current_index_number)\n        );\n    } else {\n        calculated_section = 1;\n\n        let question_id_array: number[];\n        switch (product_href) {\n            case PRODUCT_HREF.METFORMIN:\n                question_id_array = METFORMIN_QUESTION_ID_LIST;\n                break;\n            case PRODUCT_HREF.B12_INJECTION:\n                question_id_array = B12_QUESTION_ID_LIST;\n                break;\n            case PRODUCT_HREF.NAD_NASAL_SPRAY:\n                question_id_array = NAD_NASAL_SPRAY_QUESTION_ID_LIST;\n                break;\n            case PRODUCT_HREF.NAD_INJECTION:\n                question_id_array = NAD_INJECTION_QUESTION_ID_LIST;\n                break;\n            case PRODUCT_HREF.ED_GLOBAL:\n                question_id_array = ED_GLOBAL_QUESTION_ID_LIST;\n                break;\n            case PRODUCT_HREF.X_CHEWS:\n            case PRODUCT_HREF.X_MELTS:\n            case PRODUCT_HREF.PEAK_CHEWS:\n            case PRODUCT_HREF.RUSH_MELTS:\n                question_id_array = ED_X_QUESTION_ID_LIST;\n                break;\n            case PRODUCT_HREF.TRETINOIN:\n                question_id_array = SKINCARE_QUESTION_ID_LIST;\n                break;\n            case PRODUCT_HREF.SEMAGLUTIDE:\n            case PRODUCT_HREF.TIRZEPATIDE:\n                if (vwo_test_ids.includes(AB_TESTS_IDS.WL_HERS_FUNNEL)) {\n                    question_id_array = HERS_SEMAGLUTIDE_QUESTION_ID_LIST;\n                } else if (\n                    vwo_test_ids.includes(AB_TESTS_IDS.WL_NEW_SCREEN_TEST)\n                ) {\n                    question_id_array = WL_NEW_SCREENS_QUESTION_ID_LIST;\n                } else if (\n                    vwo_test_ids.includes(AB_TESTS_IDS.COMP_COMPARE)\n                ) {\n                    question_id_array = SEM_COMPETITOR_COMPARISON_QUESTION_ID_LIST;\n                } \n                else {\n                    question_id_array = WL_QUESTION_ID_LIST;\n                }\n                break;\n            case PRODUCT_HREF.WEIGHT_LOSS:\n                if (vwo_test_ids.includes(AB_TESTS_IDS.WL_NEW_SCREEN_TEST)) {\n                    question_id_array =\n                        WEIGHT_LOSS_NEW_SCREENS_QUESTION_ID_LIST;\n                } else {\n                    question_id_array = WEIGHT_LOSS_QUESTION_ID_LIST;\n                }\n                break;\n            case PRODUCT_HREF.SERMORELIN:\n                question_id_array = SERMORELIN_QUESTION_ID_LIST;\n                break;\n            default:\n                question_id_array = SKINCARE_QUESTION_ID_LIST;\n                break;\n        }\n\n        const current_question_id = parseInt(\n            currentPathArray[currentPathArray.length - 1]\n        );\n\n        const current_question_id_index =\n            question_id_array.indexOf(current_question_id);\n\n        calculated_progress = Math.floor(\n            (current_question_id_index / question_id_array.length) * 100\n        );\n    }\n\n    /**\n     * For calculated section the options are 0, 1, and 2.\n     * 0 represents section prior to questions\n     * 1 represents during the quesitons\n     * 2 represents section after questions.\n     */\n    return {\n        progress: calculated_progress,\n        currentSection: calculated_section,\n    };\n}"
      },
      {
        "name": "getRouteArrayForTest",
        "kind": "function",
        "signature": "export function getRouteArrayForTest(\n    routeObject: RouteObject,\n    test_ids: string[]\n): string[] {\n    // If `test_ids` is not provided or empty, return the default route_array\n    if (!test_ids || test_ids.length === 0) {\n        return routeObject.route_array;\n    }\n\n    // Find all ab_tests that match any of the test_ids\n    const matchingTests = routeObject.ab_tests.filter((abTest) =>\n        test_ids.includes(abTest.id)\n    );\n\n    if (matchingTests.length > 1) {\n        // More than one matching test → throw an error or handle as needed\n        // If we're dealing with this case, priority code needs to be added here\n\n        return routeObject.route_array;\n    }\n\n    // If exactly one match, return its route_array\n    if (matchingTests.length === 1) {\n        return matchingTests[0].route_array;\n    }\n\n    // If no matches, return the default route_array\n    return routeObject.route_array;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/intake-route-controller.ts",
      "bioverse-client/app/components/intake-v3/checkout/order-summary-v3/order-summary-v3-ap.tsx",
      "bioverse-client/app/components/intake-v3/checkout/order-summary-v3/order-summary-v3.tsx",
      "bioverse-client/app/components/intake-v3/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component-ab.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-intro-graph-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-intro-question-4-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/question-id-pre-signup.tsx",
      "bioverse-client/app/components/intake-v3/pages/registration-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/order-summary-v4/MetforminOrderSummary.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-goal-hers-transition-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/select-supply-ap.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-intro-specialists-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-supply-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/pre-id-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-female-safety.tsx",
      "bioverse-client/app/components/intake-v3/pages/good-news-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-graph-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/up-next-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/treatment-evolve.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-supply-v3-no-6.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-inform-2-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/shipping-information-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/patient-match-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/start-wl-journey-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/greeting-v3-ap.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-goal-hers-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-intro-1.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-reviews-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-intro-3.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-stat-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-intro-2.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-intro-question-2-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/fatigue-stat-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-whats-next.tsx",
      "bioverse-client/app/components/intake-v3/pages/b12-reviews.tsx",
      "bioverse-client/app/components/intake-v3/pages/date-of-birth-pre-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/general-order-summary.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-calulating-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/pre-id-v3-ap.tsx",
      "bioverse-client/app/components/intake-v3/pages/b12-advantages.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-infographic-hers-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/up-next-v3-ap.tsx",
      "bioverse-client/app/components/intake-v3/pages/up-next-id-v3-ap.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-intro-options-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/login-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/up-next-health-v3-ap.tsx",
      "bioverse-client/app/components/intake-v3/pages/one-moment.tsx",
      "bioverse-client/app/components/intake-v3/pages/improve-function.tsx",
      "bioverse-client/app/components/intake-v3/pages/treatment-support.tsx",
      "bioverse-client/app/components/intake-v3/pages/up-next-v3-wl.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-good-hands-review.tsx",
      "bioverse-client/app/components/intake-v3/pages/question-id-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/greeting-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/improve-health-ap.tsx",
      "bioverse-client/app/components/intake-v3/pages/treatment-safety.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-data-processing-no-calc.tsx",
      "bioverse-client/app/components/intake-v3/pages/nad-benefits-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/demographic-collection.tsx",
      "bioverse-client/app/components/intake-v3/pages/rtb-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-intro-question-3-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/select-supply-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/up-next-preview-v3-ap.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-inform-3-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-data-processing.tsx",
      "bioverse-client/app/components/intake-v3/pages/on-your-way.tsx",
      "bioverse-client/app/components/intake-v3/pages/demographic-wl-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/id-verification-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/pre-question-id-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/id-verification-noskip-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/date-of-birth-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/order-summary-v4.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-graph-presignup.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-inform-1-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-intro-question-1-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/state-selection-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/pre-treatment.tsx",
      "bioverse-client/app/components/intake-v2/ed/ed-match/ed-match.tsx",
      "bioverse-client/app/components/intake-v2/ed/ed-pre-id/ed-pre-id.tsx",
      "bioverse-client/app/components/intake-v2/checkout/order-summary-v2/order-summary.tsx",
      "bioverse-client/app/components/intake-v2/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/components/wl-checkout-component-fulltest.tsx",
      "bioverse-client/app/components/intake-v2/checkout/checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-pre-demographic.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-intro-specialists.tsx",
      "bioverse-client/app/components/intake-v2/pages/fatigue-stat.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-client-template.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-intro-question-4.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-intro-options.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-intro-question-1.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-statement.tsx",
      "bioverse-client/app/components/intake-v2/pages/question-id.tsx",
      "bioverse-client/app/components/intake-v2/pages/skincare-frequency.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-security-disclaimer.tsx",
      "bioverse-client/app/components/intake-v2/pages/date-of-birth.tsx",
      "bioverse-client/app/components/intake-v2/pages/demographic-information.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-intro-question-2.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-intro-question-3.tsx",
      "bioverse-client/app/components/intake-v2/pages/state-selection-hers.tsx",
      "bioverse-client/app/components/intake-v2/pages/up-next-preview.tsx",
      "bioverse-client/app/components/intake-v2/pages/bmi-summary.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-in-good-hands.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-inform-2.tsx",
      "bioverse-client/app/components/intake-v2/pages/skincare-up-next-upload.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-calulating.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-intro-1.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-inform-3.tsx",
      "bioverse-client/app/components/intake-v2/pages/id-verification.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-inform-1.tsx",
      "bioverse-client/app/components/intake-v2/pages/skincare-up-next-preview.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-intro-3.tsx",
      "bioverse-client/app/components/intake-v2/pages/product-overview.tsx",
      "bioverse-client/app/components/intake-v2/pages/pre-id.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-intro-2.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-animated-intro.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-checklist.tsx",
      "bioverse-client/app/components/intake-v2/pages/rtb.tsx",
      "bioverse-client/app/components/intake-v2/pages/nad-benefits.tsx",
      "bioverse-client/app/components/intake-v2/pages/pre-screen.tsx",
      "bioverse-client/app/components/intake-v2/pages/up-next-id.tsx",
      "bioverse-client/app/components/intake-v2/pages/combined-wl-demographic.tsx",
      "bioverse-client/app/components/intake-v2/pages/b12-reviews.tsx",
      "bioverse-client/app/components/intake-v2/pages/skin-care-see-others.tsx",
      "bioverse-client/app/components/intake-v2/pages/state-selection.tsx",
      "bioverse-client/app/components/intake-v2/pages/general-order-summary.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-intro-graph.tsx",
      "bioverse-client/app/components/intake-v2/pages/b12-advantages.tsx",
      "bioverse-client/app/components/intake-v2/pages/demographic-wl.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-up-next-preview.tsx",
      "bioverse-client/app/components/intake-v2/pages/glutathione-advantages.tsx",
      "bioverse-client/app/components/intake-v2/pages/skincare-intro.tsx",
      "bioverse-client/app/components/intake-v2/pages/improve-function.tsx",
      "bioverse-client/app/components/intake-v2/pages/shipping-information.tsx",
      "bioverse-client/app/components/intake-v2/pages/patient-match.tsx",
      "bioverse-client/app/components/intake-v2/pages/select-supply.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-supply.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-reviews.tsx",
      "bioverse-client/app/components/intake-v2/pages/pre-demographic.tsx",
      "bioverse-client/app/components/intake-v2/pages/glutathione-process.tsx",
      "bioverse-client/app/components/intake-v2/pages/demographic-collection.tsx",
      "bioverse-client/app/components/intake-v2/pages/registration.tsx",
      "bioverse-client/app/components/intake-v2/pages/skincare-up-next-id.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-graph.tsx",
      "bioverse-client/app/components/intake-v2/pages/improve-health.tsx",
      "bioverse-client/app/components/intake-v2/pages/skincare-pre-demographic.tsx",
      "bioverse-client/app/components/intake-v2/pages/up-next.tsx",
      "bioverse-client/app/components/intake-v2/pages/skincare-upload.tsx",
      "bioverse-client/app/components/intake-v2/pages/enhance-energy.tsx",
      "bioverse-client/app/components/intake-v2/pages/start-wl-journey.tsx",
      "bioverse-client/app/components/intake-v2/pages/pre-id-b.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-preview-treatment.tsx",
      "bioverse-client/app/components/intake-v2/pages/on-your-way.tsx",
      "bioverse-client/app/components/intake-v2/pages/skincare-results.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-stat.tsx",
      "bioverse-client/app/components/intake-v2/pages/semaglutide-dosage.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-profile-start-v3.tsx",
      "bioverse-client/app/components/intake-v2/pages/good-to-go.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-intro-screen.tsx",
      "bioverse-client/app/components/intake-v2/pages/patient-match-one-moment.tsx",
      "bioverse-client/app/components/intake-v2/pages/greeting.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/registration/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/ed-intro/page.tsx",
      "bioverse-client/app/(intake)/intake/prescriptions/[product]/registration-v3/page.tsx",
      "bioverse-client/app/components/intake-v2/topnav/topnav-v2.tsx",
      "bioverse-client/app/components/intake-v2/topnav/topnav.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/isTransitionScreen.ts",
    "exports": [
      {
        "name": "isTransitionScreen",
        "kind": "variable",
        "signature": "isTransitionScreen = (question: any) => {\n    if (question && question.custom_name) {\n        return TRANSITION_SCREEN_NAMES.includes(question.custom_name);\n    }\n    return false;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/isTransitionScreen.ts",
      "bioverse-client/app/components/patient-portal/subscriptions/components/ChangeRefillDate/feedback/RefillFeedback.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/CancelSubscription/feedback/CancelFeedbackQuestion.tsx",
      "bioverse-client/app/components/patient-portal/check-up/question/CheckupQuestion.tsx",
      "bioverse-client/app/components/intake-v3/pages/question-id-pre-signup.tsx",
      "bioverse-client/app/components/intake-v3/pages/question-id-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/pre-question-id-v3.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/logic-v3.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/glp-1-before.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/what-is-your-sex-v3.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/wl-checkin-anything-else.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/glp-1-side-effects.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/identify-sex-v3.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/glp-how-long.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/checkup-v2-side-effect-question.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/wl-list-medicines.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/glp-1-dosage-request.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/glp-weekly-dose.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/final-review.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/nad-anything-else.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-v3.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/multiple-choice-v3.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-render/question-rendering-v3.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-render/pre-question-rendering-v3.tsx",
      "bioverse-client/app/components/intake-v2/pages/question-id.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/glp-1-before.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/wl-checkin-anything-else.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/glp-1-side-effects.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/glp-how-long.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/wl-list-medicines.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/glp-1-dosage-request.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/what-is-your-sex.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/glp-weekly-dose.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/identify-sex.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/final-review.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/logic.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/multiple-choice.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-render/question-rendering.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/job-scheduler/BaseJobSchedulerHandler.ts",
    "exports": [
      {
        "name": "DONT_RETRY_ERROR_MESSAGE",
        "kind": "variable",
        "signature": "DONT_RETRY_ERROR_MESSAGE = 'dont_process'"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/job-scheduler/BaseJobSchedulerHandler.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/StripeInvoicePaidJobHandler.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/job-scheduler/JobSchedulerFactory.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/functions/job-scheduler/jobs/BaseCommJobHandler.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/functions/job-scheduler/jobs/IDAndSelfieCheckJobHandler.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/functions/job-scheduler/jobs/RenewalAutoshipJobHandler.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/functions/job-scheduler/jobs/RenewalValidationJobHandler.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/functions/job-scheduler/jobs/SendPrescriptionJobHandler.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/functions/job-scheduler/jobs/StripeInvoicePaidJobHandler.ts",
    "exports": [
      {
        "name": "usedAllRefills",
        "kind": "function",
        "signature": "export function usedAllRefills(subscription: PrescriptionSubscription) {\n    const href = subscription.product_href as PRODUCT_HREF;\n    const type = subscription.subscription_type as SubscriptionCadency;\n    const mapping = MAX_REFILLS_MAPPING[href];\n    const maxRefills = mapping ? mapping[type] : null;\n\n    // If the lookup fails throw an error\n    if (!maxRefills) {\n        const msg = `Max refills lookup failed for ${subscription.product_href} -> ${subscription.subscription_type}`;\n        console.error(msg);\n        throw Error(msg);\n    }\n\n    return subscription.since_last_checkup >= maxRefills.max_refills;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/job-scheduler/jobs/StripeInvoicePaidJobHandler.ts",
      "bioverse-client/app/api/stripe/webhook/invoice-paid/route.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/jobs/JobsFactory.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/functions/jobs/jobs.ts",
    "exports": [
      {
        "name": "getReviewStatusTagForRenewalOrder",
        "kind": "function",
        "signature": "export async function getReviewStatusTagForRenewalOrder(\n    renewal_order_id: string,\n): Promise<StatusTag> {\n    const months = await getMonthsIntoRenewalOrderSubscription(\n        renewal_order_id,\n    );\n\n    if (!months) {\n        return StatusTag.Review;\n    } else if (months === 1 || months === 2) {\n        return StatusTag.ReviewNoPrescribe;\n    } else if (months >= 3) {\n        return StatusTag.FinalReview;\n    }\n    return StatusTag.Review;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/jobs/jobs.ts",
      "bioverse-client/app/utils/functions/jobs/JobsFactory.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/meta-events.ts",
    "exports": [
      {
        "name": "sendConvertEvent",
        "kind": "variable",
        "signature": "sendConvertEvent = async (\n    event_type: string,\n    event_id: string,\n    payload: any,\n    values: any = {},\n    conversionPayload: any,\n) => {\n    const customData = {\n        value: payload.value,\n        currency: payload.currency,\n    };\n\n    try {\n        const response = await axios.post(\n            `https://graph.facebook.com/v19.0/${process.env.NEXT_PUBLIC_PIXEL_ID}/events?access_token=${process.env.FBACCESSKEY}`,\n            {\n                data: [\n                    {\n                        ...conversionPayload,\n                        ...(event_type === 'Purchase' && {\n                            custom_data: customData,\n                        }),\n                    },\n                ],\n                ...(process.env.NEXT_PUBLIC_ENVIRONMENT === 'dev' && {\n                    test_event_code: process.env.NEXT_PUBLIC_CONVERSION_TEST_ID,\n                }),\n            },\n        );\n    } catch (error: any) {\n        console.log('Error firing meta pixel convert event');\n        console.log(conversionPayload);\n        if (error.response) {\n            // The request was made and the server responded with a status code\n            // that falls out of the range of  2xx\n            console.log(error.response.data);\n            console.log(error.response.status);\n            console.log(error.response.headers);\n        } else if (error.request) {\n            // The request was made but no response was received\n            console.log(error.request);\n        } else {\n            // Something happened in setting up the request that triggered an Error\n            console.log('Error', error.message);\n        }\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/meta-events.ts",
      "bioverse-client/app/services/tracking/meta.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/patient-portal/patient-portal-utils.ts",
    "exports": [
      {
        "name": "categorizeSubscriptions",
        "kind": "function",
        "signature": "export function categorizeSubscriptions(\n    subscriptions: SubscriptionListItem[],\n): SubscriptionStatusCategories {\n    return subscriptions.reduce(\n        (acc: SubscriptionStatusCategories, subscription) => {\n            if (subscription.status === 'active') {\n                acc['active'] = acc['active'] || [];\n                acc['active'].push(subscription);\n            } else if (subscription.status === 'paused') {\n                acc['paused'] = acc['paused'] || [];\n                acc['paused'].push(subscription);\n            } else if (subscription.status === 'canceled') {\n                acc['canceled'] = acc['canceled'] || [];\n                acc['canceled'].push(subscription);\n            } else if (subscription.status === 'scheduled-cancel') {\n                acc['scheduled-cancel'] = acc['scheduled-cancel'] || [];\n                acc['scheduled-cancel'].push(subscription);\n            } else {\n                acc['unknown'] = acc['unknown'] || [];\n                acc['unknown'].push(subscription);\n            }\n            return acc;\n        },\n        {\n            active: [],\n            paused: [],\n            canceled: [],\n            unknown: [],\n            'scheduled-cancel': [],\n        },\n    );\n}"
      },
      {
        "name": "getAllProductHrefs",
        "kind": "function",
        "signature": "export function getAllProductHrefs(\n    categories: SubscriptionStatusCategories,\n): string[] {\n    const allHrefs: string[] = [];\n\n    // Iterate over each category (active, paused, canceled)\n    Object.values(categories).forEach((category: SubscriptionListItem[]) => {\n        // Iterate over each item in the category\n        category.forEach((item: SubscriptionListItem) => {\n            // Push the product_href to the allHrefs array\n            allHrefs.push(item.product_href);\n        });\n    });\n\n    // Use Set to keep only unique hrefs and convert it back to an array\n    const uniqueHrefs: string[] = Array.from(new Set(allHrefs));\n\n    return uniqueHrefs;\n}"
      },
      {
        "name": "categorizeOrders",
        "kind": "function",
        "signature": "export function categorizeOrders(orders: OrderItem[]): OrderStatusCategories {\n    return orders.reduce(\n        (acc: OrderStatusCategories, order) => {\n            if (order.shipping_status === ShippingStatus.Delivered) {\n                acc['delivered'] = acc['delivered'] || [];\n                acc['delivered'].push(order);\n            } else if (order.shipping_status === ShippingStatus.Shipped) {\n                acc['shipped'] = acc['shipped'] || [];\n                acc['shipped'].push(order);\n            } else if (\n                order.order_status !== RenewalOrderStatus.PharmacyProcessing &&\n                order.dosage_selection_completed\n            ) {\n                acc['processing'] = acc['processing'] || [];\n                acc['processing'].push(order);\n            } else if (\n                order.order_status === OrderStatus.UnapprovedCardDown ||\n                order.order_status ===\n                    RenewalOrderStatus.CheckupComplete_Unprescribed_Paid ||\n                // order.order_status ===\n                //     RenewalOrderStatus.CheckupComplete_Unprescribed_Unpaid ||\n                order.order_status ===\n                    RenewalOrderStatus.CheckupIncomplete_Unprescribed_Paid ||\n                order.order_status ===\n                    RenewalOrderStatus.CheckupIncomplete_Unprescribed_Paid_1 ||\n                order.order_status ===\n                    RenewalOrderStatus.CheckupIncomplete_Unprescribed_Paid_2 ||\n                order.order_status ===\n                    RenewalOrderStatus.CheckupWaived_Unprescribed_Paid\n            ) {\n                acc['review'] = acc['review'] || [];\n                acc['review'].push(order);\n            } else if (\n                order.order_status === OrderStatus.Canceled ||\n                order.order_status === OrderStatus.AdministrativeCancel ||\n                order.order_status === OrderStatus.DeniedCardDown ||\n                order.order_status === RenewalOrderStatus.Denied_Paid ||\n                order.order_status === RenewalOrderStatus.Denied_Unpaid\n            ) {\n                acc['canceled'] = acc['canceled'] || [];\n                acc['canceled'].push(order);\n            } else if (\n                order.order_status === OrderStatus.ApprovedCardDown ||\n                order.order_status === OrderStatus.PaymentCompleted ||\n                order.order_status === OrderStatus.ApprovedCardDownFinalized ||\n                order.order_status === RenewalOrderStatus.PharmacyProcessing ||\n                order.order_status ===\n                    RenewalOrderStatus.CheckupComplete_Prescribed_Paid\n            ) {\n                acc['pharmacy-processing'] = acc['pharmacy-processing'] || [];\n                acc['pharmacy-processing'].push(order);\n            } else if (order.order_status === OrderStatus.PaymentDeclined) {\n                acc['payment-failed'] = acc['payment-failed'] || [];\n                acc['payment-failed'].push(order);\n            } else if (\n                order.order_status === RenewalOrderStatus.Unknown ||\n                order.order_status ===\n                    RenewalOrderStatus.Scheduled_Admin_Cancel ||\n                order.order_status === RenewalOrderStatus.Scheduled_Cancel ||\n                order.order_status === RenewalOrderStatus.Incomplete\n            ) {\n                // do nothing\n            } else {\n                // acc['review'] = acc['review'] || [];\n                // acc['review'].push(order);\n            }\n            return acc;\n        },\n        {\n            delivered: [],\n            'pharmacy-processing': [],\n            review: [],\n            shipped: [],\n            canceled: [],\n            'payment-failed': [],\n            processing: [],\n        },\n    );\n}"
      },
      {
        "name": "mergeOrders",
        "kind": "function",
        "signature": "export async function mergeOrders(\n    orders: OrderItem[],\n    renewalOrders: OrderItem[],\n): Promise<OrderItem[]> {\n    // Step 1: Concatenate the arrays\n    const combinedOrders: OrderItem[] = [...orders, ...renewalOrders];\n\n    // Step 2: Add the order_type field to each item\n    await Promise.all(\n        combinedOrders.map(async (order) => {\n            if (orders.includes(order)) {\n                order.order_type = OrderType.Order;\n            } else if (renewalOrders.includes(order)) {\n                order.order_type = OrderType.RenewalOrder;\n            }\n            var price;\n            if (order.order_type === OrderType.RenewalOrder) {\n                price = await getPriceForRenewalOrder(order.renewal_order_id!);\n            } else {\n                price = (await getPriceForProduct(order.id)) || 0;\n            }\n\n            order.price = price;\n        }),\n    );\n\n    // Step 3: Sort the combined array by the created_at field\n    combinedOrders.sort(\n        (a, b) =>\n            new Date(b.created_at).getTime() - new Date(a.created_at).getTime(),\n    );\n\n    return combinedOrders;\n}"
      },
      {
        "name": "formatSubscriptionType",
        "kind": "function",
        "signature": "export function formatSubscriptionType(subscriptionType: string) {\n    switch (subscriptionType) {\n        case 'monthly':\n            return 'Monthly';\n        case 'quarterly':\n            return 'Quarterly';\n        case 'one_time':\n            return 'One-Time';\n        default:\n            return 'N/A';\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(testing_and_development)/dev/mock/subscriptions/[user_id]/page.tsx",
      "bioverse-client/app/utils/functions/patient-portal/patient-portal-utils.ts",
      "bioverse-client/app/(patient-portal)/portal/account-information/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/page.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/SubscriptionsList.tsx",
      "bioverse-client/app/(testing_and_development)/dev/mock/order-history/[user_id]/page.tsx",
      "bioverse-client/app/(patient-portal)/portal/order-history/page.tsx",
      "bioverse-client/app/components/patient-portal/account-information/personal-information/components/PrescriptionsList.tsx",
      "bioverse-client/app/components/patient-portal/subscriptions/components/SubscriptionList/SubscriptionItem.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/pharmacy-helpers/bundle-to-single-vial-converter.ts",
    "exports": [
      {
        "name": "convertBundleVariantToSingleVialScript",
        "kind": "function",
        "signature": "export async function convertBundleVariantToSingleVialScript(\n    order_data: DBOrderData,\n    patient_data: DBPatientData,\n    order_type: OrderType,\n    variant_index: number\n) {\n    const new_variant_index = convertBundleVariantToSingleVariant(\n        order_data.product_href,\n        variant_index\n    );\n\n    const pharmacy = getEligiblePharmacy(\n        order_data.product_href,\n        new_variant_index\n    );\n\n    if (pharmacy === PHARMACY.EMPOWER) {\n        const bmi_answers = await getQuestionAnswersForBMI(patient_data.id);\n\n        const result = generateEmpowerScript(\n            patient_data,\n            order_data,\n            order_type,\n            bmi_answers,\n            new_variant_index\n        );\n        if (result) {\n            const { script, sigs, displayName } = result;\n\n            return script;\n        }\n    }\n\n    if (pharmacy === PHARMACY.HALLANDALE) {\n        const addressData: AddressInterface = {\n            address_line1:\n                order_type === OrderType.Order\n                    ? order_data.address_line1\n                    : order_data.order.address_line1,\n            address_line2:\n                order_type === OrderType.Order\n                    ? order_data.address_line2\n                    : order_data.order.address_line2,\n            city:\n                order_type === OrderType.Order\n                    ? order_data.city\n                    : order_data.order.city,\n            state:\n                order_type === OrderType.Order\n                    ? order_data.state\n                    : order_data.order.state,\n            zip:\n                order_type === OrderType.Order\n                    ? order_data.zip\n                    : order_data.order.zip,\n        };\n\n        const result = generateHallandaleScript(\n            patient_data,\n            order_data,\n            addressData,\n            order_type,\n            new_variant_index\n        );\n        if (result) {\n            const { script, sigs, displayName } = result;\n\n            return script;\n        }\n    }\n}"
      },
      {
        "name": "getScriptForVariantIndex",
        "kind": "function",
        "signature": "export async function getScriptForVariantIndex(\n    order_data: DBOrderData,\n    patient_data: DBPatientData,\n    orderType: OrderType,\n    incoming_variant_index: number\n) {\n    let pharmacy = getEligiblePharmacy(\n        order_data.product_href,\n        incoming_variant_index\n    );\n    let variant_index = incoming_variant_index;\n\n    if (order_data.product_href === PRODUCT_HREF.TIRZEPATIDE) {\n        const mappedIndex =\n            HALLANDALE_EMPOWER_CONVERSION_MAP['tirzepatide'][\n                incoming_variant_index as keyof (typeof HALLANDALE_EMPOWER_CONVERSION_MAP)['tirzepatide']\n            ];\n        if (mappedIndex !== variant_index) {\n            variant_index = mappedIndex;\n            order_data.assigned_pharmacy = 'empower';\n            pharmacy = 'empower';\n            order_data.variant_index = mappedIndex;\n        }\n    }\n\n    if (pharmacy === PHARMACY.EMPOWER) {\n        const bmi_answers = await getQuestionAnswersForBMI(patient_data.id);\n\n        const result = generateEmpowerScript(\n            patient_data,\n            order_data,\n            orderType,\n            bmi_answers,\n            variant_index\n        );\n        if (result) {\n            const { script, sigs, displayName } = result;\n\n            return { script, pharmacy };\n        }\n    } else if (pharmacy === PHARMACY.HALLANDALE) {\n        const result = await generateHallandaleScriptWithPDF(\n            patient_data.id,\n            orderType === OrderType.Order\n                ? order_data.id\n                : order_data.renewal_order_id,\n            variant_index,\n            patient_data\n        );\n        return { script: result, pharmacy };\n    }\n    return { script: null, pharmacy: null };\n}"
      },
      {
        "name": "generateHallandaleScriptWithPDF",
        "kind": "function",
        "signature": "export async function generateHallandaleScriptWithPDF(\n    user_id: string,\n    renewal_order_id: string,\n    variant_index: number,\n    patientData: DBPatientData\n) {\n    const { data: allergyData, error: allergyError } =\n        await getPatientAllergyData(user_id, 'deprecated');\n\n    const { data: renewalOrder, type: orderType } = await fetchOrderData(\n        renewal_order_id\n    );\n\n    if (patientData && renewalOrder && allergyData) {\n        const addressData: AddressInterface = {\n            address_line1: renewalOrder.address_line1,\n            address_line2: renewalOrder.address_line2,\n            city: renewalOrder.city,\n            state: renewalOrder.state,\n            zip: renewalOrder.zip,\n        };\n        const scriptMetadata = generateHallandaleScript(\n            patientData,\n            renewalOrder,\n            addressData,\n            OrderType.RenewalOrder,\n            variant_index\n        );\n\n        if (scriptMetadata) {\n            const base64pdf = convertHallandaleOrderToBase64(\n                scriptMetadata.script,\n                allergyData && allergyData.length > 0\n                    ? allergyData[0].allergies\n                    : 'nkda'\n            );\n\n            const orderWithPdf: HallandaleOrderObject = {\n                ...scriptMetadata.script,\n                document: { pdfBase64: base64pdf },\n            };\n\n            const body_json: HallandaleScriptJSON = {\n                message: {\n                    id: renewalOrder.id,\n                    sentTime: new Date().toISOString(),\n                },\n                order: orderWithPdf,\n            };\n            return body_json;\n        }\n    }\n    return null;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/pharmacy-helpers/bundle-to-single-vial-converter.ts",
      "bioverse-client/app/utils/classes/Pharmacy.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/pharmacy-helpers/bundle-variant-index-mapping.ts",
    "exports": [
      {
        "name": "convertBundleVariantToSingleVariant",
        "kind": "function",
        "signature": "export function convertBundleVariantToSingleVariant(\n    product: string,\n    bundle_variant_index: number\n): number {\n    if (\n        !shouldConvertBundleSubscriptionToMonthly(\n            product as PRODUCT_HREF,\n            bundle_variant_index\n        )\n    ) {\n        return bundle_variant_index;\n    }\n    switch (product) {\n        case 'semaglutide':\n            return SEMAGLUTIDE_BUNDLE_MONTHLY_MAPPING[bundle_variant_index];\n        case 'tirzepatide':\n            return TIRZEPATIDE_BUNDLE_MONTHLY_MAPPING[bundle_variant_index];\n    }\n\n    return -1;\n}"
      },
      {
        "name": "shouldConvertBundleSubscriptionToMonthly",
        "kind": "function",
        "signature": "export function shouldConvertBundleSubscriptionToMonthly(\n    product_href: PRODUCT_HREF,\n    variant_index: number\n) {\n    if (product_href === PRODUCT_HREF.SEMAGLUTIDE) {\n        if (SEMAGLUTIDE_NO_CONVERT_VARIANTS.includes(variant_index)) {\n            return false;\n        }\n        return true;\n    }\n\n    if (product_href === PRODUCT_HREF.TIRZEPATIDE) {\n        if (TIRZEPATIDE_NO_CONVERT_VARIANTS.includes(variant_index)) {\n            return false;\n        }\n\n        return true;\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(testing_and_development)/olivier-dev/utils.ts",
      "bioverse-client/app/(testing_and_development)/dev/send-script/components/ConvertBundleToMonthly.tsx",
      "bioverse-client/app/(administration)/admin/stripe-api/stripe-api-actions.ts",
      "bioverse-client/app/utils/functions/pharmacy-helpers/bundle-variant-index-mapping.ts",
      "bioverse-client/app/utils/functions/pharmacy-helpers/bundle-to-single-vial-converter.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/RenewalValidationJobHandler.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/StripeInvoicePaidJobHandler.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/RenewalOrderTabRow.tsx",
      "bioverse-client/app/api/stripe/webhook/invoice-paid/route.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/prescription-scripts/boothwyn-script-generator.ts",
    "exports": [
      {
        "name": "generateBoothwynScriptAsync",
        "kind": "function",
        "signature": "export async function generateBoothwynScriptAsync(\n    patient_id: string,\n    order_id: string,\n    override?: ScriptOverrideObject,\n    resend?: boolean\n): Promise<BoothwynScriptPayload> {\n    const { data: patient_data_any, error } = await getPatientInformationById(\n        patient_id\n    );\n\n    const { type: order_type, data: order_data_any } = await fetchOrderData(\n        order_id\n    );\n\n    if (!patient_data_any) {\n        return {\n            script_json: null,\n            error: 'No patient was found with provided Patient ID',\n        };\n    }\n\n    const resendCount = await getResendCount(\n        parseInt(order_id),\n        order_type === OrderType.Order\n            ? undefined\n            : order_data_any.renewal_order_id\n    );\n\n    const patient_data: DBPatientData = patient_data_any;\n    const order_data: DBOrderData = order_data_any;\n    const product_href: string = override\n        ? override.product_href\n        : order_data.product_href;\n    const variant_index = override\n        ? override.variant_index\n        : order_data.variant_index;\n\n    if (!BOOTHWYN_ALLOWED_PRODUCT_MAP[product_href].includes(variant_index)) {\n        return {\n            script_json: null,\n            error: `Product - Variant Mapping is not for Boothwyn: ${variant_index} : ${product_href}`,\n        };\n    }\n\n    const prescription_object =\n        BOOTHWYN_VARIANT_MAP[product_href][variant_index];\n\n    const isBoothwynQuarterly =\n        BOOTHWYN_QUARTERLY_PROGRAM_VARIANTS[product_href].includes(\n            variant_index\n        );\n\n    const script: BoothwynScriptJSON = {\n        caseId: `BIOVERSE-${\n            order_type === OrderType.RenewalOrder\n                ? order_data.renewal_order_id\n                : order_data.id\n        }${resend ? 'R'.repeat(resendCount + 1) : ''}`,\n        orderType: 2,\n        shippingMethod: 26,\n        ...(isBoothwynQuarterly ? { program: 'Quarterly Bulk' } : {}),\n        patient: {\n            firstName: patient_data.first_name,\n            lastName: patient_data.last_name,\n            email: patient_data.email,\n            phoneNumber: patient_data.phone_number,\n            dateOfBirth: patient_data.date_of_birth,\n            gender: patient_data.sex_at_birth?.charAt(0) || 'U',\n            address: {\n                address1:\n                    order_data.address_line1 ?? patient_data.address_line1,\n                ...(order_data.address_line2 || patient_data.address_line2\n                    ? {\n                          address2:\n                              order_data.address_line2 ??\n                              patient_data.address_line2,\n                      }\n                    : {}),\n                city: order_data.city ?? patient_data.city,\n                state: order_data.state ?? patient_data.state,\n                zipCode: order_data.zip ?? patient_data.zip,\n            },\n        },\n\n        clinician: boothwynProviderObject,\n        prescriptions: prescription_object,\n    };\n\n    return {\n        script_json: script,\n        error: null,\n    };\n}"
      },
      {
        "name": "generateBoothwynScriptWithData",
        "kind": "function",
        "signature": "export function generateBoothwynScriptWithData(\n    patient_data: DBPatientData,\n    order_data: DBOrderData,\n    override?: ScriptOverrideObject\n): BoothwynScriptPayload {\n    const product_href: string = override\n        ? override.product_href\n        : order_data.product_href;\n    const variant_index = override\n        ? override.variant_index\n        : order_data.variant_index;\n\n    if (!BOOTHWYN_ALLOWED_PRODUCT_MAP[product_href].includes(variant_index)) {\n        return {\n            script_json: null,\n            error: `Product - Variant Mapping is not for Boothwyn: ${variant_index} : ${product_href}`,\n        };\n    }\n\n    const prescription_object =\n        BOOTHWYN_VARIANT_MAP[product_href][variant_index];\n\n    const isBoothwynQuarterly =\n        BOOTHWYN_QUARTERLY_PROGRAM_VARIANTS[product_href].includes(\n            variant_index\n        );\n\n    const order_type = order_data.renewal_order_id\n        ? OrderType.RenewalOrder\n        : OrderType.Order;\n\n    const script: BoothwynScriptJSON = {\n        caseId: `BIOVERSE-${\n            order_type === OrderType.RenewalOrder\n                ? order_data.renewal_order_id\n                : order_data.id\n        }`,\n        orderType: 1,\n        shippingMethod: 26,\n        ...(isBoothwynQuarterly ? { program: 'Quarterly Bulk' } : {}),\n        patient: {\n            firstName: patient_data.first_name,\n            lastName: patient_data.last_name,\n            email: patient_data.email,\n            phoneNumber: patient_data.phone_number,\n            dateOfBirth: patient_data.date_of_birth,\n            gender: patient_data.sex_at_birth?.charAt(0) || 'U',\n            address: {\n                address1:\n                    order_data.address_line1 ?? patient_data.address_line1,\n                ...(order_data.address_line2 || patient_data.address_line2\n                    ? {\n                          address2:\n                              order_data.address_line2 ??\n                              patient_data.address_line2,\n                      }\n                    : {}),\n                city: order_data.city ?? patient_data.city,\n                state: order_data.state ?? patient_data.state,\n                zipCode: order_data.zip ?? patient_data.zip,\n            },\n        },\n\n        clinician: boothwynProviderObject,\n        prescriptions: prescription_object,\n    };\n\n    return {\n        script_json: script,\n        error: null,\n    };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(testing_and_development)/ben-dev/page.tsx",
      "bioverse-client/app/utils/classes/Scripts/BoothwynScriptHandler.ts",
      "bioverse-client/app/utils/functions/prescription-scripts/boothwyn-script-generator.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/resend-script-confirmation.tsx",
      "bioverse-client/app/utils/actions/intake/order-util.ts",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/confirm-prescription-dialog.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approve-script-dialog.tsx",
      "bioverse-client/app/services/pharmacy-integration/util/utils.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/prescription-scripts/empower-approval-script-generator.ts",
    "exports": [
      {
        "name": "generateEmpowerScript",
        "kind": "function",
        "signature": "export function generateEmpowerScript(\n    patientData: DBPatientData,\n    orderData: DBOrderData,\n    orderType: OrderType,\n    bmi_data?: {\n        height_feet: number;\n        height_inches: number;\n        weight_lbs: number;\n        bmi: number;\n    },\n    variant_index_data: number = orderData.variant_index,\n    custom_order_id?: string\n) {\n    custom_order_id =\n        custom_order_id ??\n        (orderType === OrderType.Order\n            ? orderData.id\n            : orderData.renewal_order_id);\n\n    /**\n     * Scripts have key-values that are not repeated within Rx's - defined here.\n     */\n    const SCRIPT_NON_REPEATED_VARIABLES = {\n        clientOrderId: custom_order_id!,\n        poNumber: custom_order_id!,\n        deliveryService: 'UPS Priority 2-Day',\n        allowOverrideDeliveryService: true,\n        allowOverrideEssentialCopyGuidance: true,\n        lfPracticeId: parseInt(process.env.NEXT_PUBLIC_EPID!),\n        referenceFields: '',\n    };\n\n    /**\n     * Prescriber details have to be loaded continuously per Rx, so defining here.\n     */\n    const PRESCRIBER_OBJECT = {\n        npi: '1013986835',\n        stateLicenseNumber: 'ME80459',\n        lastName: 'Desai',\n        firstName: 'Bobby',\n        address: {\n            city: 'New York',\n            postalCode: '10014',\n            countryCode: 'US',\n            addressLine1: '875 Washington Street',\n            stateProvince: 'NY',\n        },\n        phoneNumber: '7476668167',\n    };\n\n    /**\n     * Parse if address line 2 exists, since it cannot be null.\n     */\n    const addressLineTwo =\n        orderType === OrderType.Order\n            ? orderData.address_line2\n            : orderData.order.address_line2;\n\n    /**\n     * Patient object needs to be loaded in for each Rx item.\n     */\n    const PATIENT_OBJECT: EmpowerPatient = {\n        clientPatientId: patientData.id,\n        lastName: patientData.last_name,\n        firstName: patientData.first_name,\n        gender: patientData.sex_at_birth?.charAt(0) ?? 'U',\n        dateOfBirth: patientData.date_of_birth,\n        address: {\n            addressLine1:\n                orderType === OrderType.Order\n                    ? orderData.address_line1\n                    : orderData.order.address_line1,\n            addressLine2: addressLineTwo === '' ? null : addressLineTwo,\n            city:\n                orderType === OrderType.Order\n                    ? orderData.city\n                    : orderData.order.city,\n            stateProvince:\n                orderType === OrderType.Order\n                    ? orderData.state\n                    : orderData.order.state,\n            postalCode:\n                orderType === OrderType.Order\n                    ? orderData.zip\n                    : orderData.order.zip,\n            countryCode: 'US',\n        },\n        phoneNumber: patientData.phone_number.replace(/\\D/g, ''),\n        email: patientData.email,\n    };\n\n    /**\n     * These details will be consistent throughout all Rx medications added.\n     */\n    const MEDICATION_STATIC_VARIABLES = {\n        refills: '0',\n        writtenDate: new Date().toISOString().split('T')[0],\n        note: 'From Bioverse, Supervising physician: Dr. Bobby Desai, MD',\n    };\n\n    /**\n     * 12/11/24 new method of fetching Empower Catalog Instruction Object.\n     * Fetches an object that interacts with the below code to generate the script.\n     */\n    const variant_index_script_instructions = getEmpowerCatalogObject(\n        orderData.product_href as PRODUCT_HREF,\n        variant_index_data ?? orderData.variant_index\n    );\n\n    const newRxArrayConstructed: EmpowerNewRx[] = [];\n\n    const sigs_list: string[] = [];\n\n    let diagnosis_obtained;\n    diagnosis_obtained = getDiagnosisWithBMIData(bmi_data);\n\n    //construct Diagnosis Object\n    const diagnosis: EmpowerDiagnosis =\n        diagnosis_obtained.code !== ''\n            ? {\n                  clinicalInformationQualifier: 0,\n                  primary: {\n                      code: diagnosis_obtained.code,\n                      qualifier: 0,\n                      description: diagnosis_obtained.description,\n                  },\n              }\n            : {\n                  clinicalInformationQualifier: 0,\n                  primary: {\n                      code: 'E66.9',\n                      qualifier: 0,\n                      description: 'Obesity',\n                  },\n              };\n\n    if (\n        variant_index_script_instructions &&\n        variant_index_script_instructions.array\n    ) {\n        /**\n         * Iterating through the instructions object to create the Rx's array for the script.\n         */\n        variant_index_script_instructions.array.forEach(\n            (rxItemInstruction: ScriptInstruction) => {\n                const catalogItemData = searchEmpowerItemCatalogByCode(\n                    rxItemInstruction.catalogItemCode\n                );\n\n                const newMedicationItem: EmpowerMedication = {\n                    ...MEDICATION_STATIC_VARIABLES,\n                    ...catalogItemData,\n                    quantity: `${rxItemInstruction.quantity}`,\n                    sigText: rxItemInstruction.sigText,\n                    daysSupply: `${rxItemInstruction.daysSupply}`,\n                    diagnosis: diagnosis,\n                };\n\n                const newRxItem: EmpowerNewRx = {\n                    medication: newMedicationItem,\n                    patient: PATIENT_OBJECT,\n                    prescriber: PRESCRIBER_OBJECT,\n                };\n\n                sigs_list.push(rxItemInstruction.internalSigText);\n\n                newRxArrayConstructed.push(newRxItem);\n                return;\n            }\n        );\n    }\n\n    /**\n     * Putting the item together to be returned.\n     */\n    const script_json: EmpowerPrescriptionOrder = {\n        ...SCRIPT_NON_REPEATED_VARIABLES,\n        newRxs: newRxArrayConstructed,\n    };\n\n    //results:\n    //script_json\n    //sigs_list\n\n    return {\n        script: script_json,\n        sigs: sigs_list,\n        displayName:\n            variant_index_script_instructions?.selectDisplayName ??\n            'display name not set',\n    };\n}"
      },
      {
        "name": "generateEmpowerScriptAsync",
        "kind": "function",
        "signature": "export async function generateEmpowerScriptAsync(\n    patientId: string,\n    orderId: string,\n    override?: ScriptOverrideObject,\n    resend?: boolean\n) {\n    const { type: orderType, data: orderData } = await fetchOrderData(orderId);\n    const { data: patientData, error } = await getPatientInformationById(\n        patientId\n    );\n\n    const bmi_data = await getQuestionAnswersForBMI(patientId);\n\n    if (error) {\n        throw new Error(error.message);\n    }\n\n    const resendCount = await getResendCount(\n        parseInt(orderId),\n        orderType === OrderType.Order ? undefined : orderData.renewal_order_id\n    );\n\n    /**\n     * Scripts have key-values that are not repeated within Rx's - defined here.\n     */\n    const SCRIPT_NON_REPEATED_VARIABLES = {\n        clientOrderId: `${\n            orderType === OrderType.Order\n                ? orderData.id\n                : orderData.renewal_order_id\n        }${resend ? 'R'.repeat(resendCount + 1) : ''}`,\n        poNumber: `${\n            orderType === OrderType.Order\n                ? orderData.id\n                : orderData.renewal_order_id\n        }${resend ? 'R'.repeat(resendCount + 1) : ''}`,\n        deliveryService: 'UPS Priority 2-Day',\n        allowOverrideDeliveryService: true,\n        allowOverrideEssentialCopyGuidance: true,\n        lfPracticeId: parseInt(process.env.NEXT_PUBLIC_EPID!),\n        referenceFields: '',\n    };\n\n    /**\n     * Prescriber details have to be loaded continuously per Rx, so defining here.\n     */\n    const PRESCRIBER_OBJECT = {\n        npi: '1013986835',\n        stateLicenseNumber: 'ME80459',\n        lastName: 'Desai',\n        firstName: 'Bobby',\n        address: {\n            city: 'New York',\n            postalCode: '10014',\n            countryCode: 'US',\n            addressLine1: '875 Washington Street',\n            stateProvince: 'NY',\n        },\n        phoneNumber: '7476668167',\n    };\n\n    /**\n     * Parse if address line 2 exists, since it cannot be null.\n     */\n    const addressLineTwo =\n        orderType === OrderType.Order\n            ? orderData.address_line2\n            : orderData.order.address_line2;\n\n    /**\n     * Patient object needs to be loaded in for each Rx item.\n     */\n    const PATIENT_OBJECT: EmpowerPatient = {\n        clientPatientId: patientData.id,\n        lastName: patientData.last_name,\n        firstName: patientData.first_name,\n        gender: patientData.sex_at_birth?.charAt(0) ?? 'U',\n        dateOfBirth: patientData.date_of_birth,\n        address: {\n            addressLine1:\n                orderType === OrderType.Order\n                    ? orderData.address_line1\n                    : orderData.order.address_line1,\n            addressLine2: addressLineTwo === '' ? null : addressLineTwo,\n            city:\n                orderType === OrderType.Order\n                    ? orderData.city\n                    : orderData.order.city,\n            stateProvince:\n                orderType === OrderType.Order\n                    ? orderData.state\n                    : orderData.order.state,\n            postalCode:\n                orderType === OrderType.Order\n                    ? orderData.zip\n                    : orderData.order.zip,\n            countryCode: 'US',\n        },\n        phoneNumber: patientData.phone_number.replace(/\\D/g, ''),\n        email: patientData.email,\n    };\n\n    /**\n     * These details will be consistent throughout all Rx medications added.\n     */\n    const MEDICATION_STATIC_VARIABLES = {\n        refills: '0',\n        writtenDate: new Date().toISOString().split('T')[0],\n        note: 'From Bioverse, Supervising physician: Dr. Bobby Desai, MD',\n    };\n\n    /**\n     * 12/11/24 new method of fetching Empower Catalog Instruction Object.\n     * Fetches an object that interacts with the below code to generate the script.\n     */\n    const variant_index_script_instructions = getEmpowerCatalogObject(\n        orderData.product_href as PRODUCT_HREF,\n        override?.variant_index ?? orderData.variant_index\n    );\n\n    const newRxArrayConstructed: EmpowerNewRx[] = [];\n\n    const sigs_list: string[] = [];\n\n    let diagnosis_obtained;\n    diagnosis_obtained = getDiagnosisWithBMIData(\n        bmi_data ?? {\n            height_feet: 0,\n            height_inches: 0,\n            weight_lbs: 0,\n            bmi: 0,\n        }\n    );\n\n    //construct Diagnosis Object\n    const diagnosis: EmpowerDiagnosis =\n        diagnosis_obtained.code !== ''\n            ? {\n                  clinicalInformationQualifier: 0,\n                  primary: {\n                      code: diagnosis_obtained.code,\n                      qualifier: 0,\n                      description: diagnosis_obtained.description,\n                  },\n              }\n            : {\n                  clinicalInformationQualifier: 0,\n                  primary: {\n                      code: 'E66.9',\n                      qualifier: 0,\n                      description: 'Obesity',\n                  },\n              };\n\n    if (\n        variant_index_script_instructions &&\n        variant_index_script_instructions.array\n    ) {\n        /**\n         * Iterating through the instructions object to create the Rx's array for the script.\n         */\n        variant_index_script_instructions.array.forEach(\n            (rxItemInstruction: ScriptInstruction) => {\n                const catalogItemData = searchEmpowerItemCatalogByCode(\n                    rxItemInstruction.catalogItemCode\n                );\n\n                const newMedicationItem: EmpowerMedication = {\n                    ...MEDICATION_STATIC_VARIABLES,\n                    ...catalogItemData,\n                    quantity: `${rxItemInstruction.quantity}`,\n                    sigText: rxItemInstruction.sigText,\n                    daysSupply: `${rxItemInstruction.daysSupply}`,\n                    diagnosis: diagnosis,\n                };\n\n                const newRxItem: EmpowerNewRx = {\n                    medication: newMedicationItem,\n                    patient: PATIENT_OBJECT,\n                    prescriber: PRESCRIBER_OBJECT,\n                };\n\n                sigs_list.push(rxItemInstruction.internalSigText);\n\n                newRxArrayConstructed.push(newRxItem);\n                return;\n            }\n        );\n    }\n\n    /**\n     * Putting the item together to be returned.\n     */\n    const script_json: EmpowerPrescriptionOrder = {\n        ...SCRIPT_NON_REPEATED_VARIABLES,\n        newRxs: newRxArrayConstructed,\n    };\n\n    //results:\n    //script_json\n    //sigs_list\n\n    return {\n        script: script_json,\n        sigs: sigs_list,\n        displayName:\n            variant_index_script_instructions?.selectDisplayName ??\n            'display name not set',\n    };\n}"
      },
      {
        "name": "generateCustomEmpowerScript",
        "kind": "function",
        "signature": "export function generateCustomEmpowerScript(\n    patientData: APProfileData,\n    custom_order_id: string,\n    product_href: string,\n    variant_index: number,\n    shipping_information: AddressInterface,\n    bmi_data?: {\n        height_feet: number;\n        height_inches: number;\n        weight_lbs: number;\n        bmi: number;\n    }\n): EmpowerGeneratedScript {\n    /**\n     * Scripts have key-values that are not repeated within Rx's - defined here.\n     */\n    const SCRIPT_NON_REPEATED_VARIABLES = {\n        clientOrderId: custom_order_id,\n        poNumber: custom_order_id,\n        deliveryService: 'UPS Priority 2-Day',\n        allowOverrideDeliveryService: true,\n        allowOverrideEssentialCopyGuidance: true,\n        lfPracticeId: parseInt(process.env.NEXT_PUBLIC_EPID!),\n        referenceFields: '',\n    };\n\n    /**\n     * Prescriber details have to be loaded continuously per Rx, so defining here.\n     */\n    const PRESCRIBER_OBJECT = {\n        npi: '1013986835',\n        stateLicenseNumber: 'ME80459',\n        lastName: 'Desai',\n        firstName: 'Bobby',\n        address: {\n            city: 'New York',\n            postalCode: '10014',\n            countryCode: 'US',\n            addressLine1: '875 Washington Street',\n            stateProvince: 'NY',\n        },\n        phoneNumber: '7476668167',\n    };\n\n    /**\n     * Parse if address line 2 exists, since it cannot be null.\n     */\n    const addressLineTwo = shipping_information.address_line2;\n\n    /**\n     * Patient object needs to be loaded in for each Rx item.\n     */\n    const PATIENT_OBJECT: EmpowerPatient = {\n        clientPatientId: patientData.id,\n        lastName: patientData.last_name,\n        firstName: patientData.first_name,\n        gender: patientData.sex_at_birth.charAt(0),\n        dateOfBirth: patientData.date_of_birth,\n        address: {\n            addressLine1: shipping_information.address_line1,\n            addressLine2: addressLineTwo === '' ? undefined : addressLineTwo,\n            city: shipping_information.city,\n            stateProvince: shipping_information.state,\n            postalCode: shipping_information.zip,\n            countryCode: 'US',\n        },\n        phoneNumber: patientData.phone_number.replace(/\\D/g, ''),\n        email: patientData.email,\n    };\n\n    /**\n     * These details will be consistent throughout all Rx medications added.\n     */\n    const MEDICATION_STATIC_VARIABLES = {\n        refills: '0',\n        writtenDate: new Date().toISOString().split('T')[0],\n        note: 'From Bioverse, Supervising physician: Dr. Bobby Desai, MD',\n    };\n\n    /**\n     * 12/11/24 new method of fetching Empower Catalog Instruction Object.\n     * Fetches an object that interacts with the below code to generate the script.\n     */\n    const variant_index_script_instructions = getEmpowerCatalogObject(\n        product_href as PRODUCT_HREF,\n        variant_index\n    );\n\n    const newRxArrayConstructed: EmpowerNewRx[] = [];\n\n    const sigs_list: string[] = [];\n\n    let diagnosis_obtained;\n    diagnosis_obtained = getDiagnosisWithBMIData(bmi_data);\n\n    //construct Diagnosis Object\n    const diagnosis: EmpowerDiagnosis =\n        diagnosis_obtained.code !== ''\n            ? {\n                  clinicalInformationQualifier: 0,\n                  primary: {\n                      code: diagnosis_obtained.code,\n                      qualifier: 0,\n                      description: diagnosis_obtained.description,\n                  },\n              }\n            : {\n                  clinicalInformationQualifier: 0,\n                  primary: {\n                      code: 'E66.9',\n                      qualifier: 0,\n                      description: 'Obesity',\n                  },\n              };\n\n    if (\n        variant_index_script_instructions &&\n        variant_index_script_instructions.array\n    ) {\n        /**\n         * Iterating through the instructions object to create the Rx's array for the script.\n         */\n        variant_index_script_instructions.array.forEach(\n            (rxItemInstruction: ScriptInstruction) => {\n                const catalogItemData = searchEmpowerItemCatalogByCode(\n                    rxItemInstruction.catalogItemCode\n                );\n\n                const newMedicationItem: EmpowerMedication = {\n                    ...MEDICATION_STATIC_VARIABLES,\n                    ...catalogItemData,\n                    quantity: `${rxItemInstruction.quantity}`,\n                    sigText: rxItemInstruction.sigText,\n                    daysSupply: `${rxItemInstruction.daysSupply}`,\n                    diagnosis: diagnosis,\n                };\n\n                const newRxItem: EmpowerNewRx = {\n                    medication: newMedicationItem,\n                    patient: PATIENT_OBJECT,\n                    prescriber: PRESCRIBER_OBJECT,\n                };\n\n                sigs_list.push(rxItemInstruction.internalSigText);\n\n                newRxArrayConstructed.push(newRxItem);\n                return;\n            }\n        );\n    }\n\n    /**\n     * Putting the item together to be returned.\n     */\n    const script_json: EmpowerPrescriptionOrder = {\n        ...SCRIPT_NON_REPEATED_VARIABLES,\n        newRxs: newRxArrayConstructed,\n    };\n\n    //results:\n    //script_json\n    //sigs_list\n\n    return {\n        script: script_json,\n        sigs: sigs_list,\n        displayName:\n            variant_index_script_instructions?.selectDisplayName ??\n            'display name not set',\n    };\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/classes/Scripts/EmpowerScriptHandler.ts",
      "bioverse-client/app/utils/actions/intake/order-util.ts",
      "bioverse-client/app/utils/actions/alternatives/weight-loss/alternative-weight-loss-actions.ts",
      "bioverse-client/app/utils/functions/pharmacy-helpers/bundle-to-single-vial-converter.ts",
      "bioverse-client/app/utils/functions/prescription-scripts/empower-approval-script-generator.ts",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/confirm-prescription-dialog.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/resend-script-confirmation.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approve-script-dialog.tsx",
      "bioverse-client/app/services/pharmacy-integration/util/utils.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/custom-prescription-script/custom-prescription-script-utils.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/prescription-scripts/hallandale-approval-script-generator.ts",
    "exports": [
      {
        "name": "generateHallandaleScript",
        "kind": "function",
        "signature": "export function generateHallandaleScript(\n    patientData: DBPatientData,\n    orderData: DBOrderData,\n    addressData: AddressInterface,\n    orderType: OrderType,\n    variant_index: number,\n    custom_order_id?: string\n):\n    | { script: HallandaleOrderObject; sigs: string[]; displayName: string }\n    | undefined {\n    custom_order_id = custom_order_id ?? orderData.id;\n    let hallandaleScript: HallandaleOrderObject = {\n        general: {\n            referenceId: custom_order_id,\n        },\n        // prescriber: {\n        //     npi: '1689995771',\n        //     lastName: 'Echeverry',\n        //     firstName: 'German',\n        //     licenseState: 'FL',\n        //     licenseNumber: 'ME138578',\n        // },\n        prescriber: {\n            npi: '1013986835',\n            lastName: 'Desai',\n            firstName: 'Bobby',\n            licenseState: 'FL',\n            licenseNumber: 'ME80459',\n        },\n        practice: {\n            id: parseInt(process.env.NEXT_PUBLIC_HALLANDALE_PRACTICE_ID!),\n        },\n        patient: {\n            lastName: patientData.last_name,\n            firstName: patientData.first_name,\n            gender: parseHallandaleGender(patientData.sex_at_birth),\n            dateOfBirth: patientData.date_of_birth,\n            address1: addressData.address_line1,\n            address2: addressData.address_line2,\n            city: addressData.city,\n            state: addressData.state,\n            zip: addressData.zip,\n            phoneHome: patientData.phone_number,\n            email: patientData.email,\n        },\n        billing: {\n            payorType: 'doc',\n        },\n        shipping: {\n            recipientType: 'patient',\n            recipientFirstName: patientData.first_name,\n            recipientLastName: patientData.last_name,\n            recipientPhone: patientData.phone_number,\n            recipientEmail: patientData.email,\n            addressLine1: addressData.address_line1,\n            addressLine2: addressData.address_line2,\n            city: addressData.city,\n            state: addressData.state,\n            zipCode: addressData.zip,\n            country: 'US',\n            service: 6230,\n        },\n        rxs: [],\n    };\n\n    const sigs_list: string[] = [];\n\n    const HALLANDALE_CATALOG_ITEM = getHallandaleCatalogObject(\n        orderData.product_href as PRODUCT_HREF,\n        variant_index\n    );\n\n    if (HALLANDALE_CATALOG_ITEM) {\n        const newRxsList = HALLANDALE_CATALOG_ITEM.array.map((rx_item: any) => {\n            const rx_catalog_data = searchHallandaleItemCatalogByCode(\n                rx_item.catalogItemCode\n            );\n\n            sigs_list.push(rx_item.sigText);\n\n            return {\n                rxType: 'new',\n                drugName: rx_catalog_data.product_name,\n                drugStrength: rx_catalog_data.product_strength,\n                drugForm: rx_catalog_data.product_form,\n                lfProductID: rx_catalog_data.product_code,\n                quantity: rx_item.quantity,\n                directions: rx_item.sigText,\n                refills: 0,\n                dateWritten: getCurrentDate(),\n                daysSupply: rx_item.daysSupply,\n                internalSigDisplay: rx_item.internalDisplaySigText,\n            };\n        });\n\n        hallandaleScript = {\n            ...hallandaleScript,\n            rxs: newRxsList,\n        };\n\n        return {\n            script: hallandaleScript,\n            sigs: sigs_list,\n            displayName: HALLANDALE_CATALOG_ITEM.selectDisplayName,\n        };\n    } else {\n        return undefined;\n    }\n}"
      },
      {
        "name": "generateHallandaleScriptAsync",
        "kind": "function",
        "signature": "export async function generateHallandaleScriptAsync(\n    patientId: string,\n    orderId: string,\n    override?: ScriptOverrideObject,\n    resend?: boolean\n): Promise<\n    | { script: HallandaleOrderObject; sigs: string[]; displayName: string }\n    | undefined\n> {\n    const { type: orderType, data: orderData } = await fetchOrderData(orderId);\n    const { data: patientData, error } = await getPatientInformationById(\n        patientId\n    );\n\n    if (error) {\n        throw new Error(error.message);\n    }\n\n    const resendCount = await getResendCount(\n        parseInt(orderId),\n        orderType === OrderType.Order ? undefined : orderData.renewal_order_id\n    );\n\n    const addressLineTwo =\n        orderType === OrderType.Order\n            ? orderData.address_line2\n            : orderData.order.address_line2;\n\n    let hallandaleScript: HallandaleOrderObject = {\n        general: {\n            referenceId: `${\n                orderType === OrderType.Order\n                    ? orderData.id\n                    : orderData.renewal_order_id\n            }${resend ? 'R'.repeat(resendCount + 1) : ''}`,\n        },\n        prescriber: {\n            npi: '1013986835',\n            lastName: 'Desai',\n            firstName: 'Bobby',\n            licenseState: 'FL',\n            licenseNumber: 'ME80459',\n        },\n        practice: {\n            id: parseInt(process.env.NEXT_PUBLIC_HALLANDALE_PRACTICE_ID!),\n        },\n        patient: {\n            lastName: patientData.last_name,\n            firstName: patientData.first_name,\n            gender: parseHallandaleGender(patientData.sex_at_birth),\n            dateOfBirth: patientData.date_of_birth,\n            address1:\n                orderType === OrderType.Order\n                    ? orderData.address_line1\n                    : orderData.order.address_line1,\n            address2: addressLineTwo === '' ? null : addressLineTwo,\n            city:\n                orderType === OrderType.Order\n                    ? orderData.city\n                    : orderData.order.city,\n            state:\n                orderType === OrderType.Order\n                    ? orderData.state\n                    : orderData.order.state,\n            zip:\n                orderType === OrderType.Order\n                    ? orderData.zip\n                    : orderData.order.zip,\n            phoneHome: patientData.phone_number,\n            email: patientData.email,\n        },\n        billing: {\n            payorType: 'doc',\n        },\n        shipping: {\n            recipientType: 'patient',\n            recipientFirstName: patientData.first_name,\n            recipientLastName: patientData.last_name,\n            recipientPhone: patientData.phone_number,\n            recipientEmail: patientData.email,\n            addressLine1:\n                orderType === OrderType.Order\n                    ? orderData.address_line1\n                    : orderData.order.address_line1,\n            addressLine2: addressLineTwo === '' ? null : addressLineTwo,\n            city:\n                orderType === OrderType.Order\n                    ? orderData.city\n                    : orderData.order.city,\n            state:\n                orderType === OrderType.Order\n                    ? orderData.state\n                    : orderData.order.state,\n            zipCode:\n                orderType === OrderType.Order\n                    ? orderData.zip\n                    : orderData.order.zip,\n            country: 'US',\n            service: 6230,\n        },\n        rxs: [],\n    };\n\n    const sigs_list: string[] = [];\n\n    const HALLANDALE_CATALOG_ITEM = getHallandaleCatalogObject(\n        orderData.product_href as PRODUCT_HREF,\n        orderData.variant_index\n    );\n\n    if (HALLANDALE_CATALOG_ITEM) {\n        const newRxsList = HALLANDALE_CATALOG_ITEM.array.map((rx_item: any) => {\n            const rx_catalog_data = searchHallandaleItemCatalogByCode(\n                rx_item.catalogItemCode\n            );\n\n            sigs_list.push(rx_item.sigText);\n\n            return {\n                rxType: 'new',\n                drugName: rx_catalog_data.product_name,\n                drugStrength: rx_catalog_data.product_strength,\n                drugForm: rx_catalog_data.product_form,\n                lfProductID: rx_catalog_data.product_code,\n                quantity: rx_item.quantity,\n                directions: rx_item.sigText,\n                refills: 0,\n                dateWritten: getCurrentDate(),\n                daysSupply: rx_item.daysSupply,\n                internalSigDisplay: rx_item.internalDisplaySigText,\n            };\n        });\n\n        hallandaleScript = {\n            ...hallandaleScript,\n            rxs: newRxsList,\n        };\n\n        return {\n            script: hallandaleScript,\n            sigs: sigs_list,\n            displayName: HALLANDALE_CATALOG_ITEM.selectDisplayName,\n        };\n    } else {\n        return undefined;\n    }\n}"
      },
      {
        "name": "sendMoreNeedlesHallandale",
        "kind": "function",
        "signature": "export async function sendMoreNeedlesHallandale(\n    patientData: APProfileData,\n    orderData: OrderTabOrder,\n    custom_order_id?: string\n):\n    Promise<boolean> {\n        custom_order_id = custom_order_id ?? orderData.id;\n        let hallandaleScript: HallandaleOrderObject = {\n            general: {\n                referenceId: custom_order_id,\n            },\n            // prescriber: {\n            //     npi: '1689995771',\n            //     lastName: 'Echeverry',\n            //     firstName: 'German',\n            //     licenseState: 'FL',\n            //     licenseNumber: 'ME138578',\n            // },\n            prescriber: {\n                npi: '1013986835',\n                lastName: 'Desai',\n                firstName: 'Bobby',\n                licenseState: 'FL',\n                licenseNumber: 'ME80459',\n            },\n            practice: {\n                id: parseInt(process.env.NEXT_PUBLIC_HALLANDALE_PRACTICE_ID!),\n            },\n            patient: {\n                lastName: patientData.last_name,\n                firstName: patientData.first_name,\n                gender: parseHallandaleGender(patientData.sex_at_birth),\n                dateOfBirth: patientData.date_of_birth,\n                address1: orderData.address_line1,\n                address2: orderData.address_line2,\n                city: orderData.city,\n                state: orderData.state,\n                zip: orderData.zip,\n                phoneHome: patientData.phone_number,\n                email: patientData.email,\n            },\n            billing: {\n                payorType: 'doc',\n            },\n            shipping: {\n                recipientType: 'patient',\n                recipientFirstName: patientData.first_name,\n                recipientLastName: patientData.last_name,\n                recipientPhone: patientData.phone_number,\n                recipientEmail: patientData.email,\n                addressLine1: orderData.address_line1,\n                addressLine2: orderData.address_line2,\n                city: orderData.city,\n                state: orderData.state,\n                zipCode: orderData.zip,\n                country: 'US',\n                service: 6230,\n            },\n            rxs: [],\n        };\n    \n    \n        const needleRx: HallandaleNewRxObject =  {\n                rxType: 'new',\n                drugName: 'GLP-1 Inj Kit',\n                drugStrength: 'Insulin Syringe 30G 5/16\" 1 mL (#10), Alcohol Pads (#30)',\n                drugForm: 'Supplies',\n                lfProductID: 7963303,\n                quantity: 2,\n                directions: \"Additional Syringes for GLP-1 Patient\",\n                refills: 0,\n                dateWritten: getCurrentDate(),\n                daysSupply: 90,\n                internalSigDisplay: [\"Additional Syringes for GLP-1 Patient\"],\n        } \n            \n        hallandaleScript = {\n            ...hallandaleScript,\n            document: { pdfBase64: '' },\n            rxs: [needleRx],\n        } as HallandaleOrderObject;\n\n\n        console.log(\"SCRIPTR!1\", hallandaleScript)\n\n        const url = process.env.HALLANDALE_API_URL!;\n        const username = process.env.HALLANDALE_API_USERNAME!;\n        const password = process.env.HALLANDALE_API_PASSWORD!;\n        const headers = new Headers({\n            'Content-Type': 'application/json',\n            Authorization: 'Basic ' + btoa(`${username}:${password}`),\n            'X-Vendor-ID': process.env.HALLANDALE_X_VENDOR_ID!,\n            'X-Location-ID': process.env.HALLANDALE_X_LOCATION_ID!,\n            'X-API-Network-ID': process.env.HALLANDALE_X_API_NETWORK_ID!,\n        });\n\n        hallandaleScript.general!.referenceId = orderData.id + \"N\";\n\n        const hallandaleScriptObj = {\n            message: { id: orderData.id + \"N\", sentTime: new Date().toISOString() },\n            order: hallandaleScript,\n        }\n        \n        const response = await fetch(url, {\n            method: 'POST',\n            headers: headers,\n            body: JSON.stringify(hallandaleScriptObj),\n        });\n\n        if (response.status !== 200) {\n            console.log(\"ERROR SENDING SCRIPT\", response)\n            return false;\n        }\n\n        console.log(\"RESPONSE\", response)\n\n        return true;\n    }"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(testing_and_development)/olivier-dev/utils.ts",
      "bioverse-client/app/utils/classes/Scripts/HallandaleScriptHandler.ts",
      "bioverse-client/app/utils/actions/intake/order-util.ts",
      "bioverse-client/app/utils/functions/pharmacy-helpers/bundle-to-single-vial-converter.ts",
      "bioverse-client/app/utils/functions/prescription-scripts/hallandale-approval-script-generator.ts",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/confirm-prescription-dialog.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/resend-script-confirmation.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approve-script-dialog.tsx",
      "bioverse-client/app/api/supabase/annual-glp1/route.ts",
      "bioverse-client/app/services/pharmacy-integration/hallandale/hallandale-script-api.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/order-tab-row.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/prescription-scripts/prescription-scripts-utils.ts",
    "exports": [
      {
        "name": "updatePrescriptionScript",
        "kind": "function",
        "signature": "export function updatePrescriptionScript(\n    oldScript: EmpowerPrescriptionOrder,\n    newClientOrderId: string,\n): EmpowerPrescriptionOrder {\n    const date = new Date();\n    const year = date.getFullYear();\n    const month = String(date.getMonth() + 1).padStart(2, '0'); // Months are 0-based, so add 1\n    const day = String(date.getDate()).padStart(2, '0');\n    const newDate = `${year}-${month}-${day}`;\n\n    try {\n        oldScript.newRxs.forEach((rx: EmpowerNewRx) => {\n            // Update the writtenDate\n            rx.prescriber = ECHEVERRY_PRESCRIBER_OBJECT;\n            rx.medication.writtenDate = newDate;\n        });\n        if (newClientOrderId) {\n            oldScript.clientOrderId = newClientOrderId;\n        }\n        return oldScript;\n    } catch (error) {\n        console.error('Error updating prescription script', oldScript, error);\n    }\n    return oldScript;\n}"
      },
      {
        "name": "updatePrescriptionProvider",
        "kind": "function",
        "signature": "export function updatePrescriptionProvider(\n    oldScript: EmpowerPrescriptionOrder,\n): EmpowerPrescriptionOrder {\n    const date = new Date();\n    const year = date.getFullYear();\n    const month = String(date.getMonth() + 1).padStart(2, '0'); // Months are 0-based, so add 1\n    const day = String(date.getDate()).padStart(2, '0');\n    const newDate = `${year}-${month}-${day}`;\n    try {\n        oldScript.newRxs.forEach((rx: EmpowerNewRx) => {\n            // Update the writtenDate\n            rx.prescriber = ECHEVERRY_PRESCRIBER_OBJECT;\n            rx.medication.writtenDate = newDate;\n        });\n\n        return oldScript;\n    } catch (error) {\n        console.error('Error updating prescription script', oldScript, error);\n    }\n    return oldScript;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/database/controller/orders/process-manual-order.ts",
      "bioverse-client/app/utils/classes/Pharmacy.ts",
      "bioverse-client/app/utils/functions/prescription-scripts/prescription-scripts-utils.ts",
      "bioverse-client/app/services/pharmacy-integration/empower/provider-script-feedback.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/prescription-scripts/revive-script-generator.ts",
    "exports": [
      {
        "name": "generateReviveScript",
        "kind": "function",
        "signature": "export async function generateReviveScript(\n    patientId: string,\n    orderId: string,\n    override?: ScriptOverrideObject,\n    resend?: boolean\n) {\n    /**\n     * Order:\n     *\n     * Get patient information\n     *\n     * Use order ID to find order information renewal vs first time\n     *\n     * Find the medication data on map\n     * - Populate the most recent written date.\n     *\n     * Put it all together\n     *\n     * Return script JSON.\n     *\n     */\n\n    //Order data will either be a renewal or first time order & we need the type.\n    const { type: order_type, data: order_data_any } = await fetchOrderData(\n        orderId\n    );\n\n    //Interfacing the data for ease of code writing & type safety\n    const order_data: DBOrderData = order_data_any;\n    const product_href: string = override\n        ? override.product_href\n        : order_data.product_href;\n    const variant_index = override\n        ? override.variant_index\n        : order_data.variant_index;\n\n    if (!REVIVE_ALLOWED_PRODUCT_MAP[product_href]?.includes(variant_index)) {\n        console.error('Product - Variant Mapping is not for Revive');\n        return {\n            script_json: null,\n            error: 'Product - Variant Mapping is not for Revive',\n        };\n    }\n\n    try {\n        const reviveGeneratedPatientData =\n            await retrieveOrCreateAndRetrieveRevivePatientData(patientId);\n\n        const reviveMedicationMapping =\n            REVIVE_PRODUCT_VARIANT_MAP[product_href][variant_index];\n\n        // Format the current date in the specified format\n        const currentDate = new Date();\n        const formattedDate = currentDate\n            .toLocaleString('en-US', {\n                year: 'numeric',\n                month: '2-digit',\n                day: '2-digit',\n                hour: '2-digit',\n                minute: '2-digit',\n                second: '2-digit',\n                timeZoneName: 'short',\n                hour12: false,\n            })\n            .replace(\n                /(\\d+)\\/(\\d+)\\/(\\d+),\\s(\\d+):(\\d+):(\\d+)\\s(.+)/,\n                '$3-$1-$2T$4:$5:$6$7'\n            );\n\n        // Process each item in the mapping array\n        const processedMedicationMapping = reviveMedicationMapping.map(\n            (item) => ({\n                ...item,\n                date_issued: formattedDate,\n                medication_order_entry_identifier: uuidv4(),\n            })\n        );\n\n        const reviveGeneratedScript: ReviveScriptJSON = {\n            medication_requests: processedMedicationMapping,\n            patient: reviveGeneratedPatientData,\n            clinic_identifier: 'bed973e6-444a-4098-a881-b1990f6ce5c7',\n            practitioner_identifier: 'ee6bc798-fb24-40e6-a2bc-267eb7a2e878',\n            medication_order_identifier: uuidv4(),\n        };\n\n        return {\n            script_json: reviveGeneratedScript,\n            error: null,\n        };\n    } catch (error) {\n        console.error('ERROR in genrating revive script: ', error);\n        return {\n            script_json: null,\n            error: 'Error in generating script: ' + JSON.stringify(error),\n        };\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(testing_and_development)/ben-dev/page.tsx",
      "bioverse-client/app/utils/classes/Scripts/ReviveScriptHandler.ts",
      "bioverse-client/app/utils/actions/intake/order-util.ts",
      "bioverse-client/app/utils/functions/prescription-scripts/revive-script-generator.ts",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/confirm-prescription-dialog.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/resend-script-confirmation.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approve-script-dialog.tsx",
      "bioverse-client/app/api/supabase/split-shipment-glp1/route.ts",
      "bioverse-client/app/services/pharmacy-integration/util/utils.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/prescription-scripts/tmc-approval-script-generator.ts",
    "exports": [
      {
        "name": "generateTMCScript",
        "kind": "function",
        "signature": "export function generateTMCScript(\n    orderData: DBOrderData,\n    patientData: DBPatientData,\n    allergyData: string\n) {\n    const prescriptionForm: TMCPrescriptionForm = {\n        prescriptions: [\n            {\n                // physician_npi: '1780019117', //german echeverry\n                physician_npi: '1013986835', //bobby desai\n                shipping_method: 'Standard Ground',\n                shipping_address: {\n                    shipping_city: orderData.city || 'none',\n                    shipping_postal_code: orderData.zip || '00000',\n                    shipping_state: orderData.state || 'none',\n                    shipping_street: orderData.address_line1 || undefined,\n                    shipping_address_line2:\n                        orderData.address_line2 || undefined,\n                    shipping_country: 'United States',\n                },\n                patient: {\n                    first_name: patientData.first_name || 'N/A',\n                    last_name: patientData.last_name || 'N/A',\n                    dob: patientData.date_of_birth || '2000/1/1',\n                    gender: patientData.sex_at_birth || 'NA',\n                    email: patientData.email || 'none',\n                    phone: patientData.phone_number || 'none',\n                    //   ssn: '',\n                    allergies: allergyData || 'none',\n                },\n                prescription_items: [\n                    {\n                        Id: '',\n                        Quantity: '',\n                        NoOfOriginalRefills: '0',\n                        NoOfRefillRemaining: '0',\n                        Sig: '',\n                        Reason_for_Compounding:\n                            'Product not available commercially',\n                    },\n                ],\n            },\n        ],\n    };\n\n    const medication_object = findMedicationByHref(orderData.product_href);\n\n    console.log('href ', orderData.product_href);\n    console.log('med obj: ', medication_object);\n\n    const updatePrescriptionForm = (\n        prescriptionForm: TMCPrescriptionForm,\n        newPrescriptionItem: TMCPrescriptionItem\n    ): TMCPrescriptionForm => {\n        // Create a deep copy to avoid mutating state directly\n        const newForm = prescriptionForm;\n\n        // Update the prescription_items of the first prescription\n        newForm.prescriptions[0].prescription_items = [newPrescriptionItem];\n\n        return newForm;\n    };\n\n    const addSecondaryItemWithSpecification = (\n        prescriptionForm: TMCPrescriptionForm,\n        id: string,\n        quantity: number = 1,\n        sig: string\n    ): void => {\n        // Note the return type is now void since we're mutating the input directly\n        // Check if there is an item at index [1] and remove it if it exists\n        if (prescriptionForm.prescriptions[0].prescription_items.length > 1) {\n            prescriptionForm.prescriptions[0].prescription_items.splice(1, 1);\n        }\n\n        // Add a new item to the prescription_items array of the first prescription\n        prescriptionForm.prescriptions[0].prescription_items.push({\n            Id: id,\n            Quantity: String(quantity),\n            NoOfOriginalRefills: '0',\n            NoOfRefillRemaining: '0',\n            Sig: sig,\n        });\n\n        // Since we're modifying the input directly, no need to return anything\n    };\n\n    switch (orderData.product_href) {\n        case 'b12-injection':\n            const newPrescriptionItem = {\n                Id: medication_object!.id,\n                Quantity: orderData.subscription_type === 'monthly' ? '1' : '3',\n                NoOfOriginalRefills: '0',\n                NoOfRefillRemaining: '0',\n                Sig: medication_object!.sig,\n                Reason_for_Compounding: 'Product not available commercially',\n            };\n\n            console.log('treated as b12');\n\n            updatePrescriptionForm(prescriptionForm, newPrescriptionItem);\n\n            break;\n        case 'nad-injection':\n        case 'glutathione-injection':\n            const newPrescriptionItemNonB12 = {\n                Id: medication_object!.id,\n                Quantity: '1',\n                NoOfOriginalRefills: '0',\n                NoOfRefillRemaining: '0',\n                Sig: medication_object!.sig,\n                Reason_for_Compounding: 'Product not available commercially',\n            };\n\n            updatePrescriptionForm(prescriptionForm, newPrescriptionItemNonB12);\n\n            addSecondaryItemWithSpecification(\n                prescriptionForm,\n                '01t1R000007FvGmQAK',\n                2,\n                medication_object!.sig\n            );\n\n            break;\n    }\n\n    return prescriptionForm;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/prescription-scripts/tmc-approval-script-generator.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approve-script-dialog.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/pricing.ts",
    "exports": [
      {
        "name": "constructPricingStructure",
        "kind": "variable",
        "signature": "constructPricingStructure = (\n    productData: any,\n    priceData: ProductVariantRecord[],\n    shouldDiscount: boolean,\n) => {\n    // Construct { full_price, subscribesave_price, coupon_price, total_price }\n    const subscriptionType = productData['subscriptionType'];\n    const variant = productData['variant'];\n    const productName = productData['productName'];\n    const product = priceData[variant].price_data;\n\n    if (productName === CGM_SENSOR_PRODUCT_HREF) {\n        if (subscriptionType === 'monthly') {\n            const total_price = 195 - (shouldDiscount ? 20 : 0);\n            return {\n                item_price: '238.00',\n                subscribe_save_price: '43.00',\n                total_price: total_price.toFixed(2),\n                ...(shouldDiscount && {\n                    coupon_price: parseFloat(\n                        product.discount_price.discount_amount,\n                    ).toFixed(2),\n                }),\n            };\n        }\n    }\n\n    let res: any = {};\n    var full_price = parseFloat(product.product_price);\n    res['item_price'] = full_price;\n\n    // Determine if should apply Subscribe + Save (aka only monthly products)\n    if (subscriptionType !== 'quarterly' && subscriptionType !== 'one_time') {\n        // Apply Subscribe & Save\n\n        const oneTimePriceRecord = priceData.find(\n            (record) => record.cadence === 'one_time',\n        );\n\n        if (oneTimePriceRecord) {\n            const one_time_price = parseFloat(\n                oneTimePriceRecord.price_data.product_price,\n            );\n\n            const subscribe_save_price = product.product_price - one_time_price;\n            res['subscribe_save_price'] = Math.abs(subscribe_save_price);\n        }\n    }\n\n    // Determine coupon savings\n    // Dont apply coupon savings if it's one-time\n    if (\n        (subscriptionType !== 'one_time' && shouldDiscount) ||\n        isWeightlossProduct(productData.productName)\n    ) {\n        const coupon_price = parseFloat(product.discount_price.discount_amount);\n        res['coupon_price'] = coupon_price;\n    }\n\n    const total =\n        full_price -\n        (res['subscribe_save_price'] ?? 0) -\n        (res['coupon_price'] ?? 0);\n    res['total_price'] = total;\n\n    return Object.keys(res).reduce((acc: any, key: any) => {\n        // Convert each value to a string with two decimal places and then to a number\n        acc[key] = res[key].toFixed(2);\n        return acc;\n    }, {});\n}"
      },
      {
        "name": "isVialProduct",
        "kind": "variable",
        "signature": "isVialProduct = (product_href: string) => {\n    if (\n        product_href === 'ozempic' ||\n        product_href === 'nad-injection' ||\n        product_href === 'semaglutide' ||\n        product_href === 'wegovy' ||\n        product_href === 'tirzepatide' ||\n        product_href === 'mounjaro' ||\n        product_href === 'b12-injection' ||\n        product_href === 'glutathione-injection'\n    ) {\n        return true;\n    }\n    return false;\n}"
      },
      {
        "name": "isAdvertisedProduct",
        "kind": "variable",
        "signature": "isAdvertisedProduct = (product_href: string) => {\n    // TODO: Remove glutathione here\n    if (\n        product_href === SEMAGLUTIDE_PRODUCT_HREF\n        // ||\n        // product_href === 'tirzepatide' ||\n        // product_href === 'nad_injection'\n    ) {\n        return true;\n    }\n    return false;\n}"
      },
      {
        "name": "isWeightlossProduct",
        "kind": "variable",
        "signature": "isWeightlossProduct = (product_href: string) => {\n    // TODO: Remove glutathione here\n    if (\n        product_href === 'ozempic' ||\n        product_href === 'semaglutide' ||\n        product_href === 'wegovy' ||\n        product_href === 'tirzepatide' ||\n        product_href === 'mounjaro' ||\n        product_href === PRODUCT_HREF.WEIGHT_LOSS\n    ) {\n        return true;\n    }\n    return false;\n}"
      },
      {
        "name": "isGLP1Product",
        "kind": "variable",
        "signature": "isGLP1Product = (product_href: string) => {\n    // TODO: Remove glutathione here\n    if (\n        product_href === PRODUCT_HREF.OZEMPIC ||\n        product_href === PRODUCT_HREF.SEMAGLUTIDE ||\n        product_href === PRODUCT_HREF.WEGOVY ||\n        product_href === PRODUCT_HREF.TIRZEPATIDE ||\n        product_href === PRODUCT_HREF.MOUNJARO\n    ) {\n        return true;\n    }\n    return false;\n}"
      },
      {
        "name": "constructPricingStructureV2",
        "kind": "variable",
        "signature": "constructPricingStructureV2 = (\n    product_data: {\n        product_href: string;\n        variant: number;\n        subscriptionType: string;\n        discountable: boolean;\n    },\n    priceData: ProductVariantRecord[],\n    shouldDiscount: boolean,\n) => {\n    // Construct { full_price, subscribesave_price, coupon_price, total_price }\n    const subscriptionType = product_data['subscriptionType'];\n    const productName = product_data['product_href'];\n\n    const variantRecord = priceData.find(\n        (record) => record.variant_index == product_data.variant,\n    );\n\n    const product = variantRecord?.price_data;\n\n    // if (productName === PRODUCT_HREF.CGM_SENSOR) {\n    //     if (subscriptionType === 'monthly') {\n    //         const total_price = 119 - (shouldDiscount ? 20 : 0);\n    //         return {\n    //             item_price: '119.00',\n    //             subscribe_save_price: '43.00',\n    //             total_price: total_price.toFixed(2),\n    //             ...(shouldDiscount && {\n    //                 coupon_price: parseFloat(\n    //                     product.discount_price.discount_amount\n    //                 ).toFixed(2),\n    //             }),\n    //             discountApplied: true,\n    //         };\n    //     }\n    // }\n\n    let res: any = {\n        discountApplied: false,\n    };\n\n    var full_price = parseFloat(product.product_price);\n\n    res['item_price'] = full_price;\n\n    // Determine if should apply Subscribe + Save (aka only monthly products)\n    if (subscriptionType !== 'quarterly' && subscriptionType !== 'one_time' && subscriptionType !== 'annually') {\n        // Apply Subscribe & Save\n\n        const oneTimeRecord = priceData.find(\n            (record) => record.cadence === 'one_time',\n        );\n\n        if (oneTimeRecord) {\n            const one_time_price = parseFloat(\n                oneTimeRecord.price_data.product_price,\n            );\n\n            const subscribe_save_price = product.product_price - one_time_price;\n            res['subscribe_save_price'] = Math.abs(subscribe_save_price);\n            res.discountApplied = true;\n        }\n    }\n\n    // Determine coupon savings\n    // Dont apply coupon savings if it's one-time\n    if (\n        (subscriptionType !== 'one_time' && shouldDiscount) ||\n        isWeightlossProduct(product_data.product_href)\n    ) {\n        const coupon_price = parseFloat(product.discount_price.discount_amount);\n        res['coupon_price'] = coupon_price;\n        res.discountApplied = true;\n    }\n\n    const total =\n        full_price -\n        (res['subscribe_save_price'] ?? 0) -\n        (((shouldDiscount || isWeightlossProduct(product_data.product_href)) &&\n            res['coupon_price']) ??\n            0);\n    res['total_price'] = total;\n\n    return Object.keys(res).reduce((acc: any, key: any) => {\n        // Convert each value to a string with two decimal places and then to a number\n        if (key === 'discountApplied') {\n            return acc;\n        }\n        acc[key] = res[key].toFixed(2);\n        return acc;\n    }, {});\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/pricing.ts",
      "bioverse-client/app/components/patient-portal/order-history/orderItem.tsx",
      "bioverse-client/app/components/intake-v3/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component-ab.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/questionnaire-completion-display/questionnaire-completion-display.tsx",
      "bioverse-client/app/components/intake-v2/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/components/wl-checkout-component-fulltest.tsx",
      "bioverse-client/app/components/intake-v2/checkout/checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/pages/product-overview.tsx",
      "bioverse-client/app/components/intake-v3/pages/shipping-information-v3.tsx",
      "bioverse-client/app/components/intake-v2/pages/shipping-information.tsx",
      "bioverse-client/app/components/intake-v3/registration/intake-signup-form/intake-signup-form-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/question-id-pre-signup.tsx",
      "bioverse-client/app/components/intake-v3/pages/id-verification-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/pre-question-id-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/id-verification-noskip-v3.tsx",
      "bioverse-client/app/components/intake-v2/registration/intake-signup-form/intake-signup-form.tsx",
      "bioverse-client/app/components/intake-v2/pages/id-verification.tsx",
      "bioverse-client/app/utils/database/controller/orders/orders-api.ts",
      "bioverse-client/app/utils/classes/Dashboard.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/StripeInvoicePaidJobHandler.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/utils/intake-helpers.ts",
      "bioverse-client/app/components/patient-portal/subscriptions/components/CancelSubscription/CancelSubscriptionConfirm.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-in-good-hands.tsx",
      "bioverse-client/app/api/easypost/route.tsx",
      "bioverse-client/app/api/stripe/webhook/invoice-paid/route.ts",
      "bioverse-client/app/(patient-portal)/portal/subscriptions/cancel-flow/[subscription_id]/confirm/page.tsx",
      "bioverse-client/app/utils/database/controller/questionnaires/questionnaire.ts",
      "bioverse-client/app/utils/database/controller/renewal_orders/renewal_orders.ts",
      "bioverse-client/app/utils/database/controller/orders/create-manual-order.ts",
      "bioverse-client/app/utils/actions/check-up/check-up-actions.ts",
      "bioverse-client/app/utils/functions/provider-portal/intakes/provider-intake-utils.ts",
      "bioverse-client/app/utils/functions/jobs/JobsFactory.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/ManualOrderCreationDialog.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/patient-information/approval-buttons/review-approval-buttons.tsx",
      "bioverse-client/app/components/intake-v3/questions/question-types/custom-questions/custom-types/bmi-v3.tsx",
      "bioverse-client/app/components/intake-v2/questions/question-types/custom-questions/custom-types/bmi.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/provider-portal/intakes/provider-intake-utils.ts",
    "exports": [
      {
        "name": "showButtonController",
        "kind": "function",
        "signature": "export function showButtonController(\n    order_status: string,\n    status_tag: string | undefined,\n    order_cadence: SubscriptionCadency,\n    employeeAuthorization: BV_AUTH_TYPE | null,\n    order_data: DBOrderData,\n    orderType: OrderType\n) {\n    // console.log('Show button controller all props: ', order_status, status_tag);\n\n    if (\n        !status_tag ||\n        employeeAuthorization === BV_AUTH_TYPE.REGISTERED_NURSE\n    ) {\n        return IntakeButtonTypes.None;\n    }\n\n    if (status_tag === StatusTag.Resolved || status_tag === StatusTag.None) {\n        return IntakeButtonTypes.None;\n    }\n\n    let cadence = order_cadence;\n\n    //If it's a new order and it's not the typical 'review' status, we may need to show the approval button anyway\n    if (orderType === OrderType.Order) {\n        if (\n            status_tag === StatusTag.ProviderMessage ||\n            status_tag === StatusTag.Overdue ||\n            status_tag === StatusTag.Engineer\n        ) {\n            return IntakeButtonTypes.ApprovalButtons;\n        }\n    }\n\n    if (cadence === SubscriptionCadency.Quarterly) {\n        if (\n            order_status === OrderStatus.UnapprovedCardDown ||\n            order_status === OrderStatus.PaymentCompleted\n        ) {\n            if (\n                status_tag === StatusTag.Review ||\n                status_tag === StatusTag.LeadProvider ||\n                status_tag === StatusTag.Overdue ||\n                status_tag === StatusTag.Engineer\n            ) {\n                console.log(\n                    '[Quarterly] Approval Buttons because status is UnapprovedCardDown or PaymentCompleted '\n                );\n                return IntakeButtonTypes.ApprovalButtons;\n            }\n            console.log(\n                '[Quarterly] None because status is UnapprovedCardDown or PaymentCompleted and status tag is not Review, LeadProvider, Overdue, or Engineer'\n            );\n            return IntakeButtonTypes.None;\n        }\n\n        if (\n            status_tag === StatusTag.FinalReview ||\n            status_tag === StatusTag.Review ||\n            status_tag === StatusTag.LeadProvider ||\n            status_tag === StatusTag.Overdue ||\n            status_tag === StatusTag.Engineer\n        ) {\n            console.log(\n                '[Quarterly] Approval Buttons because status was not UnapprovedCardDown or PaymentCompleted and status tag is FinalReview, Review, LeadProvider, Overdue, or Engineer'\n            );\n            return IntakeButtonTypes.ApprovalButtons;\n        }\n\n        if (\n            status_tag === StatusTag.ReviewNoPrescribe ||\n            status_tag === StatusTag.OverdueNoPrescribe ||\n            status_tag === StatusTag.ProviderMessage\n        ) {\n            if (\n                (order_data.product_href as PRODUCT_HREF) ===\n                PRODUCT_HREF.METFORMIN\n            ) {\n                console.log(\n                    '[Quarterly] Approval Buttons because product href is METFORMIN, though no approval action is needed'\n                );\n                return IntakeButtonTypes.ApprovalButtons;\n            }\n\n            if (\n                (order_data.product_href as PRODUCT_HREF) ===\n                    PRODUCT_HREF.TIRZEPATIDE &&\n                [16, 17, 18, 19, 20, 21, 22].includes(order_data.variant_index)\n            ) {\n                console.log(' none 2 '); //DELETE THIS WHOLE IF STATEMENT ONCE ADJUST DOSING IS READY FOR THESE VARIANTS\n                return IntakeButtonTypes.None;\n            } else {\n                return IntakeButtonTypes.AdjustDosing;\n            }\n        }\n\n        return IntakeButtonTypes.None;\n\n        //end of quarterly order cadence handling\n    } else if (cadence === SubscriptionCadency.Monthly) {\n        if (\n            status_tag === StatusTag.FinalReview ||\n            status_tag === StatusTag.Review ||\n            status_tag === StatusTag.Overdue ||\n            status_tag === StatusTag.Engineer\n        ) {\n            console.log(\n                '[Monthly] Approval Buttons because status tag is FinalReview, Review, Overdue, or Engineer'\n            );\n            return IntakeButtonTypes.ApprovalButtons;\n        }\n\n        if (\n            order_status === OrderStatus.UnapprovedCardDown ||\n            order_status ===\n                RenewalOrderStatus.CheckupComplete_Unprescribed_Paid ||\n            order_status ===\n                RenewalOrderStatus.CheckupComplete_Unprescribed_Unpaid\n        ) {\n            console.log(\n                '[Monthly] Approval Buttons because status is UnapprovedCardDown, CheckupComplete_Unprescribed_Paid, or CheckupComplete_Unprescribed_Unpaid'\n            );\n            return IntakeButtonTypes.ApprovalButtons;\n        }\n    } else if (\n        (cadence === SubscriptionCadency.Biannually ||\n            cadence === SubscriptionCadency.Annually) &&\n        isGLP1Product(order_data.product_href)\n    ) {\n        if (\n            order_status === OrderStatus.UnapprovedCardDown ||\n            order_status === OrderStatus.PaymentCompleted\n        ) {\n            if (\n                status_tag === StatusTag.Review ||\n                status_tag === StatusTag.LeadProvider ||\n                status_tag === StatusTag.Engineer\n            ) {\n                console.log('Approval buttons 6 ');\n                return IntakeButtonTypes.ApprovalButtons;\n            }\n            return IntakeButtonTypes.None;\n        }\n\n        if (\n            status_tag === StatusTag.FinalReview ||\n            status_tag === StatusTag.Review ||\n            status_tag === StatusTag.LeadProvider\n        ) {\n            console.log('Approval buttons 7 ');\n            return IntakeButtonTypes.ApprovalButtons;\n        }\n\n        if (\n            status_tag === StatusTag.ReviewNoPrescribe ||\n            status_tag === StatusTag.OverdueNoPrescribe ||\n            status_tag === StatusTag.ProviderMessage\n        ) {\n            return IntakeButtonTypes.AdjustDosing;\n        }\n\n        return IntakeButtonTypes.None;\n    } else if (cadence === SubscriptionCadency.Biannually) {\n        if (\n            order_status === OrderStatus.UnapprovedCardDown ||\n            order_status === OrderStatus.PaymentCompleted\n        ) {\n            if (\n                status_tag === StatusTag.Review ||\n                status_tag === StatusTag.LeadProvider ||\n                status_tag === StatusTag.Overdue ||\n                status_tag === StatusTag.Engineer\n            ) {\n                console.log(\n                    '[Biannually] Approval Buttons because status tag is Review, LeadProvider, Overdue, or Engineer'\n                );\n                return IntakeButtonTypes.ApprovalButtons;\n            }\n            return IntakeButtonTypes.None;\n        }\n\n        if (\n            status_tag === StatusTag.FinalReview ||\n            status_tag === StatusTag.Review ||\n            status_tag === StatusTag.LeadProvider ||\n            status_tag === StatusTag.Overdue ||\n            status_tag === StatusTag.Engineer\n        ) {\n            console.log(\n                '[Biannually] Approval Buttons because status tag is FinalReview, Review, LeadProvider, Overdue, or Engineer'\n            );\n            return IntakeButtonTypes.ApprovalButtons;\n        }\n\n        if (\n            status_tag === StatusTag.ReviewNoPrescribe ||\n            status_tag === StatusTag.OverdueNoPrescribe ||\n            status_tag === StatusTag.ProviderMessage\n        ) {\n            if (\n                (order_data.product_href as PRODUCT_HREF) ===\n                PRODUCT_HREF.METFORMIN\n            ) {\n                console.log(\n                    '[Biannually] Approval Buttons because product href is METFORMIN, though no approval action is needed'\n                );\n                return IntakeButtonTypes.ApprovalButtons;\n            }\n\n            if (\n                (order_data.product_href as PRODUCT_HREF) ===\n                    PRODUCT_HREF.TIRZEPATIDE &&\n                [16, 17, 18, 19, 20, 21, 22].includes(order_data.variant_index)\n            ) {\n                return IntakeButtonTypes.None;\n            } else {\n                return IntakeButtonTypes.AdjustDosing;\n            }\n        }\n\n        return IntakeButtonTypes.None;\n    } //end of non-glp1 biannually order cadence handling\n\n    if (cadence === SubscriptionCadency.OneTime) {\n        console.log('[OneTime] Approval Buttons because cadence is OneTime');\n        return IntakeButtonTypes.ApprovalButtons;\n    }\n\n    return IntakeButtonTypes.None;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/provider-portal/intakes/provider-intake-utils.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/containers/response-column.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/patient-information/approval-buttons/review-approval-buttons.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/provider-portal/messages/admin-message-center.ts",
    "exports": [
      {
        "name": "getAccessLevel",
        "kind": "function",
        "signature": "export async function getAccessLevel(authLevel: number) {\n    switch (authLevel) {\n        case 0: // customer\n            return AccessLevel.Patient;\n        case 1: // provider\n            return AccessLevel.Provider;\n        case 2: // developer\n            return AccessLevel.Developer;\n        case 3: // admin\n            return AccessLevel.Admin;\n        case 4: // customer support\n            return AccessLevel.CustomerSupport;\n        default:\n            return AccessLevel.Denied;\n    }\n}"
      },
      {
        "name": "getAvailableUsers",
        "kind": "function",
        "signature": "export async function getAvailableUsers(\n    user_id: string,\n    accessLevel: AccessLevel,\n): Promise<UserMessage[]> {\n    const supabase = createSupabaseServerComponentClient();\n\n    let rpcMethod = '';\n    let params = {};\n    if (accessLevel === AccessLevel.Provider) {\n        rpcMethod = 'get_patients_for_provider';\n        params = { provider_id_: user_id };\n    } else if (\n        accessLevel === AccessLevel.Developer ||\n        accessLevel === AccessLevel.Admin ||\n        accessLevel === AccessLevel.CustomerSupport\n    ) {\n        rpcMethod = 'get_all_patients_and_providers';\n    } else {\n        console.error(\"This user shouldn't be here\");\n        return [];\n    }\n\n    const response = await supabase.rpc(rpcMethod, params);\n\n    if (response.error) {\n        console.error('Error getting available users', response.error);\n        return [];\n    }\n    return response.data;\n}"
      },
      {
        "name": "getUserThreads",
        "kind": "function",
        "signature": "export async function getUserThreads(\n    user_id: string,\n): Promise<GetUserThreadsResponse> {\n    const supabase = createSupabaseServerComponentClient();\n\n    const thread_ids = await getAllThreadsForUser(user_id, 0);\n\n    const threadMembers = await getThreadRecepientNames(user_id, thread_ids);\n\n    const { data: messageData, error } = await supabase.rpc(\n        'get_all_messages',\n        { lookup_user_id: user_id, _thread_ids: thread_ids },\n    );\n\n    if (error) {\n        console.log('get thread members error provider');\n        console.log(error, error.message);\n        return { messageData: [], threadMembers: [], success: false };\n    }\n    return { messageData, threadMembers, success: true };\n}"
      },
      {
        "name": "groupMessagesByThreadId",
        "kind": "function",
        "signature": "export async function groupMessagesByThreadId(\n    messages: Message[],\n): Promise<Record<number, Message[]>> {\n    const groupedMessages: Record<number, Message[]> = {};\n\n    // Group messages by thread_id\n    messages.forEach((message) => {\n        if (!groupedMessages[message.thread_id]) {\n            groupedMessages[message.thread_id] = [];\n        }\n        groupedMessages[message.thread_id].push(message);\n    });\n\n    // Sort messages in each thread by created_at\n    Object.keys(groupedMessages).forEach((threadId: any) => {\n        groupedMessages[threadId].sort(\n            (a: any, b: any) =>\n                new Date(a.created_at).getTime() -\n                new Date(b.created_at).getTime(),\n        );\n    });\n\n    return groupedMessages;\n}"
      },
      {
        "name": "getThreadRecepientNames",
        "kind": "function",
        "signature": "export async function getThreadRecepientNames(\n    user_id: string,\n    thread_ids: number[],\n): Promise<ThreadMember[]> {\n    const supabase = createSupabaseServerComponentClient();\n\n    const { data, error } = await supabase.rpc('get_thread_members', {\n        lookup_user_id: user_id,\n        _thread_ids: thread_ids,\n    });\n\n    if (error) {\n        console.log('get thread members error provider');\n        console.log(error, error.message);\n        return [];\n    }\n\n    return data;\n}"
      },
      {
        "name": "formatDate",
        "kind": "function",
        "signature": "export async function formatDate(isoDateString: string | Date) {\n    const date = new Date(isoDateString);\n    const monthNames = [\n        'Jan',\n        'Feb',\n        'Mar',\n        'Apr',\n        'May',\n        'Jun',\n        'Jul',\n        'Aug',\n        'Sep',\n        'Oct',\n        'Nov',\n        'Dec',\n    ];\n    const day = date.getDate();\n    const monthIndex = date.getMonth();\n    const year = date.getFullYear();\n    const hours = date.getHours();\n    const minutes = date.getMinutes();\n    const ampm = hours >= 12 ? 'PM' : 'AM';\n    const formattedHours = hours % 12 || 12; // the hour '0' should be '12'\n    const formattedMinutes = minutes < 10 ? '0' + minutes : minutes;\n\n    return `${monthNames[monthIndex]} ${day} at ${formattedHours}:${formattedMinutes}${ampm}`;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/provider-portal/messages/admin-message-center.ts",
      "bioverse-client/app/components/provider-portal/messages/components/UserDetails.tsx",
      "bioverse-client/app/utils/database/controller/orders/create-manual-order.ts",
      "bioverse-client/app/utils/functions/client-utils.ts",
      "bioverse-client/app/utils/functions/formatting.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/custom-prescription-script/components/CustomPrescriptionConfirmationDialog.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/info/info-content.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/info/info-edit-dialog.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/ManualOrderCreationDialog.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/all-patients-table-row.tsx",
      "bioverse-client/app/components/admin/announcements/announcement-history.tsx",
      "bioverse-client/app/components/provider-portal/history/provider-history.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/patient-information/internal-notes-accordion/status-tag-note-item.tsx",
      "bioverse-client/app/components/provider-portal/provider-patient-review/provider-review-UI/patient-information/internal-notes-accordion/internal-note-item.tsx",
      "bioverse-client/app/components/patient-portal/account-information/personal-information/account-information-display.tsx",
      "bioverse-client/app/components/patient-portal/dosage-selection-first-time/components/FirstTimeAlmostDone.tsx",
      "bioverse-client/app/components/intake-v3/data-collection/data-collection-wl-input-v4.tsx",
      "bioverse-client/app/components/intake-v3/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component-ab.tsx",
      "bioverse-client/app/components/intake-v3/checkout/wl-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/ed/ed-checkout/ed-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/new-checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/checkout-component.tsx",
      "bioverse-client/app/components/intake-v2/checkout/wl-checkout-component.tsx",
      "bioverse-client/_deprecated/track-hours/coordinator-time-tracker-content.tsx",
      "bioverse-client/_deprecated/track-hours/provider-time-tracker-content-deprecated.tsx",
      "bioverse-client/_deprecated/chat_old_6.10/testing.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/provider-portal/time-tracker/provider-time-tracker-functions.ts",
    "exports": [
      {
        "name": "endSessionAndSignOutUser",
        "kind": "function",
        "signature": "export async function endSessionAndSignOutUser(provider_id: string) {\n    await endSession(provider_id);\n    await signOutUser();\n}"
      },
      {
        "name": "getProviderAutomaticSessionLog",
        "kind": "function",
        "signature": "export async function getProviderAutomaticSessionLog(\n    provider_id: string,\n    start_time: number,\n    end_time: number\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase.rpc(\n        'get_provider_automatic_session_times_v2',\n        {\n            provider_id_: provider_id,\n            start_date: start_time,\n            end_date: end_time,\n        }\n    );\n\n    const filteredData = data?.filter((item: any) => item.session_time > 0.05); //only sessions that are more than 5 seconds long\n\n    if (error) {\n        console.log('Error fetching provider automatic session log', error);\n        return [];\n    }\n\n    return filteredData;\n}"
      },
      {
        "name": "getRegisteredNurseArray",
        "kind": "function",
        "signature": "export async function getRegisteredNurseArray() {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('providers')\n        .select('name, id, role')\n        .in('role', [BV_AUTH_TYPE.REGISTERED_NURSE]);\n\n    if (error) {\n        console.log(error);\n        return [];\n    }\n\n    const filteredData = data.filter(\n        (provider) => !DUMMY_PROVIDER_ARRAY_FILTER.includes(provider.id)\n    );\n\n    return filteredData as ProviderArrayItem[];\n}"
      },
      {
        "name": "getProviderArray",
        "kind": "function",
        "signature": "export async function getProviderArray() {\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('providers')\n        .select('name, id, role')\n        .in('role', [BV_AUTH_TYPE.LEAD_PROVIDER, BV_AUTH_TYPE.PROVIDER]);\n\n    if (error) {\n        console.log(error);\n        return [];\n    }\n\n    const filteredData = data.filter(\n        (provider) => !DUMMY_PROVIDER_ARRAY_FILTER.includes(provider.id)\n    );\n\n    return filteredData as ProviderArrayItem[];\n}"
      },
      {
        "name": "fetchProviderAutomaticSessionLogData",
        "kind": "function",
        "signature": "export async function fetchProviderAutomaticSessionLogData({\n    selectedProviderIds,\n    selectedDateSessionsHoursTab,\n    selectedTab,\n    array,\n    timeZone,\n}: FetchProviderAutomaticSessionLogParams) {\n    if (selectedTab !== 0) {\n        return null;\n    }\n\n    if (!selectedDateSessionsHoursTab) {\n        return null;\n    }\n\n    const date = dayjs(selectedDateSessionsHoursTab).tz(timeZone); //make sure any date created in a server function is aware of the client's timezone\n    const startOfDay = date.startOf('day');\n    const endOfDay = date.endOf('day');\n\n    // console.log('selectedDateSessionsHoursTab', selectedDateSessionsHoursTab);\n    // console.log('startOfDay', startOfDay);\n    // console.log('endOfDay', endOfDay);\n    // console.log('startOfDay value', startOfDay.valueOf());\n    // console.log('endOfDay value', endOfDay.valueOf());\n\n    if (selectedProviderIds.length > 0) {\n        const sessionLogs = await Promise.all(\n            selectedProviderIds.map(async (providerId) => {\n                const logs = await getProviderAutomaticSessionLog(\n                    providerId,\n                    startOfDay.valueOf(),\n                    endOfDay.valueOf()\n                );\n                return { [providerId]: logs };\n            })\n        );\n        const combinedLogs = Object.assign({}, ...sessionLogs);\n        const newRows = Object.entries(combinedLogs).flatMap(\n            ([providerId, sessions]) => {\n                if (!Array.isArray(sessions)) return [];\n                return sessions.map(\n                    (session: SessionLog, sessionIndex: number) => ({\n                        id: providerId + '_' + sessionIndex,\n                        employeeName:\n                            array.find((provider) => provider.id === providerId)\n                                ?.name || 'Unknown',\n                        startTime: new Date(\n                            session.start_session_timestamp\n                        ).toLocaleString('en-US', { timeZone }),\n                        endTime: new Date(\n                            session.end_session_timestamp\n                        ).toLocaleString('en-US', { timeZone }),\n                        sessionsDuration: calculateDuration(\n                            Number(session.start_session_timestamp),\n                            Number(session.end_session_timestamp)\n                        ),\n                        totalHoursDaily: calculateTotalHours(sessions),\n                    })\n                );\n            }\n        );\n        newRows.sort(\n            (a, b) =>\n                new Date(b.startTime).getTime() -\n                new Date(a.startTime).getTime()\n        );\n        return newRows;\n    }\n    return null;\n}"
      },
      {
        "name": "fetchProviderActivityAuditCountsData",
        "kind": "function",
        "signature": "export async function fetchProviderActivityAuditCountsData({\n    selectedProviderIds,\n    selectedStartDatePerformanceTab,\n    selectedEndDatePerformanceTab,\n    selectedTab,\n    array,\n    timeZone,\n}: FetchProviderActivityAuditCountsParams): Promise<Record<\n    string,\n    any\n> | null> {\n    if (selectedTab !== 1) {\n        return null;\n    }\n\n    if (!selectedStartDatePerformanceTab || !selectedEndDatePerformanceTab) {\n        return null;\n    }\n\n    const startDate = dayjs(selectedStartDatePerformanceTab).tz(timeZone);\n    const endDate = dayjs(selectedEndDatePerformanceTab).tz(timeZone);\n    const startOfDay = startDate.startOf('day');\n    const endOfDay = endDate.endOf('day');\n\n    if (selectedProviderIds.length > 0) {\n        const actionCounts = await Promise.all(\n            selectedProviderIds.map(async (providerId) => {\n                const logs = await getProviderActivityAuditCountsBetweenDates(\n                    providerId,\n                    startOfDay.valueOf(),\n                    endOfDay.valueOf()\n                );\n                return { [providerId]: logs };\n            })\n        );\n        const sessions = await Promise.all(\n            selectedProviderIds.map(async (providerId) => {\n                const sessions = await getProviderAutomaticSessionLog(\n                    providerId,\n                    startOfDay.valueOf(),\n                    endOfDay.valueOf()\n                );\n                return { [providerId]: sessions };\n            })\n        );\n        const combinedLogs: Record<string, any> = Object.assign(\n            {},\n            ...actionCounts\n        );\n        let newRows = Object.entries(combinedLogs).map(\n            ([providerId, actionCounts]) => ({\n                id: providerId + '_',\n                employeeName:\n                    array.find((provider) => provider.id === providerId)\n                        ?.name || 'Unknown',\n                hoursLogged: 'n/a',\n                messagesAnswered: actionCounts?.providerMessages || 0,\n                intakesCompleted:\n                    (actionCounts?.providerIntakesHandled || 0) +\n                    (actionCounts?.providerRenewalsHandled || 0) +\n                    (actionCounts?.providerCheckinsHandled || 0),\n                fwdPercentage: 'n/a',\n            })\n        );\n\n        newRows.forEach((row, index) => {\n            const providerId = selectedProviderIds[index];\n            const providerSessions = sessions.find(\n                (s) => Object.keys(s)[0] === providerId\n            )?.[providerId];\n            row.hoursLogged = calculateTotalHours(providerSessions);\n        });\n\n        return newRows;\n    }\n    return null;\n}"
      },
      {
        "name": "fetchProviderWeeklySummaryRowsData",
        "kind": "function",
        "signature": "export async function fetchProviderWeeklySummaryRowsData({\n    selectedProviderIds,\n    selectedStartDateWeeklySummaryTab,\n    selectedEndDateWeeklySummaryTab,\n    selectedTab,\n    array,\n    timeZone,\n}: FetchProviderWeeklySummaryRowsParams) {\n    if (selectedTab !== 2) {\n        return null;\n    }\n\n    if (\n        !selectedStartDateWeeklySummaryTab ||\n        !selectedEndDateWeeklySummaryTab\n    ) {\n        return null;\n    }\n\n    const startDate = dayjs(selectedStartDateWeeklySummaryTab).tz(timeZone);\n    const endDate = dayjs(selectedEndDateWeeklySummaryTab).tz(timeZone);\n    const startOfDay = startDate.startOf('day');\n    const endOfDay = endDate.endOf('day');\n\n    if (selectedProviderIds.length > 0) {\n        const sessionLogs = await Promise.all(\n            selectedProviderIds.map(async (providerId) => {\n                const logs = await getProviderAutomaticSessionLog(\n                    providerId,\n                    startOfDay.valueOf(),\n                    endOfDay.valueOf()\n                );\n                return { [providerId]: logs };\n            })\n        );\n\n        const providerEarningsBreakdownArray = await Promise.all(\n            selectedProviderIds.map(async (providerId) => {\n                const logs =\n                    await getProviderEstimatedPaymentBetweenDatesV2Verbose(\n                        providerId,\n                        startOfDay.valueOf(),\n                        endOfDay.valueOf()\n                    );\n                return { [providerId]: logs };\n            })\n        );\n        // console.log(\"providerEarningsBreakdown inside weekly summary: \", providerEarningsBreakdownArray)\n\n        const combinedLogs = Object.assign({}, ...sessionLogs);\n        const newRows = Object.entries(combinedLogs)\n            .map(([providerId, sessions]) => {\n                if (!Array.isArray(sessions)) return null;\n                const {\n                    totalHoursMonday,\n                    totalHoursTuesday,\n                    totalHoursWednesday,\n                    totalHoursThursday,\n                    totalHoursFriday,\n                    totalHoursSaturday,\n                    totalHoursSunday,\n                } = calculateTotalHoursMondayThroughFriday(sessions, timeZone);\n                return {\n                    id: providerId,\n                    employeeName:\n                        array.find((provider) => provider.id === providerId)\n                            ?.name || 'Unknown',\n                    hoursM: totalHoursMonday,\n                    hoursT: totalHoursTuesday,\n                    hoursW: totalHoursWednesday,\n                    hoursTh: totalHoursThursday,\n                    hoursF: totalHoursFriday,\n                    hoursSa: totalHoursSaturday,\n                    hoursSu: totalHoursSunday,\n                    weeklyTotal: calculateTotalHours(sessions),\n                    weeklyEarnings: 'n/a',\n                };\n            })\n            .filter((row): row is WeeklySummaryRow => row !== null);\n\n        //loop through the providerEarningsBreakdown and add the totalPayinPeriod to that provider's .weeklyEarnings property\n        newRows.forEach((row, index) => {\n            const providerId = selectedProviderIds[index]; //there will always be as many rows as there are selected providers (other than the totals row)\n            const providerEarningsBreakdown = providerEarningsBreakdownArray.find(\n                (s: any) => Object.keys(s)[0] === providerId\n            )?.[providerId];\n            row.weeklyEarnings = `$${providerEarningsBreakdown?.totalPayInPeriod.toFixed(2) || 'n/a'}`;\n        });\n\n\n        const totalHoursMonday = newRows.reduce((acc, row) => acc + parseTime(row.hoursM), 0);\n        const totalHoursTuesday = newRows.reduce((acc, row) => acc + parseTime(row.hoursT), 0);\n        const totalHoursWednesday = newRows.reduce((acc, row) => acc + parseTime(row.hoursW), 0);\n        const totalHoursThursday = newRows.reduce((acc, row) => acc + parseTime(row.hoursTh), 0);\n        const totalHoursFriday = newRows.reduce((acc, row) => acc + parseTime(row.hoursF), 0);\n        const totalHoursSaturday = newRows.reduce((acc, row) => acc + parseTime(row.hoursSa), 0);\n        const totalHoursSunday = newRows.reduce((acc, row) => acc + parseTime(row.hoursSu), 0);\n        \n        const totalsRow = {\n            id: 'totals',\n            employeeName: 'Totals',\n            hoursM: formatMinutesToHM(totalHoursMonday),\n            hoursT: formatMinutesToHM(totalHoursTuesday),\n            hoursW: formatMinutesToHM(totalHoursWednesday),\n            hoursTh: formatMinutesToHM(totalHoursThursday),\n            hoursF: formatMinutesToHM(totalHoursFriday),\n            hoursSa: formatMinutesToHM(totalHoursSaturday),\n            hoursSu: formatMinutesToHM(totalHoursSunday),\n            weeklyTotal: formatMinutesToHM(totalHoursMonday + totalHoursTuesday + totalHoursWednesday + totalHoursThursday + totalHoursFriday + totalHoursSaturday + totalHoursSunday),\n            weeklyEarnings: 'n/a'\n          }\n        newRows.push(totalsRow);\n        return newRows;\n    }\n    return null;\n}"
      },
      {
        "name": "fetchProviderEarningsBreakdownRowsData",
        "kind": "function",
        "signature": "export async function fetchProviderEarningsBreakdownRowsData({\n    selectedProviderIds,\n    selectedStartDateEarningsBreakdownTab,\n    selectedEndDateEarningsBreakdownTab,\n    selectedTab,\n    array,\n    timeZone,\n}: FetchProviderEarningsBreakdownRowsParams) {\n    if (selectedTab !== 3) {\n        return null;\n    }\n\n    if (\n        !selectedStartDateEarningsBreakdownTab ||\n        !selectedEndDateEarningsBreakdownTab\n    ) {\n        return null;\n    }\n\n    const startDate = dayjs(selectedStartDateEarningsBreakdownTab).tz(timeZone);\n    const endDate = dayjs(selectedEndDateEarningsBreakdownTab).tz(timeZone);\n    const startOfDay = startDate.startOf('day');\n    const endOfDay = endDate.endOf('day');\n\n    if (selectedProviderIds.length > 0) {\n        const providerEarningsBreakdown = await Promise.all(\n            selectedProviderIds.map(async (providerId) => {\n                const logs =\n                    await getProviderEstimatedPaymentBetweenDatesV2Verbose(\n                        providerId,\n                        startOfDay.valueOf(),\n                        endOfDay.valueOf()\n                    );\n                return { [providerId]: logs };\n            })\n        );\n        const combinedLogs: Record<string, any> = Object.assign(\n            {},\n            ...providerEarningsBreakdown\n        );\n        const newRows = Object.entries(combinedLogs).map(\n            ([providerId, providerEarningsBreakdown]) => ({\n                id: providerId + '_',\n                employeeName:\n                    array.find((provider) => provider.id === providerId)\n                        ?.name || 'Unknown',\n                newIntakes:\n                    '$' +\n                    (providerEarningsBreakdown?.intakesHandled.toFixed(2) || 0),\n                renewals:\n                    '$' +\n                    (providerEarningsBreakdown?.renewalsHandled.toFixed(2) ||\n                        0),\n                checkins:\n                    '$' +\n                    (providerEarningsBreakdown?.checkinsHandled.toFixed(2) ||\n                        0),\n                providerMessages:\n                    '$' +\n                    (providerEarningsBreakdown?.messagesAnswered.toFixed(2) ||\n                        0),\n                totalPayForPeriod:\n                    '$' +\n                    (providerEarningsBreakdown?.totalPayInPeriod.toFixed(2) ||\n                        0),\n                details: 'n/a',\n            })\n        );\n        return newRows;\n    }\n    return null;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/provider-portal/time-tracker/provider-time-tracker-functions.ts",
      "bioverse-client/app/components/registered-nurse-portal/nav-bar/registered-nurse-nav-bar.tsx",
      "bioverse-client/app/hooks/useSessionTimeout.ts",
      "bioverse-client/app/components/provider-portal/tasks/task-action-page/utils/task-action-data-fetch.ts",
      "bioverse-client/_deprecated/track-hours/provider-time-tracker-content-deprecated.tsx",
      "bioverse-client/app/(employee)/(registered-nurse-portal)/registered-nurse/track-hours/page.tsx",
      "bioverse-client/app/(employee)/(provider-portal)/provider/track-hours/page.tsx",
      "bioverse-client/app/components/provider-portal/track-hours-v2/provider-time-tracker-content.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/provider-portal/time-tracker/provider-time-tracker-types.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/functions/renewal-orders/renewal-orders.ts",
    "exports": [
      {
        "name": "getOrderStatusDetails",
        "kind": "function",
        "signature": "export function getOrderStatusDetails(orderStatus: string): {\n    isCheckupComplete: boolean;\n    isProviderApproved: boolean;\n    isPaid: boolean;\n    isPrescribed: boolean;\n    isFailedPayment: boolean;\n} {\n    const details: {\n        isCheckupComplete: boolean;\n        isProviderApproved: boolean;\n        isPaid: boolean;\n        isPrescribed: boolean;\n        isFailedPayment: boolean;\n    } = {\n        isCheckupComplete: false,\n        isProviderApproved: false,\n        isPaid: false,\n        isPrescribed: false,\n        isFailedPayment: false,\n    };\n\n    // Check if the order status indicates a checkup completion\n    if (\n        orderStatus.includes('CheckupComplete') ||\n        orderStatus.includes('CheckupWaived')\n    ) {\n        details.isCheckupComplete = true;\n    } else {\n        details.isCheckupComplete = false;\n    }\n\n    // Check if the order status indicates provider approval\n    if (orderStatus.includes('ProviderApproved')) {\n        details.isProviderApproved = true;\n    } else {\n        details.isProviderApproved = false;\n    }\n\n    // Check if the order status indicates payment status\n    if (orderStatus.includes('Paid')) {\n        details.isPaid = true;\n    } else {\n        details.isPaid = false;\n    }\n\n    if (orderStatus.includes('Unpaid-1') || orderStatus.includes('Unpaid-2')) {\n        details.isPaid = false;\n        details.isFailedPayment = true;\n    } else {\n        details.isFailedPayment = false;\n    }\n\n    if (orderStatus.includes('Prescribed')) {\n        details.isPrescribed = true;\n    } else {\n        details.isPrescribed = false;\n    }\n\n    return details;\n}"
      },
      {
        "name": "getFinalReviewStartsDate",
        "kind": "function",
        "signature": "export function getFinalReviewStartsDate() {\n    return new Date(Date.now() + 61 * 24 * 60 * 60 * 1000);\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(testing_and_development)/olivier-dev/utils.ts",
      "bioverse-client/app/utils/database/controller/profiles/profiles.ts",
      "bioverse-client/app/utils/actions/check-up/check-up-actions.ts",
      "bioverse-client/app/utils/functions/renewal-orders/renewal-orders.ts",
      "bioverse-client/app/utils/functions/job-scheduler/jobs/StripeInvoicePaidJobHandler.ts",
      "bioverse-client/app/components/coordinator-portal/orderID-TaskView/confirm-prescription-dialog/confirm-prescription-dialog.tsx",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/CoordinatorConfirmDosage.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/approve-script-dialog.tsx",
      "bioverse-client/app/components/patient-portal/check-up-requested/refill-preference/refill-preference-screen-v2.tsx",
      "bioverse-client/app/components/patient-portal/check-up-requested/refill-preference/refill-preference-screen.tsx",
      "bioverse-client/app/api/customerio/webhook/route.ts",
      "bioverse-client/app/api/stripe/webhook/invoice-paid/route.ts",
      "bioverse-client/app/services/pharmacy-integration/revive/revive-send-script-api.ts",
      "bioverse-client/app/services/pharmacy-integration/empower/provider-script-feedback.ts",
      "bioverse-client/app/services/pharmacy-integration/hallandale/hallandale-script-api.ts",
      "bioverse-client/app/services/pharmacy-integration/boothwyn/boothwyn-script-api.ts",
      "bioverse-client/app/utils/database/controller/renewal_orders/renewal_orders.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/rudderstack/rudderstack-utils.ts",
    "exports": [
      {
        "name": "sendRudderstackEvent",
        "kind": "function",
        "signature": "export async function sendRudderstackEvent(\n    eventType: RudderstackEventType,\n    payload: any\n) {\n    const apiUrl = await getURL();\n    // console.log('sending rudderstack event...', eventType, payload);\n    const res = await fetch(`${apiUrl}/api/rudderstack`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            Authorization: `Bearer ${process.env.SUPABASE_JOBS_API_KEY}`,\n        },\n        body: JSON.stringify({ eventType, payload }),\n    });\n    return res.status;\n}"
      },
      {
        "name": "trackRudderstackEvent",
        "kind": "function",
        "signature": "export async function trackRudderstackEvent(\n    userId: string,\n    eventType: RudderstackEvent,\n    properties: any = {}\n) {\n    const payload = {\n        userId,\n        event: eventType,\n        anonymousId: properties.anonymousId,\n        properties:\n            typeof properties === 'string'\n                ? await JSON.parse(properties)\n                : properties,\n    };\n\n    const res = await sendRudderstackEvent(RudderstackEventType.Track, payload);\n\n    switch (eventType) {\n        case ORDER_RECEIVED:\n            await sendRudderstackEvent(RudderstackEventType.Track, {\n                ...payload,\n                event: 'ncon-bioverse',\n            });\n            break;\n        case ACCOUNT_CREATED:\n            await sendRudderstackEvent(RudderstackEventType.Track, {\n                ...payload,\n                event: 'nsig-bioverse',\n            });\n            break;\n        case PROFILE_INTAKE_COMPLETED:\n            await sendRudderstackEvent(RudderstackEventType.Track, {\n                ...payload,\n                event: 'nsig-bioverse',\n            });\n            await sendRudderstackEvent(RudderstackEventType.Track, {\n                ...payload,\n                event: ACCOUNT_CREATED,\n            });\n            break;\n    }\n    return res;\n}"
      },
      {
        "name": "identifyRudderstackEvent",
        "kind": "function",
        "signature": "export async function identifyRudderstackEvent(userId: string, traits: any) {\n    const payload = {\n        userId,\n        anonymousId: traits.anonymousId,\n        traits: typeof traits === 'string' ? await JSON.parse(traits) : traits,\n    };\n\n    const res = await sendRudderstackEvent(\n        RudderstackEventType.Identify,\n        payload\n    );\n    console.log('identify?', res);\n    return res;\n}"
      },
      {
        "name": "aliasRudderstackEvent",
        "kind": "function",
        "signature": "export async function aliasRudderstackEvent(\n    newUserId: string,\n    anonymousId: string\n) {\n    const payload = {\n        userId: newUserId,\n        previousId: anonymousId,\n    };\n\n    const res = await sendRudderstackEvent(RudderstackEventType.Alias, payload);\n    return res;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/rudderstack/rudderstack-utils.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/decline-dialog.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/intake-response-column/quarterly-final-review-dialog.tsx",
      "bioverse-client/app/components/intake-v3/registration/intake-signup-form/intake-signup-form-v3.tsx",
      "bioverse-client/app/components/intake-v3/data-collection/data-collection-wl-input-v4.tsx",
      "bioverse-client/app/components/intake-v3/account/data-collection/data-collection-new.tsx",
      "bioverse-client/app/components/intake-v3/pages/question-id-pre-signup.tsx",
      "bioverse-client/app/components/intake-v3/pages/pre-id-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/shipping-information-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-reviews-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-intro-3.tsx",
      "bioverse-client/app/components/intake-v3/pages/pre-id-v3-ap.tsx",
      "bioverse-client/app/components/intake-v3/pages/question-id-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/wl-intro-question-3-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/id-verification-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/pre-question-id-v3.tsx",
      "bioverse-client/app/components/intake-v3/pages/id-verification-noskip-v3.tsx",
      "bioverse-client/app/components/intake-v2/registration/intake-signup-form/intake-signup-form.tsx",
      "bioverse-client/app/components/intake-v2/ed/ed-pre-id/ed-pre-id.tsx",
      "bioverse-client/app/components/intake-v2/account/data-collection/data-collection-wl.tsx",
      "bioverse-client/app/components/intake-v2/account/data-collection/data-collection.tsx",
      "bioverse-client/app/components/intake-v2/account/data-collection/data-collection-new.tsx",
      "bioverse-client/app/components/intake-v2/account/data-collection/wl-data-collection.tsx",
      "bioverse-client/app/components/intake-v2/pages/question-id.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-in-good-hands.tsx",
      "bioverse-client/app/components/intake-v2/pages/id-verification.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-intro-3.tsx",
      "bioverse-client/app/components/intake-v2/pages/pre-id.tsx",
      "bioverse-client/app/components/intake-v2/pages/wl-up-next-preview.tsx",
      "bioverse-client/app/components/intake-v2/pages/shipping-information.tsx",
      "bioverse-client/app/components/intake-v2/pages/up-next-3-health.tsx",
      "bioverse-client/app/components/intake-v2/pages/pre-id-b.tsx",
      "bioverse-client/app/services/customerio/customerioApiFactory.ts",
      "bioverse-client/app/auth/callback/route.ts",
      "bioverse-client/app/components/intake-v3/wl-graph/wl-login-verification-screen.tsx",
      "bioverse-client/app/components/intake-v3/wl-graph/wl-registration-pre-graph-dialog.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/split-shipment-glp1/split-shipment-glp1-controller.ts",
    "exports": [
      {
        "name": "checkIfOrderIsSplitShipmentVariant",
        "kind": "function",
        "signature": "export async function checkIfOrderIsSplitShipmentVariant(\n    new_variant_index: number,\n    orderId: string\n): Promise<{\n    isSplitShipmentVariant: boolean;\n    shipmentNumber: 'first' | 'second';\n}> {\n    let isSplitShipmentVariant: boolean = false;\n    let shipmentNumber: 'first' | 'second' = 'first';\n\n    const { data, type } = await fetchOrderData(orderId);\n\n    const product_href = data.product_href;\n\n    if (product_href !== PRODUCT_HREF.SEMAGLUTIDE && product_href !== PRODUCT_HREF.TIRZEPATIDE) {\n        return {\n            isSplitShipmentVariant: false,\n            shipmentNumber: 'first',\n        };\n    }\n\n    isSplitShipmentVariant =\n        SplitShipmentGLP1VariantIndexMap[product_href].includes(new_variant_index);\n    const elibibleVariants =\n        SPLIT_SHIPMENT_GLP1_VARIANT_MAP[product_href][new_variant_index];\n\n    if (!elibibleVariants) {\n        return {\n            isSplitShipmentVariant: false,\n            shipmentNumber: 'first',\n        };\n    }\n\n    if (elibibleVariants.firstShipmentVariant === new_variant_index) {\n        shipmentNumber = 'first';\n    } else {\n        shipmentNumber = 'second';\n    }\n\n    console.log('SPLIT SHIPMENT CHECK RESULT SHIP NUM: ', shipmentNumber);\n\n    return {\n        isSplitShipmentVariant: isSplitShipmentVariant,\n        shipmentNumber: shipmentNumber,\n    };\n}"
      },
      {
        "name": "createSplitShipmentGLP1Record",
        "kind": "function",
        "signature": "export async function createSplitShipmentGLP1Record(orderId: string, scriptJSON: any) {\n    const { data, type } = await fetchOrderData(orderId);\n\n    const subscriptionId = data.subscription_id;\n\n    /**\n     * Start with the fact that the script was sent for a specific order/renewal order id\n     */\n    //Fetch the subscription data with subscription ID\n    const stripe_subscription_id =\n        await getStripeSubscriptionIdFromSubscription(subscriptionId);\n\n    if (!stripe_subscription_id) {\n        throw new Error('No Stripe Subscription found for ID');\n    }\n\n    //Use subscription data to get the stripe subcsription data and then fetch the next renewal date epoch\n    const stripeSubscription = await getStripeSubscription(\n        stripe_subscription_id\n    );\n\n    const nextRenewalEpoch = stripeSubscription.current_period_end;\n\n    const currentTimeEpoch = Math.floor(Date.now() / 1000);\n\n    //take the epoch time of that and the epoch time of current and then take half the difference and add it to the current\n    const timeDifference = nextRenewalEpoch - currentTimeEpoch;\n    const halfTimeDifference = Math.floor(timeDifference / 2);\n\n    // Then take the current and add the 1/2-difference and get the scheduled release time\n    const scheduledReleaseEpoch = currentTimeEpoch + halfTimeDifference;\n\n    // turn the subscription renewal time & the 1/2-difference and then turn them into timestamptz for the database to store.\n    const scheduledReleaseTime = new Date(\n        scheduledReleaseEpoch * 1000\n    ).toISOString();\n    const subscriptionRenewalTime = new Date(\n        nextRenewalEpoch * 1000\n    ).toISOString();\n\n    // These timestamps can now be stored in Supabase\n    const timestampsForDatabase = {\n        scheduled_release_time: scheduledReleaseTime,\n        subscription_renewal_time: subscriptionRenewalTime,\n    };\n\n    const supabase = createSupabaseServiceClient();\n\n    const splitShipmentOrderTrackingRecord = {\n        patient_id:\n            type === OrderType.Order ? data.customer_uid : data.customer_uuid,\n        product_href: data.product_href,\n        variant_index: data.variant_index,\n        scheduled_next_renewal_date:\n            timestampsForDatabase.subscription_renewal_time,\n        scheduled_second_supply_date:\n            timestampsForDatabase.scheduled_release_time,\n        base_order_id:\n            type === OrderType.Order ? data.id : data.original_order_id,\n        renewal_order_id:\n            type === OrderType.RenewalOrder ? data.renewal_order_id : null,\n        subscription_id: subscriptionId,\n        prescription_json_1: scriptJSON,\n    };\n\n    const { data: record_added, error } = await supabase\n        .from('split_shipment_order_tracking')\n        .insert(splitShipmentOrderTrackingRecord)\n        .select('id')\n        .single();\n\n    if (error) {\n        throw new Error('Could not add record to supabase: ' + error.message);\n    }\n\n    return record_added.id;\n}"
      },
      {
        "name": "updateSplitShipmentGLP1SecondShipmentSent",
        "kind": "function",
        "signature": "export async function updateSplitShipmentGLP1SecondShipmentSent(\n    splitShipmentRecordId: number,\n    scriptJSON: any\n) {\n    const supabase = createSupabaseServiceClient();\n\n    const { error } = await supabase\n        .from('split_shipment_order_tracking')\n        .update({\n            status: 'complete',\n            second_script_sent_time: new Date().toISOString(),\n            prescription_json_2: scriptJSON,\n        })\n        .eq('id', splitShipmentRecordId);\n\n    if (error) {\n        console.log(error);\n    }\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/split-shipment-glp1/split-shipment-glp1-controller.ts",
      "bioverse-client/app/api/revive/send-script/route.ts",
      "bioverse-client/app/api/supabase/split-shipment-glp1/route.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/split-shipment-glp1/split-shipment-variant-mappings.ts",
    "exports": [
      {
        "name": "SPLIT_SHIPMENT_GLP1_VARIANT_MAP",
        "kind": "variable",
        "signature": "SPLIT_SHIPMENT_GLP1_VARIANT_MAP: SplitShipmentGlp1Map = {\n    /**\n     * These mappings correspond to two variant indices, but they are double mapped\n     * to give the same results whether the first or second shipment variant index is used.\n     */\n    [PRODUCT_HREF.SEMAGLUTIDE]: {\n        //0.25mg x 6\n        64: {\n            firstShipmentVariant: 64,\n            secondShipmentVariant: 65,\n        },\n        65: {\n            firstShipmentVariant: 64,\n            secondShipmentVariant: 65,\n        },\n\n        //0.5mg x 6\n        66: {\n            firstShipmentVariant: 66,\n            secondShipmentVariant: 67,\n        },\n        67: {\n            firstShipmentVariant: 66,\n            secondShipmentVariant: 67,\n        },\n\n        //0.25mg, 0.5mg, 0.5mg, 1mg, 1mg, 1mg\n        68: {\n            firstShipmentVariant: 68,\n            secondShipmentVariant: 69,\n        },\n        69: {\n            firstShipmentVariant: 68,\n            secondShipmentVariant: 69,\n        },\n\n        //0.5mg, 0.5mg, 1.25mg, 1.25mg, 2.5mg, 2.5mg\n        70: {\n            firstShipmentVariant: 70,\n            secondShipmentVariant: 71,\n        },\n        71: {\n            firstShipmentVariant: 70,\n            secondShipmentVariant: 71,\n        },\n\n        //1.25mg, 1.25mg, 1.25mg, 2.5mg, 2.5mg, 2.5mg\n        72: {\n            firstShipmentVariant: 72,\n            secondShipmentVariant: 73,\n        },\n        73: {\n            firstShipmentVariant: 72,\n            secondShipmentVariant: 73,\n        },\n        74: {\n            firstShipmentVariant: 74,\n            secondShipmentVariant: 75,\n        },\n        75: {\n            firstShipmentVariant: 74,\n            secondShipmentVariant: 75,\n        },\n    },\n    [PRODUCT_HREF.TIRZEPATIDE]: {\n        //2.5mg x 6\n        57: {\n            firstShipmentVariant: 57,\n            secondShipmentVariant: 58,\n        },\n        58: {\n            firstShipmentVariant: 57,\n            secondShipmentVariant: 58,\n        },\n\n        //2.5mg, 2.5mg, 2.5mg, 5mg, 5mg, 5mg\n        59: {\n            firstShipmentVariant: 59,\n            secondShipmentVariant: 60,\n        },\n        60: {\n            firstShipmentVariant: 59,\n            secondShipmentVariant: 60,\n        }\n    },\n}"
      },
      {
        "name": "SplitShipmentGLP1VariantIndexMap",
        "kind": "variable",
        "signature": "SplitShipmentGLP1VariantIndexMap: SplitShipmentGlp1AllowedMap = {\n    [PRODUCT_HREF.SEMAGLUTIDE]: [64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75],\n    [PRODUCT_HREF.TIRZEPATIDE]: [57, 58, 59, 60],\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/split-shipment-glp1/split-shipment-variant-mappings.ts",
      "bioverse-client/app/utils/functions/split-shipment-glp1/split-shipment-glp1-controller.ts",
      "bioverse-client/app/api/supabase/split-shipment-glp1/route.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/split-shipment-glp1/split_shipment_record.d.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/functions/state-auth/utils.ts",
    "exports": [
      {
        "name": "getUserStateEligibilitySelectionScreen",
        "kind": "function",
        "signature": "export function getUserStateEligibilitySelectionScreen(\n    product_href: string,\n    frequency: string,\n    state: string | null,\n): boolean {\n    const INELIGIBLE_STATES: Record<string, Record<string, string[]>> = {\n        [PRODUCT_HREF.PEAK_CHEWS]: {\n            [ED_FREQUENCY.AS_NEEDED]: [\n                USStates.NorthCarolina,\n                USStates.California,\n            ],\n            [ED_FREQUENCY.DAILY]: [USStates.California],\n        },\n        [PRODUCT_HREF.VIAGRA]: {\n            [ED_FREQUENCY.AS_NEEDED]: [USStates.NorthCarolina],\n        },\n        [PRODUCT_HREF.TADALAFIL]: {\n            [ED_FREQUENCY.DAILY]: [USStates.NorthCarolina],\n        },\n        [PRODUCT_HREF.RUSH_CHEWS]: {\n            [ED_FREQUENCY.AS_NEEDED]: [USStates.California],\n            [ED_FREQUENCY.DAILY]: [USStates.California],\n        },\n        [PRODUCT_HREF.X_MELTS]: {\n            [ED_FREQUENCY.AS_NEEDED]: [USStates.California],\n            [ED_FREQUENCY.DAILY]: [USStates.California],\n        },\n        [PRODUCT_HREF.X_CHEWS]: {\n            [ED_FREQUENCY.AS_NEEDED]: [USStates.California],\n            [ED_FREQUENCY.DAILY]: [USStates.California],\n        },\n    };\n\n    if (!state) {\n        return true;\n    }\n\n    // Check if the product has ineligible states and if the state is in that list\n    if (\n        INELIGIBLE_STATES[product_href] &&\n        INELIGIBLE_STATES[product_href][frequency] &&\n        INELIGIBLE_STATES[product_href][frequency].includes(state)\n    ) {\n        return false; // User is in an ineligible state\n    }\n\n    return true; // User is eligible by default\n}"
      },
      {
        "name": "getUserStateEligibilityDosage",
        "kind": "function",
        "signature": "export function getUserStateEligibilityDosage(\n    product_href: string,\n    frequency: string,\n    dosage: string | undefined,\n    state: string | null,\n): boolean {\n    const INELIGIBLE_STATES: Record<\n        string,\n        Record<string, Record<string, string[]>>\n    > = {\n        [PRODUCT_HREF.TADALAFIL]: {\n            [ED_FREQUENCY.AS_NEEDED]: {\n                '5mg': [USStates.NorthCarolina],\n                '20mg': [USStates.NorthCarolina],\n            },\n        },\n        [PRODUCT_HREF.CIALIS]: {\n            [ED_FREQUENCY.AS_NEEDED]: {\n                '10 mg': [USStates.NorthCarolina],\n                '20 mg': [USStates.NorthCarolina],\n            },\n        },\n    };\n\n    if (!state || !dosage) {\n        return true; // Assume eligibility if state or dosage is missing\n    }\n\n    // Check if the product and dosage exist in INELIGIBLE_STATES before accessing them\n    if (\n        INELIGIBLE_STATES[product_href] &&\n        INELIGIBLE_STATES[product_href][frequency] &&\n        INELIGIBLE_STATES[product_href][frequency][dosage] &&\n        INELIGIBLE_STATES[product_href][frequency][dosage].includes(state)\n    ) {\n        return false; // User is in an ineligible state\n    }\n\n    return true; // Default to eligible if no restrictions are found\n}"
      },
      {
        "name": "stateSelectionUserEligbility",
        "kind": "function",
        "signature": "export function stateSelectionUserEligbility(\n    product_href: string,\n    state: USStates,\n) {\n    const INELIGIBLE_STATES: Record<string, USStates[]> = {\n        [PRODUCT_HREF.METFORMIN]: [USStates.NorthCarolina],\n        [PRODUCT_HREF.B12_INJECTION]: [USStates.NorthCarolina],\n        [PRODUCT_HREF.GLUTATIONE_INJECTION]: [USStates.NorthCarolina],\n        [PRODUCT_HREF.NAD_FACE_CREAM]: [USStates.NorthCarolina],\n        [PRODUCT_HREF.NAD_INJECTION]: [USStates.NorthCarolina],\n        [PRODUCT_HREF.NAD_NASAL_SPRAY]: [USStates.NorthCarolina],\n        [PRODUCT_HREF.NAD_PATCHES]: [USStates.NorthCarolina],\n        [PRODUCT_HREF.X_CHEWS]: [USStates.California],\n        [PRODUCT_HREF.X_MELTS]: [USStates.California],\n        [PRODUCT_HREF.RUSH_CHEWS]: [USStates.California],\n        [PRODUCT_HREF.RUSH_MELTS]: [USStates.California],\n    };\n\n    if (\n        INELIGIBLE_STATES[product_href] &&\n        INELIGIBLE_STATES[product_href].includes(state)\n    ) {\n        return false;\n    }\n\n    return true;\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/utils/functions/state-auth/utils.ts",
      "bioverse-client/app/components/intake-v2/ed/components/additional-options.tsx",
      "bioverse-client/app/components/intake-v2/ed/confirmation/ed-confirmation.tsx",
      "bioverse-client/app/components/intake-v2/pages/state-selection.tsx"
    ]
  },
  {
    "source": "bioverse-client/app/utils/functions/utils.ts",
    "exports": [
      {
        "name": "getURL",
        "kind": "variable",
        "signature": "getURL = async () => {\n    let url =\n        process?.env?.NEXT_PUBLIC_SITE_URL ??\n        process?.env?.NEXT_PUBLIC_VERCEL_URL ??\n        'http://localhost:3000';\n    url = url.includes('http') ? url : `https://${url}`;\n    // Remove trailing slashes using replace\n    url = url.replace(/\\/+$/, '');\n    return url;\n}"
      },
      {
        "name": "getCurrentDate",
        "kind": "function",
        "signature": "export async function getCurrentDate() {\n    const date = new Date();\n    const options: Intl.DateTimeFormatOptions = {\n        year: 'numeric', // \"numeric\" or \"2-digit\"\n        month: 'long', // \"numeric\", \"2-digit\", \"long\", \"short\", or \"narrow\"\n        day: 'numeric', // \"numeric\" or \"2-digit\"\n    };\n    const formattedDate = date.toLocaleDateString('en-US', options);\n    return formattedDate;\n}"
      },
      {
        "name": "doStuff",
        "kind": "function",
        "signature": "export async function doStuff() {\n    const supabase = createSupabaseServiceClient();\n\n    const date = new Date('2024-04-01');\n    const { data, error } = await supabase\n        .from('profiles')\n        .select('id, email')\n        .gte('created_at', '2024-04-01');\n\n    const batched = data?.map((item: any) => ({\n        type: 'person',\n        identifiers: { id: item.id },\n        action: 'identify',\n        attributes: {\n            email: item.email,\n        },\n    }));\n\n    await batchTriggerEvent({ batch: batched });\n\n    // await identifyUser(data?.id, { email: data?.email });\n    console.log('success');\n}"
      },
      {
        "name": "runScript",
        "kind": "function",
        "signature": "export async function runScript() {\n    console.log(await getCurrentDate());\n    const supabase = createSupabaseServiceClient();\n\n    const { data, error } = await supabase\n        .from('threads')\n        .select('id')\n        .is('patient_id', 'null');\n\n    console.log(data?.length);\n}"
      }
    ],
    "usedIn": [
      "bioverse-client/app/(testing_and_development)/dev/send-script-hallandale/page.tsx",
      "bioverse-client/app/utils/actions/auth/oauth.ts",
      "bioverse-client/app/utils/functions/utils.ts",
      "bioverse-client/app/utils/functions/client-utils.ts",
      "bioverse-client/app/utils/functions/rudderstack/rudderstack-utils.ts",
      "bioverse-client/app/(employee)/(provider-portal)/provider/intakes/[orderId]/page.tsx",
      "bioverse-client/app/components/coordinator-portal/tasks/utils/findNextTask.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/utils/resend-scripts.ts",
      "bioverse-client/app/components/provider-coordinator-shared/all-patients/components/patient-page/tab-components/orders/components/components/ManualOrderCreationDialog.tsx",
      "bioverse-client/app/components/provider-portal/tasks/utils/findNextTask.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/message/ai-response-helper/utils/ai-response-controller.ts",
      "bioverse-client/app/components/login/forms/v2/sign-up-form-v2.tsx",
      "bioverse-client/app/components/login/forms/signUpForm.tsx",
      "bioverse-client/app/components/login/CheckEmail.tsx",
      "bioverse-client/app/components/login/login-drawer/drawer-specific-forms/sign-up-form-drawer.tsx",
      "bioverse-client/app/components/login/ResetPassword.tsx",
      "bioverse-client/app/api/supabase/payment-failure/route.ts",
      "bioverse-client/app/services/mixpanel/mixpanel-utils.ts",
      "bioverse-client/app/services/pharmacy-integration/revive/revive-send-script-api.ts",
      "bioverse-client/app/services/pharmacy-integration/empower/provider-script-feedback.ts",
      "bioverse-client/app/services/pharmacy-integration/hallandale/hallandale-script-api.ts",
      "bioverse-client/app/services/pharmacy-integration/boothwyn/boothwyn-script-api.ts",
      "bioverse-client/app/services/pharmacy-integration/tmc/provider-script-feedback.ts",
      "bioverse-client/app/services/stripe/charge-customer.ts",
      "bioverse-client/app/utils/functions/prescription-scripts/hallandale-approval-script-generator.ts",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-creation-menu/creation-tab-content/note-creation/note-creation.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/patient-information-column/clinical-note-creation-menu/creation-tab-content/template-creation.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/belmar/belmar-prescribe-window.tsx",
      "bioverse-client/app/components/provider-portal/intake-view/v2/components/tab-column/prescribe/prescribe-windows/hallandale/hallandale-prescribe-window.tsx",
      "bioverse-client/app/api/stripe/webhook/invoice-paid/route.ts",
      "bioverse-client/app/api/stripe/subscription/create/route.ts",
      "bioverse-client/app/services/stripe/subscriptions.ts"
    ]
  },
  {
    "source": "bioverse-client/app/utils/hooks/session-storage/useSessionStorage.ts",
    "exports": [],
    "usedIn": []
  },
  {
    "source": "bioverse-client/app/utils/hooks/storage/useDualStorage.ts",
    "exports": [],
    "usedIn": []
  }
]